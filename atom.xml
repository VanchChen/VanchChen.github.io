<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vanch&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/753583210964c7a8a41496ec0dc617dc</icon>
  <subtitle>欢迎来到我的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vanchchen.github.io/"/>
  <updated>2018-10-08T08:10:13.268Z</updated>
  <id>https://vanchchen.github.io/</id>
  
  <author>
    <name>Vanch</name>
    <email>447389831@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>脚本处理iOS的Crash日志</title>
    <link href="https://vanchchen.github.io/p/2616.html"/>
    <id>https://vanchchen.github.io/p/2616.html</id>
    <published>2018-10-08T08:06:38.000Z</published>
    <updated>2018-10-08T08:10:13.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当我们打包app时，可以选择生成对应的符号表，其保存 16 进制函数地址映射信息，通过给定的函数起始地址和偏移量，可以对应函数具体信息以供分析。</p><p>所以我们拿到测试给的闪退日志(<code>.crash</code>)时，需要找到打包时对应生成的符号表(<code>.dSYM</code>)作为钥匙解析。具体分为下面几个步骤</p><ol><li><code>dwarfdump --uuid</code> 命令获取 <code>.dSYM</code> 的 <code>uuid</code></li><li>打开 <code>.crash</code> 文件，在特定位置找到 <code>uuid</code></li><li>根据 <code>arm</code> 版本比对两者是否一致</li><li><p>到 <code>Xcode</code> 目录下寻找 <code>symbolicatecrash</code> 工具</p><blockquote><p>不同版本文件路径不同，具体版本请谷歌。Xcode9路径是/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/</p></blockquote></li><li><p>设置终端环境变量</p><p> <code>export DEVELOPER_DIR=&quot;/Applications/Xcode.app/Contents/Developer&quot;</code></p></li><li>使用 <code>symbolicatecrash</code> 工具解析日志<br> <code>symbolicatecrash .crash .dsym &gt; a.out</code></li></ol><p>虽然过程不复杂，但是每次都需要手动执行一次检查与命令，过于繁琐，所以决定用脚本化提高效率。</p><hr><h2 id="步骤实现"><a href="#步骤实现" class="headerlink" title="步骤实现"></a>步骤实现</h2><h3 id="输入Crash日志"><a href="#输入Crash日志" class="headerlink" title="输入Crash日志"></a>输入Crash日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>要求输入crash文件路径</span><br><span class="line">inputFile 'Please Input Crash File' 'crash'</span><br><span class="line">crashPath=$filePath</span><br></pre></td></tr></table></figure><p>由于需要输入两种不同后缀的文件路径，且都需要检查，因此统一定义一个方法。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>定义全局变量</span><br><span class="line">filePath=</span><br><span class="line"><span class="meta">#</span>输入文件路径</span><br><span class="line">inputFile() &#123;</span><br><span class="line">    readSuccess=false</span><br><span class="line">    #首先清空变量值</span><br><span class="line">    filePath=</span><br><span class="line">    while [ $readSuccess = false ]; do </span><br><span class="line">        echo $1</span><br><span class="line">        #读取到变量中</span><br><span class="line">        read -a filePath</span><br><span class="line">        if [[ ! -e $filePath || $&#123;filePath##*.&#125; != $2 ]]; then</span><br><span class="line">            echo "Input file is not ."$2</span><br><span class="line">        else</span><br><span class="line">            readSuccess=true</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>.dSYM</code> 是文件夹路径，所以这里简单的判断了路径是否存在，如果不存在就继续让用户输入。</p><blockquote><p>Shell命令中判断分为[]与[[]]，后者比前者更通用，可以使用 || 正则运算等。</p><p>判断中，-f表示检查是否存在该文件，-d表示检查是否存在文件夹，-e表示检查是否存在该路径</p></blockquote><h3 id="输入dSYM符号表"><a href="#输入dSYM符号表" class="headerlink" title="输入dSYM符号表"></a>输入dSYM符号表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dsymSuccess=false</span><br><span class="line">while [ $dsymSuccess = false ]; do</span><br><span class="line">    #要求输入dSYM文件路径</span><br><span class="line">    inputFile 'Please Input dSYM File' 'dSYM'</span><br><span class="line">    dsymPath=$filePath</span><br><span class="line">    #检查是否匹配</span><br><span class="line">    checkUUID "$crashPath" "$dsymPath"</span><br><span class="line">    match=$?</span><br><span class="line">    if [ $match -eq 0 ]; then</span><br><span class="line">        echo 'UUID not match!'</span><br><span class="line">    else</span><br><span class="line">        dsymSuccess=true</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>循环获取匹配 <code>UUID</code> 的 <code>dSYM</code> ，这里使用了另一种方法获取方法返回值，具体之后章节会总结。</p><h3 id="查找symbolicatecrash工具"><a href="#查找symbolicatecrash工具" class="headerlink" title="查找symbolicatecrash工具"></a>查找symbolicatecrash工具</h3><p>在 <code>Xcode</code> 文件夹指定路径下查找工具，加快效率，如果没找到就停止运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查找symbolicatecrash解析工具，内置在Xcode的库文件中</span><br><span class="line">toolPath=`find /Applications/Xcode.app/Contents/SharedFrameworks -name symbolicatecrash | head -n 1`</span><br><span class="line">if [ ! -f $toolPath ]; then</span><br><span class="line">    echo "Symbolicatecrash not exist!"</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="执行解析命令"><a href="#执行解析命令" class="headerlink" title="执行解析命令"></a>执行解析命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>先设置环境变量</span><br><span class="line">export DEVELOPER_DIR="/Applications/Xcode.app/Contents/Developer"</span><br><span class="line"><span class="meta">#</span>指定解析结果路径</span><br><span class="line">crashName=`basename $crashPath`</span><br><span class="line">afterPath="$(dirname "$crashPath")"/"$&#123;crashName%%.*&#125;""_after.crash"</span><br><span class="line"><span class="meta">#</span>开始解析</span><br><span class="line"><span class="meta">$</span>toolPath "$crashPath" "$dsymPath" &gt; "$afterPath" 2&gt; /dev/null</span><br></pre></td></tr></table></figure><p>这里我将错误信息导流到 <code>/dev/null</code>，保证解析文件没有杂乱信息。</p><hr><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="怎么获取函数返回值？"><a href="#怎么获取函数返回值？" class="headerlink" title="怎么获取函数返回值？"></a>怎么获取函数返回值？</h3><p>之前没有处理过需要返回数值的方法，所以一开始有点懵，查询资料后最终采用了两种方式实现了效果，现在做一些总结。</p><h4 id="全局变量记录"><a href="#全局变量记录" class="headerlink" title="全局变量记录"></a>全局变量记录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>定义全局变量</span><br><span class="line">filePath=</span><br><span class="line">inputFile() &#123;</span><br><span class="line">    #读取到变量中</span><br><span class="line">    read -a filePath</span><br><span class="line">&#125;</span><br><span class="line">inputFile</span><br><span class="line">crashPath=$filePath</span><br></pre></td></tr></table></figure><p>通过 <code>inputFile</code> 方法来了解一下，首先定义一个全局变量为 <code>filePath</code>，在方法中重新赋值，方法结束后读取全局变量中的数据。</p><p>这种方法的好处是可以自定义返回参数类型和个数，缺点是容易和其他变量搞混。</p><h4 id="Return返回值"><a href="#Return返回值" class="headerlink" title="Return返回值"></a>Return返回值</h4><p>类似与C语言中的用法，脚本也支持 <code>retrun 0</code> 返回结果并停止运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkUUID() &#123;</span><br><span class="line">    grep "$arm64id" "$1"</span><br><span class="line">    if [ $? -ne 0 ]; then</span><br><span class="line">        return 1;</span><br><span class="line">    fi</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">checkUUID "$crashPath" "$dsymPath"</span><br><span class="line">match=$?</span><br></pre></td></tr></table></figure><p>获取结果的方式为 <code>$?</code>，其能够返回环境中最后一个指令结果，也就是之前执行的<code>checkUUID</code>的结果。</p><p>优点是简洁明了，符合编码习惯，缺点是返回值只能是 <code>0-255</code> 的数字，不能返回其他类型的数据。</p><h4 id="获取打印值"><a href="#获取打印值" class="headerlink" title="获取打印值"></a>获取打印值</h4><p>还有一种方法其实平时一直在使用，只不过并不了解其运行方式。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crashName=`basename $crashPath`</span><br><span class="line"></span><br><span class="line">print() &#123;</span><br><span class="line">    echo "Hello World"</span><br><span class="line">&#125;</span><br><span class="line">text=$(print)</span><br></pre></td></tr></table></figure></p><p>运行系统预设的方法或者自定义方法，将执行命令用 <code>$()</code> 的方式使用，就可以获取该命令中所有打印的信息，赋值到变量就可以拿到需要的返回值。</p><p>优点是功能全效率高，使用字符串的方式可以传递定制化信息，缺点是不可预期返回结果，需要通过字符串查找等命令辅助。</p><h3 id="循环输入合法路径"><a href="#循环输入合法路径" class="headerlink" title="循环输入合法路径"></a>循环输入合法路径</h3><p>在我的设想中，需要用户输入匹配的 <code>dSYM</code> 文件路径，如果不匹配，则重新输入，直到合法。为了支持嵌套，需要定义局部变量控制循环，具体代码如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dsymSuccess=false</span><br><span class="line">while [ $dsymSuccess = false ]; do</span><br><span class="line">    #要求输入dSYM文件路径</span><br><span class="line">    inputFile 'Please Input dSYM File' 'dSYM'</span><br><span class="line">    dsymPath=$filePath</span><br><span class="line">    #检查是否匹配</span><br><span class="line">    checkUUID "$crashPath" "$dsymPath"</span><br><span class="line">    match=$?</span><br><span class="line">    if [ $match -eq 0 ]; then</span><br><span class="line">        echo 'UUID not match!'</span><br><span class="line">    else</span><br><span class="line">        dsymSuccess=true</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>### 处理字符串</p><p>获取到 <code>UUID</code> 所有输出信息后，需要截取出对应平台的信息，处理还是不太熟悉，特地整理如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>原始信息</span><br><span class="line">UUID: 92E495AA-C2D4-3E9F-A759-A50AAEF446CD (armv7) /Volumes/.dSYM/Contents/Resources/DWARF/app</span><br><span class="line">UUID: 536527A8-0243-34DB-AE08-F1F64ACA4351 (arm64) /Volumes/.dSYM/Contents/Resources/DWARF/app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>去除中间间隔-</span><br><span class="line">uuid=$&#123;uuid//-/&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>从后往前找第一个匹配 \(arm64的，并且都删除</span><br><span class="line">arm64id=$&#123;uuid% \(arm64*&#125;</span><br><span class="line"><span class="meta">#</span>处理后</span><br><span class="line">UUID: 92E495AAC2D43E9FA759A50AAEF446CD (armv7) /Volumes/.dSYM/Contents/Resources/DWARF/app</span><br><span class="line">UUID: 536527A8024334DBAE08F1F64ACA4351</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>从前往后找最后一个UUID: ，并删除</span><br><span class="line">arm64id=$&#123;arm64id##*UUID: &#125;</span><br><span class="line"><span class="meta">#</span>处理后 </span><br><span class="line">536527A8024334DBAE08F1F64ACA4351</span><br></pre></td></tr></table></figure></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看似简单的脚本，也花了一天时间编写，总体还是不太熟练，仍需努力联系。</p><p>这次特地尝试了与上次不同的参数输入方法，使用提示输入的方式，果然遇到了新的问题。好在都查资料解决了，结果还算满意。</p><p>脚本我提交到了<a href="https://github.com/VanchChen/AnalysisCrash" target="_blank" rel="noopener">Github</a>，欢迎大家指教共同进步！给个关注最好啦～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;当我们打包app时，可以选择生成对应的符号表，其保存 16 进制函数地址映射信息，通过给定的函数起始地址和偏移量，可以对应函数具体信息以供分
      
    
    </summary>
    
      <category term="Shell" scheme="https://vanchchen.github.io/categories/Shell/"/>
    
    
  </entry>
  
  <entry>
    <title>AssociatedObject关联对象原理实现</title>
    <link href="https://vanchchen.github.io/p/f39e.html"/>
    <id>https://vanchchen.github.io/p/f39e.html</id>
    <published>2018-09-29T09:55:21.000Z</published>
    <updated>2018-10-08T01:55:15.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>关联对象（AssociatedObject）是Objective-C 2.0运行时的一个特性，允许开发者对已经存在的类在扩展中添加自定义的属性。在实际生产过程中，比较常用的方式是给分类（Category）添加成员变量。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> property;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"><span class="keyword">@dynamic</span> property;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)property &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setProperty:(<span class="built_in">NSString</span> *)property &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(property), property, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>通过实现代码可以稍微分析下，<code>objc_getAssociatedObject</code> 拿着不变的指针地址（示例传入selector作为参数，实际是void*），从实例中获取需要的对象。<code>objc_setAssociatedObject</code> 根据传入的参数协议，保存指定的对象。</p><h3 id="参数协议"><a href="#参数协议" class="headerlink" title="参数协议"></a>参数协议</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object. The association is made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied. The association is made atomically. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实这五个协议就是我们平时定义属性时使用的，需要注意的是，虽然苹果在注释中说 <code>OBJC_ASSOCIATION_ASSIGN</code> 相当于一个 <code>weak reference</code>，但其实等于 <code>assign/unsafe_unretained</code>。</p><p>对于与<code>weak</code>的区别不在本文讨论范围内，浅显的区别在于变量释放后，<code>weak</code> 会把引用置空，<code>unsafe_unretained</code>会保留内存地址，一旦获取可能会野指针闪退。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们知道，如果类要添加变量，只有在<code>objc_allocateClassPair</code>与<code>objc_registerClassPair</code>之间<code>addIvar</code>。等类注册后，变量结构就不允许再被改变，这是为了防止两个相同类的实例拥有不同变量导致运行困惑。</p><p>那么在runtime时给实例添加变量，又不改变类内部变量结构，关联对象就是一个比较好的做法。</p><hr><h2 id="关联对象的实现"><a href="#关联对象的实现" class="headerlink" title="关联对象的实现"></a>关联对象的实现</h2><h3 id="外部方法"><a href="#外部方法" class="headerlink" title="外部方法"></a>外部方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sets an associated value for a given object using a given key and association policy.</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> * key, <span class="keyword">id</span> value, objc_AssociationPolicy policy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Returns the value associated with a given object for a given key.</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> * key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Removes all associations for a given object.</span></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object);</span><br></pre></td></tr></table></figure><p>相比刚刚例子中的用法，多了一个<code>objc_removeAssociatedObjects</code>，那么可不可以用这个方法来删除不用的关联对象呢？</p><p>苹果的文档中解释说这个方法主要用来还原对象到类初始的状态，会移除所有的关联，包括其他模块添加的，因此应该用 <code>objc_setAssociatedObject(..,nil,..)</code> 的方式去卸载。</p><hr><h3 id="Setter实现"><a href="#Setter实现" class="headerlink" title="Setter实现"></a>Setter实现</h3><p><code>objc_setAssociatedObject</code>实际调用的是<code>_object_set_associative_reference</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</span><br><span class="line">    <span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> acquireValue(<span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (policy &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">        <span class="keyword">return</span> objc_retain(value);</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(value, SEL_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> releaseValue(<span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123;</span><br><span class="line">        <span class="keyword">return</span> objc_release(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</span><br><span class="line"><span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">    old_association = ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br></pre></td></tr></table></figure><p>我们摘出与对象内存相关的代码仔细分析下，首先把新传入的对象，根据协议进行<code>retain/copy</code>，在赋值的过程中获取旧值，在方法结束前<code>release</code>。</p><hr><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">AssociationsManager manager;</span><br><span class="line">AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line"><span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">    <span class="comment">//需要赋值</span></span><br><span class="line">    AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">    <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">        <span class="comment">//找到了这个对象的关联表</span></span><br><span class="line">        ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">        ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">        <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">            <span class="comment">//找到了这个key的关联对象</span></span><br><span class="line">            old_association = j-&gt;second;</span><br><span class="line">            j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没找到，新增一个关联</span></span><br><span class="line">            (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没找到，创建一个新的关联表</span></span><br><span class="line">        ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">        associations[disguised_object] = refs;</span><br><span class="line">        (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">        object-&gt;setHasAssociatedObjects();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先了解一下<code>AssociationsManager</code>与<code>AssociationsHashMap</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AssociationsManager &#123;</span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;</span><br><span class="line">public:</span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_map == <span class="literal">NULL</span>)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        <span class="keyword">return</span> *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ObjectAssociationMap : public std::map&lt;<span class="keyword">void</span> *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt;；</span><br></pre></td></tr></table></figure></p><p><code>AssociationsManager</code>通过一个以指针地址为主键，值为关联表的哈希表，来管理应用内所有的关联对象。</p><p>首先以对象的指针地址去寻找关联表，再通过指定的键值查找关联关系，从而获取关联对象。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line"><span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">    ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">    ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">    <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">        old_association = j-&gt;second;</span><br><span class="line">        refs-&gt;erase(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和修改方法类似，找到关联关系后，执行哈希表的<code>erase</code>方法删除。</p><hr><h3 id="Getter实现"><a href="#Getter实现" class="headerlink" title="Getter实现"></a>Getter实现</h3><p><code>objc_getAssociatedObject</code>实际调用的是<code>_object_get_associative_reference</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    <span class="keyword">uintptr_t</span> policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value();</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</span><br><span class="line">                    objc_retain(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        objc_autorelease(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找哈希表的方法和Setter一样，区别在于如果策略中需要retain和autorelease的话，都需要处理。那么是怎么约定这些策略呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; </span><br><span class="line">    OBJC_ASSOCIATION_SETTER_ASSIGN      = <span class="number">0</span>,</span><br><span class="line">    OBJC_ASSOCIATION_SETTER_RETAIN      = <span class="number">1</span>,</span><br><span class="line">    OBJC_ASSOCIATION_SETTER_COPY        = <span class="number">3</span>,            <span class="comment">// <span class="doctag">NOTE:</span>  both bits are set, so we can simply test 1 bit in releaseValue below.</span></span><br><span class="line">    OBJC_ASSOCIATION_GETTER_READ        = (<span class="number">0</span> &lt;&lt; <span class="number">8</span>), </span><br><span class="line">    OBJC_ASSOCIATION_GETTER_RETAIN      = (<span class="number">1</span> &lt;&lt; <span class="number">8</span>), </span><br><span class="line">    OBJC_ASSOCIATION_GETTER_AUTORELEASE = (<span class="number">2</span> &lt;&lt; <span class="number">8</span>)</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">OBJC_ENUM</span><span class="params">(<span class="keyword">uintptr_t</span>, objc_AssociationPolicy)</span> </span>&#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>, </span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>OBJC_ASSOCIATION_RETAIN = 01401</code>，其中<code>01401</code>开头是<code>0</code>，所以是八进制数字，翻译为二进制就是<code>0000 0011 0000 0001</code>，取位判断就是<code>OBJC_ASSOCIATION_SETTER_RETAIN</code> <code>OBJC_ASSOCIATION_GETTER_RETAIN</code> <code>OBJC_ASSOCIATION_GETTER_AUTORELEASE</code>。</p><p>在保存的时候，需要<code>retain</code>，在获取的时候，需要先<code>retain</code>增加引用计数，再执行<code>autorelease</code>等待释放，从而实现原子性。</p><h3 id="Remove实现"><a href="#Remove实现" class="headerlink" title="Remove实现"></a>Remove实现</h3><p><code>objc_removeAssociatedObjects</code>会判断对象是否存在关联，然后再执行<code>_object_set_associative_reference</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_remove_assocations(id object) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            <span class="keyword">delete</span> refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现方式也可以看出为什么在介绍里不推荐使用，因为会遍历所有的关联对象，并且全部释放，可能会造成别的模块功能缺陷。</p><h4 id="判断关联对象"><a href="#判断关联对象" class="headerlink" title="判断关联对象"></a>判断关联对象</h4><p>比较有意思的是判断对象是否有关联对象的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> objc_object::hasAssociatedObjects()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (isa.nonpointer) <span class="keyword">return</span> isa.has_assoc;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> objc_object::setHasAssociatedObjects()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">isa_t</span> oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    <span class="keyword">isa_t</span> newisa = oldisa;</span><br><span class="line">    <span class="keyword">if</span> (!newisa.nonpointer  ||  newisa.has_assoc) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newisa.has_assoc = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认返回的结果都是<code>true</code>，只有在64位系统下，才保存一个标记位。这么处理我推测是为了加快释放周期速度，在析构对象时，会根据这个方法判断是否需要释放关联对象。试想如果每次都查询哈希表，执行效率必定会降低，不如都先通过，之后再做处理。</p><blockquote><p>关于<code>nonpointer</code>不在本文介绍范围内，简单描述为在64位系统下，指针地址保存不仅仅为内存地址，还存有其他标记信息，包括本文涉及的has_assoc。</p><p><code>taggedPointer</code>是一种优化策略，把简单的数字或字符串信息直接保存在指针地址中，从而不申请额外内存加快运行效率。</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>关联对象的实现不复杂，保存的方式为一个全局的哈希表，存取都通过查询表找到关联来执行。哈希表的特点就是牺牲空间换取时间，所以执行速度也可以保证。</p><hr><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><h3 id="关联对象有什么应用？"><a href="#关联对象有什么应用？" class="headerlink" title="关联对象有什么应用？"></a>关联对象有什么应用？</h3><p>关联对象可以在运行时给指定对象绑定一个有生命周期的变量。</p><p>1.由于不改变原类的实现，所以可以给原生类或者是打包的库进行扩展，一般配合Category实现完整的功能。</p><p>2.ObjC类定义的变量，由于runtime的特性，都会暴露到外部，使用关联对象可以隐藏关键变量，保证安全。</p><p>3.可以用于KVO，使用关联对象作为观察者，可以避免观察自身导致循环。</p><h3 id="系统如何管理关联对象？"><a href="#系统如何管理关联对象？" class="headerlink" title="系统如何管理关联对象？"></a>系统如何管理关联对象？</h3><p>系统通过管理一个全局哈希表，通过对象指针地址和传递的固定参数地址来获取关联对象。根据<code>setter</code>传入的参数协议，来管理对象的生命周期。</p><h3 id="其被释放的时候需要手动将其指针置空么？"><a href="#其被释放的时候需要手动将其指针置空么？" class="headerlink" title="其被释放的时候需要手动将其指针置空么？"></a>其被释放的时候需要手动将其指针置空么？</h3><p>当对象被释放时，如果设置的协议是<code>OBJC_ASSOCIATION_ASSIGN</code>，那么他的关联对象不会减少引用计数，其他的协议都会减少从而释放关联对象。</p><p><code>unsafe_unretain</code>一般认为外部有对象控制，所以对象不用处理，因此不管什么协议，对象释放时都无需手动讲关联对象置空。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;关联对象（AssociatedObject）是Objective-C 2.0运行时的一个特性，允许开发者对已经存在的类在扩展中添加自定义的属
      
    
    </summary>
    
      <category term="iOS" scheme="https://vanchchen.github.io/categories/iOS/"/>
    
    
      <category term="原理分析" scheme="https://vanchchen.github.io/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>初试Shell脚本</title>
    <link href="https://vanchchen.github.io/p/3f22.html"/>
    <id>https://vanchchen.github.io/p/3f22.html</id>
    <published>2018-09-20T08:45:12.000Z</published>
    <updated>2018-10-08T01:55:15.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>临上线前测试比较努力，遇到闪退或者其他问题，会把日志包打给我，由于app内存限制，目前每次打包都是1m大小，所以有时查找问题的上下文比较吃力。同时由于日志比较多，根据关键词过滤的需求越来越重要。</p><p>于是决定学写脚本完成这个任务，根据我的要求，工作流程应该是传入压缩包，根据后缀名解压，根据日期排序后合并成一个文件，按需过滤关键词。</p><hr><h2 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/usr/bin/env bash</span><br><span class="line"><span class="meta">#</span> Created By Vanch at 2018/9/20</span><br><span class="line"></span><br><span class="line">printHelp() &#123;</span><br><span class="line">    echo "Uncompess log files from inputed zip"</span><br><span class="line">    echo "Then Merge these logs to one file"</span><br><span class="line">    echo "Supported file types: zip tar tar.gz tar.bz2"</span><br><span class="line">    echo</span><br><span class="line">    echo "Use -s for filtering socket result to socket.log"</span><br><span class="line">    echo </span><br><span class="line">    echo "Have fun!"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>如果没输入参数，就打印帮助信息</span><br><span class="line">if [ $# -eq 0 ]; then</span><br><span class="line">    printHelp</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>把长选项转到短选项</span><br><span class="line">for arg in "$@"; do</span><br><span class="line">  shift</span><br><span class="line">  case "$arg" in</span><br><span class="line">    "--help")       set -- "$@" "-h" ;;</span><br><span class="line">    "--version")    set -- "$@" "-v" ;;</span><br><span class="line">    "--list")       set -- "$@" "-l" ;;</span><br><span class="line">    *)              set -- "$@" "$arg"</span><br><span class="line">  esac</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span>获取短选项</span><br><span class="line">OPTIND=1</span><br><span class="line">printS=false;</span><br><span class="line">while getopts "dmksahvl" opt; do</span><br><span class="line">    case $opt in</span><br><span class="line">        h) #输入为help，就打印帮助信息</span><br><span class="line">            printHelp</span><br><span class="line">            exit 0;;</span><br><span class="line">        l) #支持单独获取支持文件后缀列表</span><br><span class="line">            echo "Supported file types: zip tar tar.gz tar.bz2"</span><br><span class="line">            exit 0;;</span><br><span class="line">        v) #支持查找版本号</span><br><span class="line">            echo "1.0.0"</span><br><span class="line">            exit 0;;</span><br><span class="line">        s) #过滤Socket</span><br><span class="line">            printS=true;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>获得压缩包地址</span><br><span class="line">file=$&#123;!#&#125;</span><br><span class="line"><span class="meta">#</span>如果不存在就退出</span><br><span class="line">if [ ! -f "$file" ]; then</span><br><span class="line">    echo "File not exist!"</span><br><span class="line">    exit 0;</span><br><span class="line">fi </span><br><span class="line"><span class="meta">#</span>获取压缩后缀</span><br><span class="line">fileName=`basename $file`</span><br><span class="line">suffix=$&#123;fileName#*.&#125;</span><br><span class="line"><span class="meta">#</span>判断文件类型</span><br><span class="line">support=('tar','tar.gz','tar.bz2','zip')</span><br><span class="line">if [ -z `echo "$&#123;support[@]&#125;" | grep -w "$suffix"` ] ; then</span><br><span class="line">    echo "File type not support!"</span><br><span class="line">    exit 0;    </span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span>拼接文件夹地址</span><br><span class="line">fileDir=$(dirname $file)/$&#123;fileName%%.*&#125;</span><br><span class="line">if [ -d $fileDir ]; then</span><br><span class="line">    rm -rf $fileDir</span><br><span class="line">fi</span><br><span class="line">mkdir $fileDir</span><br><span class="line">cd $fileDir</span><br><span class="line"><span class="meta">#</span>解压文件</span><br><span class="line">case $suffix in</span><br><span class="line">    'tar')</span><br><span class="line">        eval "tar xvf $file &gt; /dev/null 2&gt;&amp;1";;</span><br><span class="line">    'tar.gz')</span><br><span class="line">        eval "tar zxvf $file &gt; /dev/null 2&gt;&amp;1";;</span><br><span class="line">    'tar.bz2')</span><br><span class="line">        eval "tar jxvf $file &gt; /dev/null 2&gt;&amp;1";;</span><br><span class="line">    'zip')</span><br><span class="line">        eval "unzip -o $file &gt; /dev/null 2&gt;&amp;1";;</span><br><span class="line">esac</span><br><span class="line">echo 'Uncompass Success!'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>获取日志列表，按排序合并到一个日志</span><br><span class="line">mergeFile=./merge.log</span><br><span class="line">logCount=0</span><br><span class="line"><span class="meta">#</span>搜索com开头的日志，按日期排序，用？临时代替空格</span><br><span class="line">for logName in `ls | grep 'com' | sort -n | tr " " "?"`; do</span><br><span class="line">    logName=$&#123;logName//'?'/' '&#125;</span><br><span class="line">    cat ./"$logName" &gt;&gt; $mergeFile</span><br><span class="line">    ((logCount++))</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span>不存在日志就打断</span><br><span class="line">if [ $logCount -eq 0 ]; then</span><br><span class="line">    echo "Log not exist!"</span><br><span class="line">    exit </span><br><span class="line">fi</span><br><span class="line">echo 'Merge Success!'</span><br><span class="line"><span class="meta">#</span>打印socket</span><br><span class="line">if [ $printS = true ]; then</span><br><span class="line">    cat $mergeFile | grep -i 'socket' &gt;&gt; ./socket.log</span><br><span class="line">    echo 'Filter socket'</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><hr><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>查询了很多资料后写完了这个脚本，基本满足了我的需求，下面总结一下怎么解决遇到的问题。</p><h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><p>一开始学脚本时，书上都说<code>#! /bin/bash</code>，但是看项目中大神写的脚本，都是<code>#!/usr/bin/env bash</code>，有什么区别呢？</p><blockquote><p>脚本用env启动的原因，是因为脚本解释器在linux中可能被安装于不同的目录，env可以在系统的PATH目录中查找。<br>同时，env还规定一些系统环境变量。</p></blockquote><p>不同的系统，解释器的路径可能也不同，所以使用绝对路径是比较危险的方式。通过从环境中查找，可以保证兼容性。</p><hr><h3 id="获取选项"><a href="#获取选项" class="headerlink" title="获取选项"></a>获取选项</h3><p>开发中我们经常用到命令，这些命令一般都配合选项达到不同的效果，比如最常用的<code>ls -al</code>，通过<code>-a</code>来指定结果包含隐藏文件，通过<code>-l</code>达到列表显示的效果。</p><p>通过查询相关资料，我发现获取选项普遍的做法是使用<code>getopts</code>命令，但是这个方法只能获取<code>-h</code>这种短选项，对于<code>--help</code>长选项就不行。</p><p>第一种办法是换成<code>getopt</code>命令，但是并不是每个系统都支持这个命令。具体使用和<code>getopts</code>类似，比如<code>getopt -o ab:c -l a-long:b-long</code></p><p>第二种方法是把支持的长命令转成短命令，我使用的就是这种方式，相对来说比较容易理解，且case写的比较统一。通过<code>shift</code>取出参数，再<code>set --</code>的方式重写，最后<code>OPTIND=1</code>把指针指回第一个选项。</p><hr><h3 id="文件路径和文件后缀"><a href="#文件路径和文件后缀" class="headerlink" title="文件路径和文件后缀"></a>文件路径和文件后缀</h3><p>按需求需要判断后缀名来解压，那么就需要判断<code>tar.gz</code>之类的问题。同时，如果传入的文件目录是隐藏目录，也会造成一定的障碍。我们假设传入文件路径为<code>/a/.b/c.tar.gz</code>。</p><blockquote><p>${param#pattern}    从param前面删除pattern的最小匹配<br>${param##pattern}    从param前面删除pattern的最大匹配<br>${param%pattern}    从param后面删除pattern的最小匹配<br>${param%%pattern}    从param后面删除pattern的最大匹配</p></blockquote><p>如果按照<code>${fileName##*.}</code>来截取，那么只能拿到<code>gz</code>。<br>如果按照<code>${fileName#*.}</code>来截取，拿到的又是<code>b/c.tar.gz</code>。那怎么办呢？</p><p>好在有<code>dirname</code>可以直接获取文件路径，<code>basename</code>拿到文件名，单独对文件名进行<code>${fileName#*.}</code>就可以拿到<code>tar.gz</code>了。</p><hr><h3 id="去除不必要的打印"><a href="#去除不必要的打印" class="headerlink" title="去除不必要的打印"></a>去除不必要的打印</h3><p>执行解压命令时，会打印解压步骤，一般来说也需要显示，那如果我们不想要打印出来呢？有一个办法就是在命令之后加上<code>&gt; /dev/null 2&gt;&amp;1</code></p><blockquote><p>/dev/null ：代表空设备文件</p><p>>  ：代表重定向到哪里，例如：echo “123” &gt; /home/123.txt</p><p>1  ：表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null”</p><p>2  ：表示stderr标准错误</p><p>&amp;  ：表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1</p></blockquote><p>所以含义就是把命令输出结果和错误输出重定向，使得输出不在当前屏幕显示，由于null比较特殊，向这个文件输入等于进入黑洞，因此达到效果。</p><hr><h3 id="数组与空格"><a href="#数组与空格" class="headerlink" title="数组与空格"></a>数组与空格</h3><p>使用<code>ls | grep</code>的方式来过滤结果获取文件名数组的最大问题是，如果文件名包含空格，那么前后会被分割成两个单元，导致处理比较困难。</p><p>比较讨巧的方法是临时用特殊符号代替空格，在使用时再替换回来。这种方法不会改变文件名，也不用写复杂的数组合并，比较符合简单的设计。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tr " " "?"</span><br><span class="line"><span class="meta">$</span>&#123;logName//'?'/' '&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次简单的脚本实验，对shell有了新的认识，及时记录遇到的问题，相信下次会更有印象。使用脚本，可以让工作更有效率，相信以后也会越用越多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;临上线前测试比较努力，遇到闪退或者其他问题，会把日志包打给我，由于app内存限制，目前每次打包都是1m大小，所以有时查找问题的上下文比较
      
    
    </summary>
    
      <category term="Shell" scheme="https://vanchchen.github.io/categories/Shell/"/>
    
    
  </entry>
  
  <entry>
    <title>Category探索</title>
    <link href="https://vanchchen.github.io/p/5cb0.html"/>
    <id>https://vanchchen.github.io/p/5cb0.html</id>
    <published>2018-09-17T07:29:29.000Z</published>
    <updated>2018-10-08T01:55:15.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Category"><a href="#什么是Category" class="headerlink" title="什么是Category?"></a>什么是Category?</h2><p>Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已经存在的类添加方法，一般称为分类，文件名格式是”NSObject+A.h”。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">    <span class="keyword">struct</span> property_list_t *_classProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结构能看出分类可以扩展实例方法列表、类方法列表、协议列表，也支持扩展属性，但不支持扩展成员变量（之后会说）。</p><p>一般使用的场景有扩展现有类方法、代码分区、添加私有方法（不对外暴露category.h）、模拟多继承（使用关联对象的方式添加属性实现）</p><hr><h2 id="什么是Extension？"><a href="#什么是Extension？" class="headerlink" title="什么是Extension？"></a>什么是Extension？</h2><p>Extension一般被称为类扩展、匿名分类，用于定义私有属性和方法，不可被继承。只能依附自定义类写于.m中，定义一般为:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line">@property (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>类扩展支持写在多个.h文件，但都必须在.m文件中引用，且不能有自己的实现。</p><p>类扩展很多时候会与分类搞混，我在文后问答环节详细整理了他们的区别。</p><hr><h2 id="Category如何加载的？"><a href="#Category如何加载的？" class="headerlink" title="Category如何加载的？"></a>Category如何加载的？</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    class_data_bits_t bits; </span><br><span class="line">    class_rw_t *data() &#123;</span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars; <span class="comment">//只有ro才有实例变量表</span></span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先简单了解一下Class对象的结构，每个<code>objc_class</code>都包含有<code>class_data_bits_t</code>数据位，其中储存了<code>class_rw_t</code>的指针地址和一些其他标记。<code>class_rw_t</code>中包含有属性方法协议列表，以及<code>class_ro_t</code>指针地址。而在<code>class_ro_t</code>结构中，储存的是编译器决定的属性方法协议。</p><h3 id="那么是怎么运行的呢？"><a href="#那么是怎么运行的呢？" class="headerlink" title="那么是怎么运行的呢？"></a>那么是怎么运行的呢？</h3><p>在编译期类的结构中的<code>class_data_bits_t</code>指向的是一个 <code>class_ro_t</code>指针。</p><p>在运行时调用<code>realizeClass</code>方法，初始化一个<code>class_rw_t</code>结构体，设置ro值为原数据中的<code>class_ro_t</code>后设为数据位中的指向，最后调用<code>methodizeClass</code>方法加载。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> methodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line">    auto ro = rw-&gt;ro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从ro中加载方法表</span></span><br><span class="line">    method_list_t *list = ro-&gt;baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;list, <span class="number">1</span>, <span class="literal">YES</span>, isBundleClass(cls));</span><br><span class="line">        rw-&gt;methods.attachLists(&amp;list, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加载属性</span></span><br><span class="line">    property_list_t *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加载协议</span></span><br><span class="line">    protocol_list_t *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">        rw-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基类添加初始化方法</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, <span class="string">""</span>, <span class="literal">NO</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加载分类</span></span><br><span class="line">    category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</span><br><span class="line">    attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don't flush caches*/</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cats) free(cats);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在<code>methodizeClass</code>中加载了原先类在编译期决定的方法属性和协议，然后获取了未连接的分类表，将列表中的扩展方法添加到运行期类中。</p><hr><h2 id="Category方法覆盖"><a href="#Category方法覆盖" class="headerlink" title="Category方法覆盖"></a>Category方法覆盖</h2><p>如果不同的分类实现了相同名字的方法，那么调用时会使用最后加入的实现，这是为什么呢？</p><h3 id="加载Category"><a href="#加载Category" class="headerlink" title="加载Category"></a>加载Category</h3><p>dyld链接并初始化二进制文件后，交由<code>ImageLoader</code>读取，接着通知<code>runtime</code>处理，<code>runtime</code>调用<code>map_images</code>解析，然后执行<code>_read_images</code>分析文件中包含的类和分类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载分类</span></span><br><span class="line">category_t **catlist = </span><br><span class="line">    _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line"><span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    category_t *cat = catlist[i];</span><br><span class="line">    Class cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">        <span class="comment">//分类指定的类还没加载，可能是链接库顺序的问题</span></span><br><span class="line">        catlist[i] = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加分类到类的分类表中，伺机重载入</span></span><br><span class="line">    <span class="keyword">bool</span> classExists = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">        ||  cat-&gt;instanceProperties) </span><br><span class="line">    &#123;</span><br><span class="line">        addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">            remethodizeClass(cls);</span><br><span class="line">            classExists = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加分类到元类中</span></span><br><span class="line">    <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">        ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">    &#123;</span><br><span class="line">        addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">            remethodizeClass(cls-&gt;ISA());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加方法属性和协议"><a href="#添加方法属性和协议" class="headerlink" title="添加方法属性和协议"></a>添加方法属性和协议</h3><p>如果有新增的分类，就分别添加到原类和meta类，并通过<code>remethodizeClass</code>更新，具体就是调用<code>attachCategories</code>方法把分类中所有的方法都添加到指定类中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attachCategories</span><span class="params">(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新建数组指针</span></span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;<span class="comment">//倒序获取最新的分类</span></span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</span><br><span class="line">        <span class="comment">//分别获取列表</span></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">    <span class="comment">//加载列表到rw中</span></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    <span class="built_in">free</span>(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    <span class="built_in">free</span>(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    <span class="built_in">free</span>(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                    oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">            <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">            List* oldList = <span class="built_in">list</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到最后调用了<code>rw-&gt;methods.attachLists(mlists, mcount);</code> 把新增分类中的方法列表添加到实际运行时查询的方法列表头部。</p><p>在进行方法调用时会从头部查询，一旦查到后就返回结果，因此后编译的文件中的方法会被优先调用。</p><p>同时之前添加的方法实现也保存了，可以通过获取同名方法的方式查找原类的实现。</p><hr><h2 id="Category实现属性"><a href="#Category实现属性" class="headerlink" title="Category实现属性"></a>Category实现属性</h2><h3 id="分类不能添加成员变量"><a href="#分类不能添加成员变量" class="headerlink" title="分类不能添加成员变量"></a>分类不能添加成员变量</h3><p>属性（Property）包含了成员变量（Ivar）和Setter&amp;Getter。</p><p>可以在分类中定义属性，但由于分类是在运行时添加分类属性到类的属性列表中，所以并没有创建对应的成员变量和方法实现。</p><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>如果我们想让分类实现添加新的属性，一般都通过关联对象的方式。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明文件</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestObject</span> (<span class="title">Category</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *object;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现文件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">const</span> kAssociatedObjectKey = (<span class="keyword">void</span> *)&amp;kAssociatedObjectKey;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestObject</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSObject</span> *)object &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, kAssociatedObjectKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="built_in">NSObject</span> *)object &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, kAssociatedObjectKey, object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>这种方式可以实现存取对象，但是不能获取<code>_object</code>变量。</p><hr><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><h3 id="分类和扩展有什么区别？"><a href="#分类和扩展有什么区别？" class="headerlink" title="分类和扩展有什么区别？"></a>分类和扩展有什么区别？</h3><p>1.分类多用于扩展方法实现，类扩展多用于申明私有变量和方法。</p><p>2.类扩展作用在编译期，直接和原类在一起，而分类作用在运行时，加载类的时候动态添加到原类中。</p><p>3.类扩展可以定义属性，分类中定义的属性只会申明setter/getter，并没有相关实现和变量。</p><h3 id="分类有哪些局限性？"><a href="#分类有哪些局限性？" class="headerlink" title="分类有哪些局限性？"></a>分类有哪些局限性？</h3><p>1.分类只能给现有的类加方法或协议，不能添加实例变量（ivar）。</p><p>2.分类添加的方法如果与现有的重名，会覆盖原有方法的实现。如果多个分类方法都重名，则根据编译顺序执行最后一个。</p><h3 id="分类的结构体里面有哪些成员？"><a href="#分类的结构体里面有哪些成员？" class="headerlink" title="分类的结构体里面有哪些成员？"></a>分类的结构体里面有哪些成员？</h3><p>分类结构体包含了分类名，绑定的类，实例与类方法列表，实例与类方法属性以及协议表。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">深入理解Objective-C：Category</a></p><p><a href="https://halfrost.com/objc_runtime_isa_class/" target="_blank" rel="noopener">神经病院 Objective-C Runtime 入院第一天—— isa 和 Class</a></p><p><a href="https://www.jianshu.com/p/0dc2513e117b" target="_blank" rel="noopener">探秘Runtime - 深入剖析Category</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Category&quot;&gt;&lt;a href=&quot;#什么是Category&quot; class=&quot;headerlink&quot; title=&quot;什么是Category?&quot;&gt;&lt;/a&gt;什么是Category?&lt;/h2&gt;&lt;p&gt;Category是Objective-C 2.0之后添加的语
      
    
    </summary>
    
      <category term="iOS" scheme="https://vanchchen.github.io/categories/iOS/"/>
    
    
      <category term="原理分析" scheme="https://vanchchen.github.io/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题</title>
    <link href="https://vanchchen.github.io/p/6ea5.html"/>
    <id>https://vanchchen.github.io/p/6ea5.html</id>
    <published>2018-09-14T09:40:01.000Z</published>
    <updated>2018-10-08T09:19:25.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文借鉴整理了iOS高级开发常见的面试题，并且分博客一一分析，希望能和大家一起进步学习。</p><p>欢迎大家关注我的 <a href="https://github.com/VanchChen" target="_blank" rel="noopener">Github</a>👏以及相关博客 <a href="https://www.jianshu.com/u/a3a36cfc4cb6" target="_blank" rel="noopener">简书</a> <a href="https://www.cnblogs.com/vanch/" target="_blank" rel="noopener">博客园</a></p><p>大家的鼓励是我前进的动力😄</p><h2 id="iOS基础题"><a href="#iOS基础题" class="headerlink" title="iOS基础题"></a>iOS基础题</h2><ol><li>分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？<br> <a href="https://vanchchen.github.io/p/5cb0.html">Category探索</a></li><li>讲一下atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？</li><li>被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？</li><li>关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将其指针置空么？<br> <a href="https://vanchchen.github.io/p/f39e.html">AssociatedObject关联对象原理实现</a></li><li>KVO的底层实现？如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？</li><li><code>Autoreleasepool</code>所使用的数据结构是什么？<code>AutoreleasePoolPage</code>结构体了解么？</li><li>讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的？为什么对象方法没有保存的对象结构体里，而是保存在类对象的结构体里？</li><li><code>class_ro_t</code> 和  <code>class_rw_t</code> 的区别？</li><li>iOS 中内省的几个方法？<code>class</code>方法和<code>objc_getClass</code>方法有什么区别?</li><li>在运行时创建类的方法<code>objc_allocateClassPair</code>的方法名尾部为什么是pair（成对的意思）？</li><li>一个int变量被<code>__block</code>修饰与否的区别？<br>\12. 为什么在block外部使用<code>__weak</code>修饰的同时需要在内部使用<code>__strong</code>修饰？</li><li>RunLoop的作用是什么？它的内部工作机制了解么？（最好结合线程和内存管理来说）</li><li>哪些场景可以触发离屏渲染？（知道多少说多少）</li></ol><hr><h2 id="iOS-实战题"><a href="#iOS-实战题" class="headerlink" title="iOS 实战题"></a>iOS 实战题</h2><ol><li>AppDelegate如何瘦身？</li><li>反射是什么？可以举出几个应用场景么？（知道多少说多少）</li><li>有哪些场景是NSOperation比GCD更容易实现的？（或是NSOperation优于GCD的几点，知道多少说多少）</li><li>App 启动优化策略？最好结合启动流程来说（main()函数的执行前后都分别说一下，知道多少说多少）</li><li>App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？（知道多少说多少）</li><li>你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？（知道多少说多少）</li><li>你知道有哪些情况会导致app卡顿，分别可以用什么方法来避免？（知道多少说多少）</li></ol><hr><h2 id="网络题"><a href="#网络题" class="headerlink" title="网络题"></a>网络题</h2><ol><li>App 网络层有哪些优化策略？</li><li>TCP为什么要三次握手，四次挥手？</li><li>对称加密和非对称加密的区别？分别有哪些算法的实现？</li><li>HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么？</li><li>HTTPS是如何实现验证身份和验证完整性的？</li><li>如何用Charles抓HTTPS的包？其中原理和流程是什么？</li><li>什么是中间人攻击？如何避免？</li></ol><hr><h2 id="计算机系统题"><a href="#计算机系统题" class="headerlink" title="计算机系统题"></a>计算机系统题</h2><ol><li>了解编译的过程么？分为哪几个步骤？</li><li>静态链接了解么？静态库和动态库的区别？</li><li>内存的几大区域，各自的职能分别是什么？</li><li>static和const有什么区别？</li><li>了解内联函数么？</li><li>什么时候会出现死锁？如何避免？</li><li>说一说你对线程安全的理解？</li><li>列举你知道的线程同步策略？</li><li>有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说</li></ol><hr><h2 id="设计模式题"><a href="#设计模式题" class="headerlink" title="设计模式题"></a>设计模式题</h2><ol><li>除了单例，观察者设计模式以外，还知道哪些设计模式？分别介绍一下</li><li>最喜欢哪个设计模式？为什么？</li><li>iOS SDK 里面有哪些设计模式的实践？</li><li>**设计模式是为了解决什么问题的？</li><li>**设计模式的成员构成以及工作机制是什么？</li><li>**设计模式的优缺点是什么？</li></ol><hr><h2 id="架构-amp-设计题"><a href="#架构-amp-设计题" class="headerlink" title="架构 &amp; 设计题"></a>架构 &amp; 设计题</h2><ol><li>MVC和MVVM的区别？MVVM和MVP的区别？</li><li>面向对象的几个设计原则了解么？最好可以结合场景来说。</li><li>可以说几个重构的技巧么？你觉得重构适合什么时候来做？</li><li>你觉得框架和设计模式的区别是什么？</li><li>看过哪些第三方框架的源码，它们是怎么设计的？设计好的地方在哪里，不好的地方在哪里，如何改进？（这道题的后三个问题的难度已经很高了，如果不是太N的公司不建议深究）</li></ol><hr><h2 id="数据结构-amp-算法题"><a href="#数据结构-amp-算法题" class="headerlink" title="数据结构&amp;算法题"></a>数据结构&amp;算法题</h2><ol><li>链表和数组的区别是什么？插入和查询的时间复杂度分别是多少？</li><li>哈希表是如何实现的？如何解决地址冲突？</li><li>排序题：冒泡排序，选择排序，插入排序，快速排序（二路，三路）能写出那些？</li><li>链表题：如何检测链表中是否有环？如何删除链表中等于某个值的所有节点？</li><li>数组题：如何在有序数组中找出和等于给定值的两个元素？如何合并两个有序的数组之后保持有序？</li><li>二叉树题：如何反转二叉树？如何验证两个二叉树是完全相等的？</li></ol><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://mp.weixin.qq.com/s/-cefmEo7RcZ5wifXX8JB5g" target="_blank" rel="noopener">出一套 iOS 高级面试题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文借鉴整理了iOS高级开发常见的面试题，并且分博客一一分析，希望能和大家一起进步学习。&lt;/p&gt;
&lt;p&gt;欢迎大家关注我的 &lt;a href=&quot;
      
    
    </summary>
    
      <category term="iOS" scheme="https://vanchchen.github.io/categories/iOS/"/>
    
    
      <category term="面试" scheme="https://vanchchen.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
