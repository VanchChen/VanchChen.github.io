<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vanch&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vanchchen.github.io/"/>
  <updated>2018-09-29T09:58:35.843Z</updated>
  <id>https://vanchchen.github.io/</id>
  
  <author>
    <name>Vanch</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AssociatedObject关联对象原理实现</title>
    <link href="https://vanchchen.github.io/2018/09/29/AssociatedObject%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0/"/>
    <id>https://vanchchen.github.io/2018/09/29/AssociatedObject原理实现/</id>
    <published>2018-09-29T09:55:21.000Z</published>
    <updated>2018-09-29T09:58:35.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>关联对象（AssociatedObject）是Objective-C 2.0运行时的一个特性，允许开发者对已经存在的类在扩展中添加自定义的属性。在实际生产过程中，比较常用的方式是给分类（Category）添加成员变量。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> property;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></div><div class="line"><span class="keyword">@dynamic</span> property;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)property &#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setProperty:(<span class="built_in">NSString</span> *)property &#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(property), property, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>通过实现代码可以稍微分析下，<code>objc_getAssociatedObject</code> 拿着不变的指针地址（示例传入selector作为参数，实际是void*），从实例中获取需要的对象。<code>objc_setAssociatedObject</code> 根据传入的参数协议，保存指定的对象。</p><h3 id="参数协议"><a href="#参数协议" class="headerlink" title="参数协议"></a>参数协议</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</div><div class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. The association is not made atomically. */</span></div><div class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. The association is not made atomically. */</span></div><div class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object. The association is made atomically. */</span></div><div class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied. The association is made atomically. */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>其实这五个协议就是我们平时定义属性时使用的，需要注意的是，虽然苹果在注释中说 <code>OBJC_ASSOCIATION_ASSIGN</code> 相当于一个 <code>weak reference</code>，但其实等于 <code>assign/unsafe_unretained</code>。</p><p>对于与<code>weak</code>的区别不在本文讨论范围内，浅显的区别在于变量释放后，<code>weak</code> 会把引用置空，<code>unsafe_unretained</code>会保留内存地址，一旦获取可能会野指针闪退。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们知道，如果类要添加变量，只有在<code>objc_allocateClassPair</code>与<code>objc_registerClassPair</code>之间<code>addIvar</code>。等类注册后，变量结构就不允许再被改变，这是为了防止两个相同类的实例拥有不同变量导致运行困惑。</p><p>那么在runtime时给实例添加变量，又不改变类内部变量结构，关联对象就是一个比较好的做法。</p><hr><h2 id="关联对象的实现"><a href="#关联对象的实现" class="headerlink" title="关联对象的实现"></a>关联对象的实现</h2><h3 id="外部方法"><a href="#外部方法" class="headerlink" title="外部方法"></a>外部方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Sets an associated value for a given object using a given key and association policy.</span></div><div class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> * key, <span class="keyword">id</span> value, objc_AssociationPolicy policy);</div><div class="line"></div><div class="line"><span class="comment">//Returns the value associated with a given object for a given key.</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> * key);</div><div class="line"></div><div class="line"><span class="comment">//Removes all associations for a given object.</span></div><div class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object);</div></pre></td></tr></table></figure><p>相比刚刚例子中的用法，多了一个<code>objc_removeAssociatedObjects</code>，那么可不可以用这个方法来删除不用的关联对象呢？</p><p>苹果的文档中解释说这个方法主要用来还原对象到类初始的状态，会移除所有的关联，包括其他模块添加的，因此应该用 <code>objc_setAssociatedObject(..,nil,..)</code> 的方式去卸载。</p><hr><h3 id="Setter实现"><a href="#Setter实现" class="headerlink" title="Setter实现"></a>Setter实现</h3><p><code>objc_setAssociatedObject</code>实际调用的是<code>_object_set_associative_reference</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy) &#123;</div><div class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></div><div class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</div><div class="line">    <span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</div><div class="line">    &#123;</div><div class="line">        AssociationsManager manager;</div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class="line">        <span class="keyword">if</span> (new_value) &#123;</div><div class="line">            <span class="comment">// break any existing association.</span></div><div class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</div><div class="line">                <span class="comment">// secondary table exists</span></div><div class="line">                ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</div><div class="line">                    old_association = j-&gt;second;</div><div class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// create the new association (first time).</span></div><div class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</div><div class="line">                associations[disguised_object] = refs;</div><div class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">                object-&gt;setHasAssociatedObjects();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// setting the association to nil breaks the association.</span></div><div class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</div><div class="line">                ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</div><div class="line">                    old_association = j-&gt;second;</div><div class="line">                    refs-&gt;erase(j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// release the old value (outside of the lock).</span></div><div class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> acquireValue(<span class="keyword">id</span> value, uintptr_t policy) &#123;</div><div class="line">    <span class="keyword">switch</span> (policy &amp; <span class="number">0xFF</span>) &#123;</div><div class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</div><div class="line">        <span class="keyword">return</span> objc_retain(value);</div><div class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</div><div class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(value, SEL_copy);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> releaseValue(<span class="keyword">id</span> value, uintptr_t policy) &#123;</div><div class="line">    <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123;</div><div class="line">        <span class="keyword">return</span> objc_release(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</div><div class="line"><span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</div><div class="line">&#123;</div><div class="line">    old_association = ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</div></pre></td></tr></table></figure><p>我们摘出与对象内存相关的代码仔细分析下，首先把新传入的对象，根据协议进行<code>retain/copy</code>，在赋值的过程中获取旧值，在方法结束前<code>release</code>。</p><hr><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">AssociationsManager manager;</div><div class="line">AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">disguised_ptr_t disguised_object = DISGUISE(object);</div><div class="line"><span class="keyword">if</span> (new_value) &#123;</div><div class="line">    <span class="comment">//需要赋值</span></div><div class="line">    AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">    <span class="keyword">if</span> (i != associations.end()) &#123;</div><div class="line">        <span class="comment">//找到了这个对象的关联表</span></div><div class="line">        ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">        ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">        <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</div><div class="line">            <span class="comment">//找到了这个key的关联对象</span></div><div class="line">            old_association = j-&gt;second;</div><div class="line">            j-&gt;second = ObjcAssociation(policy, new_value);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//没找到，新增一个关联</span></div><div class="line">            (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//没找到，创建一个新的关联表</span></div><div class="line">        ObjectAssociationMap *refs = new ObjectAssociationMap;</div><div class="line">        associations[disguised_object] = refs;</div><div class="line">        (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">        object-&gt;setHasAssociatedObjects();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>先了解一下<code>AssociationsManager</code>与<code>AssociationsHashMap</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> AssociationsManager &#123;</div><div class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;</div><div class="line">public:</div><div class="line">    AssociationsHashMap &amp;associations() &#123;</div><div class="line">        <span class="keyword">if</span> (_map == <span class="literal">NULL</span>)</div><div class="line">            _map = new AssociationsHashMap();</div><div class="line">        <span class="keyword">return</span> *_map;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> ObjectAssociationMap : public std::map&lt;<span class="keyword">void</span> *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt;；</div></pre></td></tr></table></figure></p><p><code>AssociationsManager</code>通过一个以指针地址为主键，值为关联表的哈希表，来管理应用内所有的关联对象。</p><p>首先以对象的指针地址去寻找关联表，再通过指定的键值查找关联关系，从而获取关联对象。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line"><span class="keyword">if</span> (i !=  associations.end()) &#123;</div><div class="line">    ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">    ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">    <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</div><div class="line">        old_association = j-&gt;second;</div><div class="line">        refs-&gt;erase(j);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>和修改方法类似，找到关联关系后，执行哈希表的<code>erase</code>方法删除。</p><hr><h3 id="Getter实现"><a href="#Getter实现" class="headerlink" title="Getter实现"></a>Getter实现</h3><p><code>objc_getAssociatedObject</code>实际调用的是<code>_object_get_associative_reference</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">id _object_get_associative_reference(id object, <span class="keyword">void</span> *key) &#123;</div><div class="line">    id value = nil;</div><div class="line">    <span class="keyword">uintptr_t</span> policy = OBJC_ASSOCIATION_ASSIGN;</div><div class="line">    &#123;</div><div class="line">        AssociationsManager manager;</div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</div><div class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</div><div class="line">            ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</div><div class="line">                ObjcAssociation &amp;entry = j-&gt;second;</div><div class="line">                value = entry.value();</div><div class="line">                policy = entry.policy();</div><div class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</div><div class="line">                    objc_retain(value);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</div><div class="line">        objc_autorelease(value);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>查找哈希表的方法和Setter一样，区别在于如果策略中需要retain和autorelease的话，都需要处理。那么是怎么约定这些策略呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123; </div><div class="line">    OBJC_ASSOCIATION_SETTER_ASSIGN      = <span class="number">0</span>,</div><div class="line">    OBJC_ASSOCIATION_SETTER_RETAIN      = <span class="number">1</span>,</div><div class="line">    OBJC_ASSOCIATION_SETTER_COPY        = <span class="number">3</span>,            <span class="comment">// <span class="doctag">NOTE:</span>  both bits are set, so we can simply test 1 bit in releaseValue below.</span></div><div class="line">    OBJC_ASSOCIATION_GETTER_READ        = (<span class="number">0</span> &lt;&lt; <span class="number">8</span>), </div><div class="line">    OBJC_ASSOCIATION_GETTER_RETAIN      = (<span class="number">1</span> &lt;&lt; <span class="number">8</span>), </div><div class="line">    OBJC_ASSOCIATION_GETTER_AUTORELEASE = (<span class="number">2</span> &lt;&lt; <span class="number">8</span>)</div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">OBJC_ENUM</span><span class="params">(<span class="keyword">uintptr_t</span>, objc_AssociationPolicy)</span> </span>&#123;</div><div class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,</div><div class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</div><div class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>, </div><div class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><code>OBJC_ASSOCIATION_RETAIN = 01401</code>，其中<code>01401</code>开头是<code>0</code>，所以是八进制数字，翻译为二进制就是<code>0000 0011 0000 0001</code>，取位判断就是<code>OBJC_ASSOCIATION_SETTER_RETAIN</code> <code>OBJC_ASSOCIATION_GETTER_RETAIN</code> <code>OBJC_ASSOCIATION_GETTER_AUTORELEASE</code>。</p><p>在保存的时候，需要<code>retain</code>，在获取的时候，需要先<code>retain</code>增加引用计数，再执行<code>autorelease</code>等待释放，从而实现原子性。</p><h3 id="Remove实现"><a href="#Remove实现" class="headerlink" title="Remove实现"></a>Remove实现</h3><p><code>objc_removeAssociatedObjects</code>会判断对象是否存在关联，然后再执行<code>_object_set_associative_reference</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> _object_remove_assocations(id object) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</div><div class="line">    &#123;</div><div class="line">        AssociationsManager manager;</div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());</div><div class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</div><div class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</div><div class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></div><div class="line">            ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</div><div class="line">                elements.push_back(j-&gt;second);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// remove the secondary table.</span></div><div class="line">            <span class="keyword">delete</span> refs;</div><div class="line">            associations.erase(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></div><div class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实现方式也可以看出为什么在介绍里不推荐使用，因为会遍历所有的关联对象，并且全部释放，可能会造成别的模块功能缺陷。</p><h4 id="判断关联对象"><a href="#判断关联对象" class="headerlink" title="判断关联对象"></a>判断关联对象</h4><p>比较有意思的是判断对象是否有关联对象的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> objc_object::hasAssociatedObjects()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span> (isa.nonpointer) <span class="keyword">return</span> isa.has_assoc;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> objc_object::setHasAssociatedObjects()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;</div><div class="line"></div><div class="line"> retry:</div><div class="line">    <span class="keyword">isa_t</span> oldisa = LoadExclusive(&amp;isa.bits);</div><div class="line">    <span class="keyword">isa_t</span> newisa = oldisa;</div><div class="line">    <span class="keyword">if</span> (!newisa.nonpointer  ||  newisa.has_assoc) &#123;</div><div class="line">        ClearExclusive(&amp;isa.bits);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    newisa.has_assoc = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>默认返回的结果都是<code>true</code>，只有在64位系统下，才保存一个标记位。这么处理我推测是为了加快释放周期速度，在析构对象时，会根据这个方法判断是否需要释放关联对象。试想如果每次都查询哈希表，执行效率必定会降低，不如都先通过，之后再做处理。</p><blockquote><p>关于<code>nonpointer</code>不在本文介绍范围内，简单描述为在64位系统下，指针地址保存不仅仅为内存地址，还存有其他标记信息，包括本文涉及的has_assoc。</p><p><code>taggedPointer</code>是一种优化策略，把简单的数字或字符串信息直接保存在指针地址中，从而不申请额外内存加快运行效率。</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>关联对象的实现不复杂，保存的方式为一个全局的哈希表，存取都通过查询表找到关联来执行。哈希表的特点就是牺牲空间换取时间，所以执行速度也可以保证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;关联对象（AssociatedObject）是Objective-C 2.0运行时的一个特性，允许开发者对已经存在的类在扩展中添加自定义的属
      
    
    </summary>
    
      <category term="面试" scheme="https://vanchchen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>初试Shell脚本</title>
    <link href="https://vanchchen.github.io/2018/09/20/%E5%88%9D%E8%AF%95Shell%E8%84%9A%E6%9C%AC/"/>
    <id>https://vanchchen.github.io/2018/09/20/初试Shell脚本/</id>
    <published>2018-09-20T08:45:12.000Z</published>
    <updated>2018-09-20T10:24:35.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>临上线前测试比较努力，遇到闪退或者其他问题，会把日志包打给我，由于app内存限制，目前每次打包都是1m大小，所以有时查找问题的上下文比较吃力。同时由于日志比较多，根据关键词过滤的需求越来越重要。</p><p>于是决定学写脚本完成这个任务，根据我的要求，工作流程应该是传入压缩包，根据后缀名解压，根据日期排序后合并成一个文件，按需过滤关键词。</p><hr><h2 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/usr/bin/env bash</div><div class="line"><span class="meta">#</span> Created By Vanch at 2018/9/20</div><div class="line"></div><div class="line">printHelp() &#123;</div><div class="line">    echo "Uncompess log files from inputed zip"</div><div class="line">    echo "Then Merge these logs to one file"</div><div class="line">    echo "Supported file types: zip tar tar.gz tar.bz2"</div><div class="line">    echo</div><div class="line">    echo "Use -s for filtering socket result to socket.log"</div><div class="line">    echo </div><div class="line">    echo "Have fun!"</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#</span>如果没输入参数，就打印帮助信息</div><div class="line">if [ $# -eq 0 ]; then</div><div class="line">    printHelp</div><div class="line">    exit 0</div><div class="line">fi</div><div class="line"></div><div class="line"><span class="meta">#</span>把长选项转到短选项</div><div class="line">for arg in "$@"; do</div><div class="line">  shift</div><div class="line">  case "$arg" in</div><div class="line">    "--help")       set -- "$@" "-h" ;;</div><div class="line">    "--version")    set -- "$@" "-v" ;;</div><div class="line">    "--list")       set -- "$@" "-l" ;;</div><div class="line">    *)              set -- "$@" "$arg"</div><div class="line">  esac</div><div class="line">done</div><div class="line"><span class="meta">#</span>获取短选项</div><div class="line">OPTIND=1</div><div class="line">printS=false;</div><div class="line">while getopts "dmksahvl" opt; do</div><div class="line">    case $opt in</div><div class="line">        h) #输入为help，就打印帮助信息</div><div class="line">            printHelp</div><div class="line">            exit 0;;</div><div class="line">        l) #支持单独获取支持文件后缀列表</div><div class="line">            echo "Supported file types: zip tar tar.gz tar.bz2"</div><div class="line">            exit 0;;</div><div class="line">        v) #支持查找版本号</div><div class="line">            echo "1.0.0"</div><div class="line">            exit 0;;</div><div class="line">        s) #过滤Socket</div><div class="line">            printS=true;;</div><div class="line">    esac</div><div class="line">done</div><div class="line"></div><div class="line"><span class="meta">#</span>获得压缩包地址</div><div class="line">file=$&#123;!#&#125;</div><div class="line"><span class="meta">#</span>如果不存在就退出</div><div class="line">if [ ! -f "$file" ]; then</div><div class="line">    echo "File not exist!"</div><div class="line">    exit 0;</div><div class="line">fi </div><div class="line"><span class="meta">#</span>获取压缩后缀</div><div class="line">fileName=`basename $file`</div><div class="line">suffix=$&#123;fileName#*.&#125;</div><div class="line"><span class="meta">#</span>判断文件类型</div><div class="line">support=('tar','tar.gz','tar.bz2','zip')</div><div class="line">if [ -z `echo "$&#123;support[@]&#125;" | grep -w "$suffix"` ] ; then</div><div class="line">    echo "File type not support!"</div><div class="line">    exit 0;    </div><div class="line">fi</div><div class="line"><span class="meta">#</span>拼接文件夹地址</div><div class="line">fileDir=$(dirname $file)/$&#123;fileName%%.*&#125;</div><div class="line">if [ -d $fileDir ]; then</div><div class="line">    rm -rf $fileDir</div><div class="line">fi</div><div class="line">mkdir $fileDir</div><div class="line">cd $fileDir</div><div class="line"><span class="meta">#</span>解压文件</div><div class="line">case $suffix in</div><div class="line">    'tar')</div><div class="line">        eval "tar xvf $file &gt; /dev/null 2&gt;&amp;1";;</div><div class="line">    'tar.gz')</div><div class="line">        eval "tar zxvf $file &gt; /dev/null 2&gt;&amp;1";;</div><div class="line">    'tar.bz2')</div><div class="line">        eval "tar jxvf $file &gt; /dev/null 2&gt;&amp;1";;</div><div class="line">    'zip')</div><div class="line">        eval "unzip -o $file &gt; /dev/null 2&gt;&amp;1";;</div><div class="line">esac</div><div class="line">echo 'Uncompass Success!'</div><div class="line"></div><div class="line"><span class="meta">#</span>获取日志列表，按排序合并到一个日志</div><div class="line">mergeFile=./merge.log</div><div class="line">logCount=0</div><div class="line"><span class="meta">#</span>搜索com开头的日志，按日期排序，用？临时代替空格</div><div class="line">for logName in `ls | grep 'com' | sort -n | tr " " "?"`; do</div><div class="line">    logName=$&#123;logName//'?'/' '&#125;</div><div class="line">    cat ./"$logName" &gt;&gt; $mergeFile</div><div class="line">    ((logCount++))</div><div class="line">done</div><div class="line"><span class="meta">#</span>不存在日志就打断</div><div class="line">if [ $logCount -eq 0 ]; then</div><div class="line">    echo "Log not exist!"</div><div class="line">    exit </div><div class="line">fi</div><div class="line">echo 'Merge Success!'</div><div class="line"><span class="meta">#</span>打印socket</div><div class="line">if [ $printS = true ]; then</div><div class="line">    cat $mergeFile | grep -i 'socket' &gt;&gt; ./socket.log</div><div class="line">    echo 'Filter socket'</div><div class="line">fi</div></pre></td></tr></table></figure><hr><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>查询了很多资料后写完了这个脚本，基本满足了我的需求，下面总结一下怎么解决遇到的问题。</p><h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><p>一开始学脚本时，书上都说<code>#! /bin/bash</code>，但是看项目中大神写的脚本，都是<code>#!/usr/bin/env bash</code>，有什么区别呢？</p><blockquote><p>脚本用env启动的原因，是因为脚本解释器在linux中可能被安装于不同的目录，env可以在系统的PATH目录中查找。<br>同时，env还规定一些系统环境变量。</p></blockquote><p>不同的系统，解释器的路径可能也不同，所以使用绝对路径是比较危险的方式。通过从环境中查找，可以保证兼容性。</p><hr><h3 id="获取选项"><a href="#获取选项" class="headerlink" title="获取选项"></a>获取选项</h3><p>开发中我们经常用到命令，这些命令一般都配合选项达到不同的效果，比如最常用的<code>ls -al</code>，通过<code>-a</code>来指定结果包含隐藏文件，通过<code>-l</code>达到列表显示的效果。</p><p>通过查询相关资料，我发现获取选项普遍的做法是使用<code>getopts</code>命令，但是这个方法只能获取<code>-h</code>这种短选项，对于<code>--help</code>长选项就不行。</p><p>第一种办法是换成<code>getopt</code>命令，但是并不是每个系统都支持这个命令。具体使用和<code>getopts</code>类似，比如<code>getopt -o ab:c -l a-long:b-long</code></p><p>第二种方法是把支持的长命令转成短命令，我使用的就是这种方式，相对来说比较容易理解，且case写的比较统一。通过<code>shift</code>取出参数，再<code>set --</code>的方式重写，最后<code>OPTIND=1</code>把指针指回第一个选项。</p><hr><h3 id="文件路径和文件后缀"><a href="#文件路径和文件后缀" class="headerlink" title="文件路径和文件后缀"></a>文件路径和文件后缀</h3><p>按需求需要判断后缀名来解压，那么就需要判断<code>tar.gz</code>之类的问题。同时，如果传入的文件目录是隐藏目录，也会造成一定的障碍。我们假设传入文件路径为<code>/a/.b/c.tar.gz</code>。</p><blockquote><p>${param#pattern}    从param前面删除pattern的最小匹配<br>${param##pattern}    从param前面删除pattern的最大匹配<br>${param%pattern}    从param后面删除pattern的最小匹配<br>${param%%pattern}    从param后面删除pattern的最大匹配</p></blockquote><p>如果按照<code>${fileName##*.}</code>来截取，那么只能拿到<code>gz</code>。<br>如果按照<code>${fileName#*.}</code>来截取，拿到的又是<code>b/c.tar.gz</code>。那怎么办呢？</p><p>好在有<code>dirname</code>可以直接获取文件路径，<code>basename</code>拿到文件名，单独对文件名进行<code>${fileName#*.}</code>就可以拿到<code>tar.gz</code>了。</p><hr><h3 id="去除不必要的打印"><a href="#去除不必要的打印" class="headerlink" title="去除不必要的打印"></a>去除不必要的打印</h3><p>执行解压命令时，会打印解压步骤，一般来说也需要显示，那如果我们不想要打印出来呢？有一个办法就是在命令之后加上<code>&gt; /dev/null 2&gt;&amp;1</code></p><blockquote><p>/dev/null ：代表空设备文件</p><p>>  ：代表重定向到哪里，例如：echo “123” &gt; /home/123.txt</p><p>1  ：表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null”</p><p>2  ：表示stderr标准错误</p><p>&amp;  ：表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1</p></blockquote><p>所以含义就是把命令输出结果和错误输出重定向，使得输出不在当前屏幕显示，由于null比较特殊，向这个文件输入等于进入黑洞，因此达到效果。</p><hr><h3 id="数组与空格"><a href="#数组与空格" class="headerlink" title="数组与空格"></a>数组与空格</h3><p>使用<code>ls | grep</code>的方式来过滤结果获取文件名数组的最大问题是，如果文件名包含空格，那么前后会被分割成两个单元，导致处理比较困难。</p><p>比较讨巧的方法是临时用特殊符号代替空格，在使用时再替换回来。这种方法不会改变文件名，也不用写复杂的数组合并，比较符合简单的设计。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tr " " "?"</div><div class="line"><span class="meta">$</span>&#123;logName//'?'/' '&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次简单的脚本实验，对shell有了新的认识，及时记录遇到的问题，相信下次会更有印象。使用脚本，可以让工作更有效率，相信以后也会越用越多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;临上线前测试比较努力，遇到闪退或者其他问题，会把日志包打给我，由于app内存限制，目前每次打包都是1m大小，所以有时查找问题的上下文比较
      
    
    </summary>
    
      <category term="杂学" scheme="https://vanchchen.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="shell" scheme="https://vanchchen.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Category探索</title>
    <link href="https://vanchchen.github.io/2018/09/17/Category%E6%8E%A2%E7%B4%A2/"/>
    <id>https://vanchchen.github.io/2018/09/17/Category探索/</id>
    <published>2018-09-17T07:29:29.000Z</published>
    <updated>2018-09-17T07:43:14.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Category"><a href="#什么是Category" class="headerlink" title="什么是Category?"></a>什么是Category?</h2><p>Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已经存在的类添加方法，一般称为分类，文件名格式是”NSObject+A.h”。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> category_t &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    classref_t cls;</div><div class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</div><div class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</div><div class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</div><div class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</div><div class="line">    <span class="keyword">struct</span> property_list_t *_classProperties;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从结构能看出分类可以扩展实例方法列表、类方法列表、协议列表，也支持扩展属性，但不支持扩展成员变量（之后会说）。</p><p>一般使用的场景有扩展现有类方法、代码分区、添加私有方法（不对外暴露category.h）、模拟多继承（使用关联对象的方式添加属性实现）</p><hr><h2 id="什么是Extension？"><a href="#什么是Extension？" class="headerlink" title="什么是Extension？"></a>什么是Extension？</h2><p>Extension一般被称为类扩展、匿名分类，用于定义私有属性和方法，不可被继承。只能依附自定义类写于.m中，定义一般为:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line">@property (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *obj;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>类扩展支持写在多个.h文件，但都必须在.m文件中引用，且不能有自己的实现。</p><hr><h2 id="Category与Extension有什么区别？"><a href="#Category与Extension有什么区别？" class="headerlink" title="Category与Extension有什么区别？"></a>Category与Extension有什么区别？</h2><p>1.分类多用于扩展方法实现，类扩展多用于申明私有变量和方法。</p><p>2.类扩展作用在编译期，直接和原类在一起，而分类作用在运行时，加载类的时候动态添加到原类中。</p><p>3.类扩展可以定义属性，分类中定义的属性只会申明setter/getter，并没有相关实现和变量。</p><hr><h2 id="Category如何加载的？"><a href="#Category如何加载的？" class="headerlink" title="Category如何加载的？"></a>Category如何加载的？</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</div><div class="line">    Class superclass;</div><div class="line">    class_data_bits_t bits; </div><div class="line">    class_rw_t *data() &#123;</div><div class="line">        <span class="keyword">return</span> bits.data();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> class_rw_t &#123;</div><div class="line">    <span class="keyword">const</span> class_ro_t *ro;</div><div class="line"></div><div class="line">    method_array_t methods;</div><div class="line">    property_array_t properties;</div><div class="line">    protocol_array_t protocols;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> class_ro_t &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</div><div class="line">    method_list_t * baseMethodList;</div><div class="line">    protocol_list_t * baseProtocols;</div><div class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</div><div class="line">    property_list_t *baseProperties;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>先简单了解一下Class对象的结构，每个<code>objc_class</code>都包含有<code>class_data_bits_t</code>数据位，其中储存了<code>class_rw_t</code>的指针地址和一些其他标记。<code>class_rw_t</code>中包含有属性方法协议列表，以及<code>class_ro_t</code>指针地址。而在<code>class_ro_t</code>结构中，储存的是编译器决定的属性方法协议。</p><h3 id="那么是怎么运行的呢？"><a href="#那么是怎么运行的呢？" class="headerlink" title="那么是怎么运行的呢？"></a>那么是怎么运行的呢？</h3><p>在编译期类的结构中的<code>class_data_bits_t</code>指向的是一个 <code>class_ro_t</code>指针。</p><p>在运行时调用<code>realizeClass</code>方法，初始化一个<code>class_rw_t</code>结构体，设置ro值为原数据中的<code>class_ro_t</code>后设为数据位中的指向，最后调用<code>methodizeClass</code>方法加载。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> methodizeClass(Class cls)</div><div class="line">&#123;</div><div class="line">    auto rw = cls-&gt;data();</div><div class="line">    auto ro = rw-&gt;ro;</div><div class="line"></div><div class="line">    <span class="comment">// Install methods and properties that the class implements itself.</span></div><div class="line">    method_list_t *list = ro-&gt;baseMethods();</div><div class="line">    <span class="keyword">if</span> (list) &#123;</div><div class="line">        prepareMethodLists(cls, &amp;list, <span class="number">1</span>, <span class="literal">YES</span>, isBundleClass(cls));</div><div class="line">        rw-&gt;methods.attachLists(&amp;list, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    property_list_t *proplist = ro-&gt;baseProperties;</div><div class="line">    <span class="keyword">if</span> (proplist) &#123;</div><div class="line">        rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protocol_list_t *protolist = ro-&gt;baseProtocols;</div><div class="line">    <span class="keyword">if</span> (protolist) &#123;</div><div class="line">        rw-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Root classes get bonus method implementations if they don't have </span></div><div class="line">    <span class="comment">// them already. These apply before category replacements.</span></div><div class="line">    <span class="keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;</div><div class="line">        <span class="comment">// root metaclass</span></div><div class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, <span class="string">""</span>, <span class="literal">NO</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Attach categories.</span></div><div class="line">    category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</div><div class="line">    attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don't flush caches*/</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (cats) free(cats);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，在<code>methodizeClass</code>中加载了原先类在编译期决定的方法属性和协议，然后获取了未连接的分类表，将列表中的扩展方法添加到运行期类中。</p><hr><h2 id="Category方法覆盖"><a href="#Category方法覆盖" class="headerlink" title="Category方法覆盖"></a>Category方法覆盖</h2><p>如果不同的分类实现了相同名字的方法，那么调用时会使用最后加入的实现，这是为什么呢？</p><h3 id="加载Category"><a href="#加载Category" class="headerlink" title="加载Category"></a>加载Category</h3><p>dyld链接并初始化二进制文件后，交由<code>ImageLoader</code>读取，接着通知<code>runtime</code>处理，<code>runtime</code>调用<code>map_images</code>解析，然后执行<code>_read_images</code>分析文件中包含的类和分类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Discover categories. </span></div><div class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</div><div class="line">    category_t **catlist = </div><div class="line">        _getObjc2CategoryList(hi, &amp;count);</div><div class="line">    <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        category_t *cat = catlist[i];</div><div class="line">        Class cls = remapClass(cat-&gt;cls);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!cls) &#123;</div><div class="line">            <span class="comment">// Category's target class is missing (probably weak-linked).</span></div><div class="line">            <span class="comment">// Disavow any knowledge of this category.</span></div><div class="line">            catlist[i] = <span class="literal">nil</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Process this category. </span></div><div class="line">        <span class="comment">// First, register the category with its target class. </span></div><div class="line">        <span class="comment">// Then, rebuild the class's method lists (etc) if </span></div><div class="line">        <span class="comment">// the class is realized. </span></div><div class="line">        <span class="keyword">bool</span> classExists = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </div><div class="line">            ||  cat-&gt;instanceProperties) </div><div class="line">        &#123;</div><div class="line">            addUnattachedCategoryForClass(cat, cls, hi);</div><div class="line">            <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</div><div class="line">                remethodizeClass(cls);</div><div class="line">                classExists = <span class="literal">YES</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </div><div class="line">            ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </div><div class="line">        &#123;</div><div class="line">            addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</div><div class="line">            <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</div><div class="line">                remethodizeClass(cls-&gt;ISA());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="添加方法属性和协议"><a href="#添加方法属性和协议" class="headerlink" title="添加方法属性和协议"></a>添加方法属性和协议</h3><p>如果有新增的分类，就分别添加到原类和meta类，并通过<code>remethodizeClass</code>更新，具体就是调用<code>attachCategories</code>方法把分类中所有的方法都添加到指定类中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> </div><div class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</div><div class="line"></div><div class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></div><div class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</div><div class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</div><div class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</div><div class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</div><div class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</div><div class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</div><div class="line"></div><div class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></div><div class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = cats-&gt;count;</div><div class="line">    <span class="keyword">bool</span> fromBundle = NO;</div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</div><div class="line"></div><div class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class="line">        <span class="keyword">if</span> (mlist) &#123;</div><div class="line">            mlists[mcount++] = mlist;</div><div class="line">            fromBundle |= entry.hi-&gt;isBundle();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">property_list_t</span> *proplist = </div><div class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</div><div class="line">        <span class="keyword">if</span> (proplist) &#123;</div><div class="line">            proplists[propcount++] = proplist;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</div><div class="line">        <span class="keyword">if</span> (protolist) &#123;</div><div class="line">            protolists[protocount++] = protolist;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</div><div class="line"></div><div class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class="line">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class="line">    <span class="built_in">free</span>(mlists);</div><div class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</div><div class="line"></div><div class="line">    rw-&gt;properties.attachLists(proplists, propcount);</div><div class="line">    <span class="built_in">free</span>(proplists);</div><div class="line"></div><div class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</div><div class="line">    <span class="built_in">free</span>(protolists);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (hasArray()) &#123;</div><div class="line">            <span class="comment">// many lists -&gt; many lists</span></div><div class="line">            <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</div><div class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</div><div class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</div><div class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</div><div class="line">            memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </div><div class="line">                    oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</div><div class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </div><div class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// 0 lists -&gt; 1 list</span></div><div class="line">            <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 1 list -&gt; many lists</span></div><div class="line">            List* oldList = <span class="built_in">list</span>;</div><div class="line">            <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</div><div class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</div><div class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</div><div class="line">            <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</div><div class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </div><div class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>可以看到最后调用了<code>rw-&gt;methods.attachLists(mlists, mcount);</code> 把新增分类中的方法列表添加到实际运行时查询的方法列表头部。</p><p>在进行方法调用时会从头部查询，一旦查到后就返回结果，因此后编译的文件中的方法会被优先调用。</p><p>同时之前添加的方法实现也保存了，可以通过获取同名方法的方式查找原类的实现。</p><hr><h2 id="Category实现属性"><a href="#Category实现属性" class="headerlink" title="Category实现属性"></a>Category实现属性</h2><h3 id="分类不能添加成员变量"><a href="#分类不能添加成员变量" class="headerlink" title="分类不能添加成员变量"></a>分类不能添加成员变量</h3><p>属性（Property）包含了成员变量（Ivar）和Setter&amp;Getter。</p><p>可以在分类中定义属性，但由于分类是在运行时添加分类属性到类的属性列表中，所以并没有创建对应的成员变量和方法实现。</p><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>如果我们想让分类实现添加新的属性，一般都通过关联对象的方式。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明文件</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestObject</span> (<span class="title">Category</span>)</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *object;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 实现文件</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">const</span> kAssociatedObjectKey = (<span class="keyword">void</span> *)&amp;kAssociatedObjectKey;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestObject</span> (<span class="title">Category</span>)</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSObject</span> *)object &#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, kAssociatedObjectKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="built_in">NSObject</span> *)object &#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, kAssociatedObjectKey, object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p><p>这种方式可以实现存取对象，但是不能获取<code>_object</code>变量。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category</a></p><p><a href="https://halfrost.com/objc_runtime_isa_class/" target="_blank" rel="external">神经病院 Objective-C Runtime 入院第一天—— isa 和 Class</a></p><p><a href="https://www.jianshu.com/p/0dc2513e117b" target="_blank" rel="external">探秘Runtime - 深入剖析Category</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Category&quot;&gt;&lt;a href=&quot;#什么是Category&quot; class=&quot;headerlink&quot; title=&quot;什么是Category?&quot;&gt;&lt;/a&gt;什么是Category?&lt;/h2&gt;&lt;p&gt;Category是Objective-C 2.0之后添加的语
      
    
    </summary>
    
      <category term="面试" scheme="https://vanchchen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS面试题</title>
    <link href="https://vanchchen.github.io/2018/09/14/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://vanchchen.github.io/2018/09/14/iOS面试题/</id>
    <published>2018-09-14T09:40:01.000Z</published>
    <updated>2018-09-14T09:42:46.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS基础题"><a href="#iOS基础题" class="headerlink" title="iOS基础题"></a>iOS基础题</h2><ol><li>分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？</li><li>讲一下atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？</li><li>被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？</li><li>关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将其指针置空么？</li><li>KVO的底层实现？如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？</li><li><code>Autoreleasepool</code>所使用的数据结构是什么？<code>AutoreleasePoolPage</code>结构体了解么？</li><li>讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的？为什么对象方法没有保存的对象结构体里，而是保存在类对象的结构体里？</li><li><code>class_ro_t</code> 和  <code>class_rw_t</code> 的区别？</li><li>iOS 中内省的几个方法？<code>class</code>方法和<code>objc_getClass</code>方法有什么区别?</li><li>在运行时创建类的方法<code>objc_allocateClassPair</code>的方法名尾部为什么是pair（成对的意思）？</li><li>一个int变量被<code>__block</code>修饰与否的区别？<br>\12. 为什么在block外部使用<code>__weak</code>修饰的同时需要在内部使用<code>__strong</code>修饰？</li><li>RunLoop的作用是什么？它的内部工作机制了解么？（最好结合线程和内存管理来说）</li><li>哪些场景可以触发离屏渲染？（知道多少说多少）</li></ol><hr><h2 id="iOS-实战题"><a href="#iOS-实战题" class="headerlink" title="iOS 实战题"></a>iOS 实战题</h2><ol><li>AppDelegate如何瘦身？</li><li>反射是什么？可以举出几个应用场景么？（知道多少说多少）</li><li>有哪些场景是NSOperation比GCD更容易实现的？（或是NSOperation优于GCD的几点，知道多少说多少）</li><li>App 启动优化策略？最好结合启动流程来说（main()函数的执行前后都分别说一下，知道多少说多少）</li><li>App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？（知道多少说多少）</li><li>你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？（知道多少说多少）</li><li>你知道有哪些情况会导致app卡顿，分别可以用什么方法来避免？（知道多少说多少）</li></ol><hr><h2 id="网络题"><a href="#网络题" class="headerlink" title="网络题"></a>网络题</h2><ol><li>App 网络层有哪些优化策略？</li><li>TCP为什么要三次握手，四次挥手？</li><li>对称加密和非对称加密的区别？分别有哪些算法的实现？</li><li>HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么？</li><li>HTTPS是如何实现验证身份和验证完整性的？</li><li>如何用Charles抓HTTPS的包？其中原理和流程是什么？</li><li>什么是中间人攻击？如何避免？</li></ol><hr><h2 id="计算机系统题"><a href="#计算机系统题" class="headerlink" title="计算机系统题"></a>计算机系统题</h2><ol><li>了解编译的过程么？分为哪几个步骤？</li><li>静态链接了解么？静态库和动态库的区别？</li><li>内存的几大区域，各自的职能分别是什么？</li><li>static和const有什么区别？</li><li>了解内联函数么？</li><li>什么时候会出现死锁？如何避免？</li><li>说一说你对线程安全的理解？</li><li>列举你知道的线程同步策略？</li><li>有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说</li></ol><hr><h2 id="设计模式题"><a href="#设计模式题" class="headerlink" title="设计模式题"></a>设计模式题</h2><ol><li>除了单例，观察者设计模式以外，还知道哪些设计模式？分别介绍一下</li><li>最喜欢哪个设计模式？为什么？</li><li>iOS SDK 里面有哪些设计模式的实践？</li><li>**设计模式是为了解决什么问题的？</li><li>**设计模式的成员构成以及工作机制是什么？</li><li>**设计模式的优缺点是什么？</li></ol><hr><h2 id="架构-amp-设计题"><a href="#架构-amp-设计题" class="headerlink" title="架构 &amp; 设计题"></a>架构 &amp; 设计题</h2><ol><li>MVC和MVVM的区别？MVVM和MVP的区别？</li><li>面向对象的几个设计原则了解么？最好可以结合场景来说。</li><li>可以说几个重构的技巧么？你觉得重构适合什么时候来做？</li><li>你觉得框架和设计模式的区别是什么？</li><li>看过哪些第三方框架的源码，它们是怎么设计的？设计好的地方在哪里，不好的地方在哪里，如何改进？（这道题的后三个问题的难度已经很高了，如果不是太N的公司不建议深究）</li></ol><hr><h2 id="数据结构-amp-算法题"><a href="#数据结构-amp-算法题" class="headerlink" title="数据结构&amp;算法题"></a>数据结构&amp;算法题</h2><ol><li>链表和数组的区别是什么？插入和查询的时间复杂度分别是多少？</li><li>哈希表是如何实现的？如何解决地址冲突？</li><li>排序题：冒泡排序，选择排序，插入排序，快速排序（二路，三路）能写出那些？</li><li>链表题：如何检测链表中是否有环？如何删除链表中等于某个值的所有节点？</li><li>数组题：如何在有序数组中找出和等于给定值的两个元素？如何合并两个有序的数组之后保持有序？</li><li>二叉树题：如何反转二叉树？如何验证两个二叉树是完全相等的？</li></ol><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://mp.weixin.qq.com/s/-cefmEo7RcZ5wifXX8JB5g" target="_blank" rel="external">出一套 iOS 高级面试题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;iOS基础题&quot;&gt;&lt;a href=&quot;#iOS基础题&quot; class=&quot;headerlink&quot; title=&quot;iOS基础题&quot;&gt;&lt;/a&gt;iOS基础题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？&lt;/li
      
    
    </summary>
    
      <category term="面试" scheme="https://vanchchen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
</feed>
