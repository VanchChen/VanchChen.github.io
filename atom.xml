<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vanch&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vanchchen.github.io/"/>
  <updated>2018-09-17T07:30:27.569Z</updated>
  <id>https://vanchchen.github.io/</id>
  
  <author>
    <name>Vanch</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Category探索</title>
    <link href="https://vanchchen.github.io/2018/09/17/Category%E6%8E%A2%E7%B4%A2/"/>
    <id>https://vanchchen.github.io/2018/09/17/Category探索/</id>
    <published>2018-09-17T07:29:29.000Z</published>
    <updated>2018-09-17T07:30:27.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Category"><a href="#什么是Category" class="headerlink" title="什么是Category?"></a>什么是Category?</h2><p>Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已经存在的类添加方法，一般称为分类，文件名格式是”NSObject+A.h”。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义在runtime.h中</span></div><div class="line"><span class="keyword">struct</span> objc_category &#123;</div><div class="line">    <span class="keyword">char</span> * category_name;</div><div class="line">    <span class="keyword">char</span> * class_name;</div><div class="line">    <span class="keyword">struct</span> objc_method_list * instance_methods;</div><div class="line">    <span class="keyword">struct</span> objc_method_list * class_methods ;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list * protocols;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从结构能看出分类可以扩展实例方法列表、类方法列表、协议列表，但是不支持扩展属性。</p><p>一般使用的场景有扩展现有类方法、代码分区、添加私有方法（不对外暴露category.h）、模拟多继承（使用关联对象的方式添加属性实现）</p><hr><h2 id="什么是Extension？"><a href="#什么是Extension？" class="headerlink" title="什么是Extension？"></a>什么是Extension？</h2><p>Extension一般被称为类扩展、匿名分类，用于定义私有属性和方法，不可被继承。只能依附自定义类写于.m中，定义一般为:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><hr><h2 id="Category与Extension有什么区别？"><a href="#Category与Extension有什么区别？" class="headerlink" title="Category与Extension有什么区别？"></a>Category与Extension有什么区别？</h2><p>1.分类多用于扩展方法实现，类扩展多用于定义私有变量和方法。</p><p>2.类扩展作用在编译期，直接和原类在一起，而分类作用在运行时，加载类的时候动态添加到原类中。</p><p>3.类扩展可以定义属性，分类中定义的属性只会申明setter/getter，并没有相关实现和变量。</p><hr><h2 id="Category如何加载的？"><a href="#Category如何加载的？" class="headerlink" title="Category如何加载的？"></a>Category如何加载的？</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</div><div class="line">    Class superclass;</div><div class="line">    class_data_bits_t bits; </div><div class="line">    class_rw_t *data() &#123;</div><div class="line">        <span class="keyword">return</span> bits.data();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> class_rw_t &#123;</div><div class="line">    <span class="keyword">const</span> class_ro_t *ro;</div><div class="line"></div><div class="line">    method_array_t methods;</div><div class="line">    property_array_t properties;</div><div class="line">    protocol_array_t protocols;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> class_ro_t &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</div><div class="line">    method_list_t * baseMethodList;</div><div class="line">    protocol_list_t * baseProtocols;</div><div class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</div><div class="line">    property_list_t *baseProperties;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>先简单了解一下Class对象的结构，每个<code>objc_class</code>都包含有<code>class_data_bits_t</code>数据位，其中储存了<code>class_rw_t</code>的指针地址和一些其他标记。<code>class_rw_t</code>中包含有属性方法协议列表，以及<code>class_ro_t</code>指针地址。而在<code>class_ro_t</code>结构中，储存的是编译器决定的属性方法协议。</p><h3 id="那么是怎么运行的呢？"><a href="#那么是怎么运行的呢？" class="headerlink" title="那么是怎么运行的呢？"></a>那么是怎么运行的呢？</h3><p>在编译期类的结构中的<code>class_data_bits_t</code>指向的是一个 <code>class_ro_t</code>指针。</p><p>在运行时调用<code>realizeClass</code>方法，初始化一个<code>class_rw_t</code>结构体，设置ro值为原数据中的<code>class_ro_t</code>后设为数据位中的指向，最后调用<code>methodizeClass</code>方法加载。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> methodizeClass(Class cls)</div><div class="line">&#123;</div><div class="line">    auto rw = cls-&gt;data();</div><div class="line">    auto ro = rw-&gt;ro;</div><div class="line"></div><div class="line">    <span class="comment">// Install methods and properties that the class implements itself.</span></div><div class="line">    method_list_t *list = ro-&gt;baseMethods();</div><div class="line">    <span class="keyword">if</span> (list) &#123;</div><div class="line">        prepareMethodLists(cls, &amp;list, <span class="number">1</span>, <span class="literal">YES</span>, isBundleClass(cls));</div><div class="line">        rw-&gt;methods.attachLists(&amp;list, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    property_list_t *proplist = ro-&gt;baseProperties;</div><div class="line">    <span class="keyword">if</span> (proplist) &#123;</div><div class="line">        rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protocol_list_t *protolist = ro-&gt;baseProtocols;</div><div class="line">    <span class="keyword">if</span> (protolist) &#123;</div><div class="line">        rw-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Root classes get bonus method implementations if they don't have </span></div><div class="line">    <span class="comment">// them already. These apply before category replacements.</span></div><div class="line">    <span class="keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;</div><div class="line">        <span class="comment">// root metaclass</span></div><div class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, <span class="string">""</span>, <span class="literal">NO</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Attach categories.</span></div><div class="line">    category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</div><div class="line">    attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don't flush caches*/</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (cats) free(cats);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，在<code>methodizeClass</code>中加载了原先类在编译期决定的方法属性和协议，然后获取了未连接的分类表，将列表中的扩展方法添加到运行期类中。</p><hr><h2 id="Category方法覆盖"><a href="#Category方法覆盖" class="headerlink" title="Category方法覆盖"></a>Category方法覆盖</h2><p>如果不同的分类实现了相同名字的方法，那么调用时会使用最后加入的实现，这是为什么呢？</p><h3 id="加载Category"><a href="#加载Category" class="headerlink" title="加载Category"></a>加载Category</h3><p>dyld链接并初始化二进制文件后，交由<code>ImageLoader</code>读取，接着通知<code>runtime</code>处理，<code>runtime</code>调用<code>map_images</code>解析，然后执行<code>_read_images</code>分析文件中包含的类和分类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Discover categories. </span></div><div class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</div><div class="line">    category_t **catlist = </div><div class="line">        _getObjc2CategoryList(hi, &amp;count);</div><div class="line">    <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        category_t *cat = catlist[i];</div><div class="line">        Class cls = remapClass(cat-&gt;cls);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!cls) &#123;</div><div class="line">            <span class="comment">// Category's target class is missing (probably weak-linked).</span></div><div class="line">            <span class="comment">// Disavow any knowledge of this category.</span></div><div class="line">            catlist[i] = <span class="literal">nil</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Process this category. </span></div><div class="line">        <span class="comment">// First, register the category with its target class. </span></div><div class="line">        <span class="comment">// Then, rebuild the class's method lists (etc) if </span></div><div class="line">        <span class="comment">// the class is realized. </span></div><div class="line">        <span class="keyword">bool</span> classExists = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </div><div class="line">            ||  cat-&gt;instanceProperties) </div><div class="line">        &#123;</div><div class="line">            addUnattachedCategoryForClass(cat, cls, hi);</div><div class="line">            <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</div><div class="line">                remethodizeClass(cls);</div><div class="line">                classExists = <span class="literal">YES</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </div><div class="line">            ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </div><div class="line">        &#123;</div><div class="line">            addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</div><div class="line">            <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</div><div class="line">                remethodizeClass(cls-&gt;ISA());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="添加方法属性和协议"><a href="#添加方法属性和协议" class="headerlink" title="添加方法属性和协议"></a>添加方法属性和协议</h3><p>如果有新增的分类，就分别添加到原类和meta类，并通过<code>remethodizeClass</code>更新，具体就是调用<code>attachCategories</code>方法把分类中所有的方法都添加到指定类中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> </div><div class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</div><div class="line"></div><div class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></div><div class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</div><div class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</div><div class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</div><div class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</div><div class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</div><div class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</div><div class="line"></div><div class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></div><div class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = cats-&gt;count;</div><div class="line">    <span class="keyword">bool</span> fromBundle = NO;</div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</div><div class="line"></div><div class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class="line">        <span class="keyword">if</span> (mlist) &#123;</div><div class="line">            mlists[mcount++] = mlist;</div><div class="line">            fromBundle |= entry.hi-&gt;isBundle();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">property_list_t</span> *proplist = </div><div class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</div><div class="line">        <span class="keyword">if</span> (proplist) &#123;</div><div class="line">            proplists[propcount++] = proplist;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</div><div class="line">        <span class="keyword">if</span> (protolist) &#123;</div><div class="line">            protolists[protocount++] = protolist;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</div><div class="line"></div><div class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class="line">    rw-&gt;methods.attachLists(mlists, mcount);</div><div class="line">    <span class="built_in">free</span>(mlists);</div><div class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</div><div class="line"></div><div class="line">    rw-&gt;properties.attachLists(proplists, propcount);</div><div class="line">    <span class="built_in">free</span>(proplists);</div><div class="line"></div><div class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</div><div class="line">    <span class="built_in">free</span>(protolists);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (hasArray()) &#123;</div><div class="line">            <span class="comment">// many lists -&gt; many lists</span></div><div class="line">            <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</div><div class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</div><div class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</div><div class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</div><div class="line">            memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </div><div class="line">                    oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</div><div class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </div><div class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// 0 lists -&gt; 1 list</span></div><div class="line">            <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 1 list -&gt; many lists</span></div><div class="line">            List* oldList = <span class="built_in">list</span>;</div><div class="line">            <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</div><div class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</div><div class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</div><div class="line">            <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</div><div class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </div><div class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>可以看到最后调用了<code>rw-&gt;methods.attachLists(mlists, mcount);</code> 把新增分类中的方法列表添加到实际运行时查询的方法列表头部。</p><p>在进行方法调用时会从头部查询，一旦查到后就返回结果，因此后编译的文件中的方法会被优先调用。</p><p>同时之前添加的方法实现也保存了，可以通过获取同名方法的方式查找原类的实现。</p><hr><h2 id="Category实现属性"><a href="#Category实现属性" class="headerlink" title="Category实现属性"></a>Category实现属性</h2><h3 id="分类不能添加成员变量"><a href="#分类不能添加成员变量" class="headerlink" title="分类不能添加成员变量"></a>分类不能添加成员变量</h3><p>属性（Property）包含了成员变量（Ivar）和Setter&amp;Getter。</p><p>可以在分类中定义属性，但由于分类是在运行时添加分类属性到类的属性列表中，所以并没有创建对应的成员变量和方法实现。</p><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>如果我们想让分类实现添加新的属性，一般都通过关联对象的方式。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明文件</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestObject</span> (<span class="title">Category</span>)</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *object;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 实现文件</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">const</span> kAssociatedObjectKey = (<span class="keyword">void</span> *)&amp;kAssociatedObjectKey;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestObject</span> (<span class="title">Category</span>)</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSObject</span> *)object &#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, kAssociatedObjectKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="built_in">NSObject</span> *)object &#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, kAssociatedObjectKey, object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p><p>这种方式可以实现存取对象，但是不能获取<code>_object</code>变量。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category</a></p><p><a href="https://halfrost.com/objc_runtime_isa_class/" target="_blank" rel="external">神经病院 Objective-C Runtime 入院第一天—— isa 和 Class</a></p><p><a href="https://www.jianshu.com/p/0dc2513e117b" target="_blank" rel="external">探秘Runtime - 深入剖析Category</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Category&quot;&gt;&lt;a href=&quot;#什么是Category&quot; class=&quot;headerlink&quot; title=&quot;什么是Category?&quot;&gt;&lt;/a&gt;什么是Category?&lt;/h2&gt;&lt;p&gt;Category是Objective-C 2.0之后添加的语
      
    
    </summary>
    
      <category term="面试" scheme="https://vanchchen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS面试题</title>
    <link href="https://vanchchen.github.io/2018/09/14/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://vanchchen.github.io/2018/09/14/iOS面试题/</id>
    <published>2018-09-14T09:40:01.000Z</published>
    <updated>2018-09-14T09:42:46.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS基础题"><a href="#iOS基础题" class="headerlink" title="iOS基础题"></a>iOS基础题</h2><ol><li>分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？</li><li>讲一下atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？</li><li>被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？</li><li>关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将其指针置空么？</li><li>KVO的底层实现？如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？</li><li><code>Autoreleasepool</code>所使用的数据结构是什么？<code>AutoreleasePoolPage</code>结构体了解么？</li><li>讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的？为什么对象方法没有保存的对象结构体里，而是保存在类对象的结构体里？</li><li><code>class_ro_t</code> 和  <code>class_rw_t</code> 的区别？</li><li>iOS 中内省的几个方法？<code>class</code>方法和<code>objc_getClass</code>方法有什么区别?</li><li>在运行时创建类的方法<code>objc_allocateClassPair</code>的方法名尾部为什么是pair（成对的意思）？</li><li>一个int变量被<code>__block</code>修饰与否的区别？<br>\12. 为什么在block外部使用<code>__weak</code>修饰的同时需要在内部使用<code>__strong</code>修饰？</li><li>RunLoop的作用是什么？它的内部工作机制了解么？（最好结合线程和内存管理来说）</li><li>哪些场景可以触发离屏渲染？（知道多少说多少）</li></ol><hr><h2 id="iOS-实战题"><a href="#iOS-实战题" class="headerlink" title="iOS 实战题"></a>iOS 实战题</h2><ol><li>AppDelegate如何瘦身？</li><li>反射是什么？可以举出几个应用场景么？（知道多少说多少）</li><li>有哪些场景是NSOperation比GCD更容易实现的？（或是NSOperation优于GCD的几点，知道多少说多少）</li><li>App 启动优化策略？最好结合启动流程来说（main()函数的执行前后都分别说一下，知道多少说多少）</li><li>App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？（知道多少说多少）</li><li>你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？（知道多少说多少）</li><li>你知道有哪些情况会导致app卡顿，分别可以用什么方法来避免？（知道多少说多少）</li></ol><hr><h2 id="网络题"><a href="#网络题" class="headerlink" title="网络题"></a>网络题</h2><ol><li>App 网络层有哪些优化策略？</li><li>TCP为什么要三次握手，四次挥手？</li><li>对称加密和非对称加密的区别？分别有哪些算法的实现？</li><li>HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么？</li><li>HTTPS是如何实现验证身份和验证完整性的？</li><li>如何用Charles抓HTTPS的包？其中原理和流程是什么？</li><li>什么是中间人攻击？如何避免？</li></ol><hr><h2 id="计算机系统题"><a href="#计算机系统题" class="headerlink" title="计算机系统题"></a>计算机系统题</h2><ol><li>了解编译的过程么？分为哪几个步骤？</li><li>静态链接了解么？静态库和动态库的区别？</li><li>内存的几大区域，各自的职能分别是什么？</li><li>static和const有什么区别？</li><li>了解内联函数么？</li><li>什么时候会出现死锁？如何避免？</li><li>说一说你对线程安全的理解？</li><li>列举你知道的线程同步策略？</li><li>有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说</li></ol><hr><h2 id="设计模式题"><a href="#设计模式题" class="headerlink" title="设计模式题"></a>设计模式题</h2><ol><li>除了单例，观察者设计模式以外，还知道哪些设计模式？分别介绍一下</li><li>最喜欢哪个设计模式？为什么？</li><li>iOS SDK 里面有哪些设计模式的实践？</li><li>**设计模式是为了解决什么问题的？</li><li>**设计模式的成员构成以及工作机制是什么？</li><li>**设计模式的优缺点是什么？</li></ol><hr><h2 id="架构-amp-设计题"><a href="#架构-amp-设计题" class="headerlink" title="架构 &amp; 设计题"></a>架构 &amp; 设计题</h2><ol><li>MVC和MVVM的区别？MVVM和MVP的区别？</li><li>面向对象的几个设计原则了解么？最好可以结合场景来说。</li><li>可以说几个重构的技巧么？你觉得重构适合什么时候来做？</li><li>你觉得框架和设计模式的区别是什么？</li><li>看过哪些第三方框架的源码，它们是怎么设计的？设计好的地方在哪里，不好的地方在哪里，如何改进？（这道题的后三个问题的难度已经很高了，如果不是太N的公司不建议深究）</li></ol><hr><h2 id="数据结构-amp-算法题"><a href="#数据结构-amp-算法题" class="headerlink" title="数据结构&amp;算法题"></a>数据结构&amp;算法题</h2><ol><li>链表和数组的区别是什么？插入和查询的时间复杂度分别是多少？</li><li>哈希表是如何实现的？如何解决地址冲突？</li><li>排序题：冒泡排序，选择排序，插入排序，快速排序（二路，三路）能写出那些？</li><li>链表题：如何检测链表中是否有环？如何删除链表中等于某个值的所有节点？</li><li>数组题：如何在有序数组中找出和等于给定值的两个元素？如何合并两个有序的数组之后保持有序？</li><li>二叉树题：如何反转二叉树？如何验证两个二叉树是完全相等的？</li></ol><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://mp.weixin.qq.com/s/-cefmEo7RcZ5wifXX8JB5g" target="_blank" rel="external">出一套 iOS 高级面试题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;iOS基础题&quot;&gt;&lt;a href=&quot;#iOS基础题&quot; class=&quot;headerlink&quot; title=&quot;iOS基础题&quot;&gt;&lt;/a&gt;iOS基础题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？&lt;/li
      
    
    </summary>
    
      <category term="面试" scheme="https://vanchchen.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
</feed>
