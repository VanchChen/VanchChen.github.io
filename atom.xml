<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vanch&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/753583210964c7a8a41496ec0dc617dc</icon>
  <subtitle>欢迎来到我的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vanchchen.github.io/"/>
  <updated>2019-12-09T09:12:33.187Z</updated>
  <id>https://vanchchen.github.io/</id>
  
  <author>
    <name>Vanch</name>
    <email>447389831@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>逐步探究ObjC的Weak技术底层</title>
    <link href="https://vanchchen.github.io/p/3e6b.html"/>
    <id>https://vanchchen.github.io/p/3e6b.html</id>
    <published>2019-12-09T08:03:09.000Z</published>
    <updated>2019-12-09T09:12:33.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的文章有说过 <code>Atomic</code> 原子操作的原理，其作为一个特殊的修饰前缀，影响了存取操作。</p><p>在属性修饰定义中，还有另一类修饰前缀，他们分别是 <code>strong</code> <code>weak</code> <code>assign</code> <code>copy</code>，这些又有什么区别呢？</p><p>平时喜欢探究的同学，可能也见过 <code>unsafe_unretained</code>，这个又是什么呢？</p><p>让我们从属性修饰入手，逐步揭开弱引用的面纱。</p><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="属性自动生成的实现方法是怎么样的？"><a href="#属性自动生成的实现方法是怎么样的？" class="headerlink" title="属性自动生成的实现方法是怎么样的？"></a>属性自动生成的实现方法是怎么样的？</h3><p>首先我们先创建一个示例代码文件作为样本。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PropertyObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *pStrongObj; <span class="comment">//强引用</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSObject</span> *pCopyObj;   <span class="comment">//拷贝</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>)   <span class="built_in">NSObject</span> *pWeakObj;   <span class="comment">//弱引用</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSObject</span> *pAssignObj; <span class="comment">//申明</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>) <span class="built_in">NSObject</span> *pUnretainedObj; <span class="comment">//非持有</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PropertyObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后通过 <code>clang -rewrite-objc -fobjc-arc -stdlib=libc++ -mmacosx-version-min=10.14 -fobjc-runtime=macosx-10.14 -Wno-deprecated-declarations main.m</code> 命令将其解释成 <code>c++</code> 代码。（注意这里要指定版本，不然weak属性不能翻译）</p><p>展开的代码比较多，我这里截取关键部分探讨。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PropertyObject_IMPL</span> &#123;</span></span><br><span class="line">NSObject *__strong _pStrongObj;</span><br><span class="line">NSObject *__strong _pCopyObj;</span><br><span class="line">NSObject *__weak _pWeakObj;</span><br><span class="line">NSObject *__unsafe_unretained _pAssignObj;</span><br><span class="line">NSObject *__unsafe_unretained _pUnretainedObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"pStrongObj"</span>,<span class="string">"T@\"NSObject\",&amp;,N,V_pStrongObj"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pCopyObj"</span>,<span class="string">"T@\"NSObject\",C,N,V_pCopyObj"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pWeakObj"</span>,<span class="string">"T@\"NSObject\",W,N,V_pWeakObj"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pAssignObj"</span>,<span class="string">"T@\"NSObject\",N,V_pAssignObj"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pUnretainedObj"</span>,<span class="string">"T@\"NSObject\",N,V_pUnretainedObj"</span>&#125;</span><br></pre></td></tr></table></figure><p>从变量结构体的描述和特性可以看出，<code>strong</code>和<code>copy</code>实际都是<code>__strong</code>修饰，但特性不同，<code>assign</code>和<code>unsafe_unretained</code> 则完全一致，都是<code>__unsafe_unretained</code>，<code>weak</code>则单独使用<code>__weak</code>修饰。 </p><p>下面我们来看一下方法具体实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @implementation PropertyObject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据偏移取值和赋值</span></span><br><span class="line"><span class="keyword">static</span> NSObject * _I_PropertyObject_pStrongObj(PropertyObject * self, SEL _cmd) &#123; <span class="keyword">return</span> (*(NSObject *__strong *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_PropertyObject$_pStrongObj)); &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_PropertyObject_setPStrongObj_(PropertyObject * self, SEL _cmd, NSObject *pStrongObj) &#123; (*(NSObject *__strong *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_PropertyObject$_pStrongObj)) = pStrongObj; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NSObject * _I_PropertyObject_pCopyObj(PropertyObject * self, SEL _cmd) &#123; <span class="keyword">return</span> (*(NSObject *__strong *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_PropertyObject$_pCopyObj)); &#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> <span class="title">objc_setProperty</span> <span class="params">(id, SEL, <span class="keyword">long</span>, id, <span class="keyword">bool</span>, <span class="keyword">bool</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有Copy不同，setter的实现是objc_setProperty</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_PropertyObject_setPCopyObj_(PropertyObject * self, SEL _cmd, NSObject *pCopyObj) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct PropertyObject, _pCopyObj), (id)pCopyObj, <span class="number">0</span>, <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NSObject * _I_PropertyObject_pWeakObj(PropertyObject * self, SEL _cmd) &#123; <span class="keyword">return</span> (*(NSObject *__weak *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_PropertyObject$_pWeakObj)); &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_PropertyObject_setPWeakObj_(PropertyObject * self, SEL _cmd, NSObject *pWeakObj) &#123; (*(NSObject *__weak *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_PropertyObject$_pWeakObj)) = pWeakObj; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NSObject * _I_PropertyObject_pAssignObj(PropertyObject * self, SEL _cmd) &#123; <span class="keyword">return</span> (*(NSObject *__unsafe_unretained *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_PropertyObject$_pAssignObj)); &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_PropertyObject_setPAssignObj_(PropertyObject * self, SEL _cmd, NSObject *pAssignObj) &#123; (*(NSObject *__unsafe_unretained *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_PropertyObject$_pAssignObj)) = pAssignObj; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NSObject * _I_PropertyObject_pUnretainedObj(PropertyObject * self, SEL _cmd) &#123; <span class="keyword">return</span> (*(NSObject *__unsafe_unretained *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_PropertyObject$_pUnretainedObj)); &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_PropertyObject_setPUnretainedObj_(PropertyObject * self, SEL _cmd, NSObject *pUnretainedObj) &#123; (*(NSObject *__unsafe_unretained *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_PropertyObject$_pUnretainedObj)) = pUnretainedObj; &#125;</span><br><span class="line"><span class="comment">// @end</span></span><br></pre></td></tr></table></figure><p>在代码中，只有<code>copy</code>修饰属性的<code>setter</code>方法使用了<code>objc_setProperty</code>，其他几种都是根据 <code>self + 偏移量</code> 的方式计算出内存地址直接进行存取。</p><p>那问题来了，如果真的是那么简单的话，<code>arc</code> 是怎么实现根据不同修饰从而进行内存管理的呢？</p><p>原来通过 <code>clang -rewrite-objc</code> 的代码只是翻译成 <code>c++</code> 语言，在之后的编译过程中会进一步处理。</p><p>接着使用 <code>clang -S -fobjc-arc -emit-llvm main.m -o main.ll</code> 命令生成中间码。</p><p>（中间码显示比较杂乱，我根据自己理解整理成简洁版）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//代码整理后</span><br><span class="line">id [PropertyObject pStrongObj] &#123;</span><br><span class="line">  return *location; </span><br><span class="line">&#125;</span><br><span class="line">void [PropertyObject setPStrongObj:](self, _cmd, obj) &#123;</span><br><span class="line">  @llvm.objc.storeStrong(*location, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id [PropertyObject pCopyObj] &#123;</span><br><span class="line">  return @objc_getProperty(self, _cmd, offset, atomic)</span><br><span class="line">&#125;</span><br><span class="line">void [PropertyObject setPCopyObj:](self, _cmd, obj) &#123;</span><br><span class="line">  @objc_setProperty_nonatomic_copy(self, _cmd, obj, offset)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id [PropertyObject pWeakObj] &#123;</span><br><span class="line">  id obj = @llvm.objc.loadWeakRetained(*location)</span><br><span class="line">  return @llvm.objc.autoreleaseReturnValue(obj)</span><br><span class="line">&#125;</span><br><span class="line">void [PropertyObject setPWeakObj:](self, _cmd, obj) &#123;</span><br><span class="line">  @llvm.objc.storeWeak(*location, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id [PropertyObject pAssignObj] &#123;</span><br><span class="line">  return *location</span><br><span class="line">&#125;</span><br><span class="line">void [PropertyObject setPAssignObj:](self, _cmd, obj) &#123;</span><br><span class="line">  *location = obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id [PropertyObject pUnretainedObj] &#123;</span><br><span class="line">  return *location</span><br><span class="line">&#125;</span><br><span class="line">void [PropertyObject setPUnretainedObj:](self, _cmd, obj) &#123;</span><br><span class="line">  *location = obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出分别针对<code>strong</code> 和 <code>weak</code> 都做了处理，而<code>assign</code> 和 <code>unsafe_unretained</code>则不做内存管理直接返回，这也说明这两者的处理方式是一样的，区别在于 <code>assign</code> 针对。</p><table><thead><tr><th></th><th>strong</th><th>copy</th><th>weak</th><th>assign</th><th>unsafe_unretained</th></tr></thead><tbody><tr><td>Ownership</td><td>__strong</td><td>__strong</td><td>__weak</td><td>__unsafe_unretained</td><td>__unsafe_unretained</td></tr><tr><td>Getter</td><td>*location</td><td>objc_getProperty</td><td>loadWeakRetained</td><td>*location</td><td>*location</td></tr><tr><td>Setter</td><td>storeStrong</td><td>objc_setProperty</td><td>storeWeak</td><td>*location</td><td>*location</td></tr><tr><td>对象</td><td>NSObject</td><td>NSObject</td><td>NSObject</td><td>NSObject</td><td>Scalar</td></tr></tbody></table><h3 id="Weak对象怎么实现存取的？"><a href="#Weak对象怎么实现存取的？" class="headerlink" title="Weak对象怎么实现存取的？"></a>Weak对象怎么实现存取的？</h3><p>本文篇幅有限，暂不介绍 <code>storeStrong</code> 和 <code>objc_setProperty_nonatomic_copy</code>，主要介绍 <code>weak</code> 相关操作。</p><p>打开 <code>objc4-750</code> 开源代码，翻到 <code>NSObject.mm</code>，我们来一探究竟。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化弱引用</span></span><br><span class="line"><span class="function">id <span class="title">objc_initWeak</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不存在则不保存</span></span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 销毁弱引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_destroyWeak</span><span class="params">(id *location)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (location, nil);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换原有的值</span></span><br><span class="line"><span class="function">id <span class="title">objc_storeWeak</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object *)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>runtime</code> 中调用的都是一个方法，区别在于使用了不同的模版，那么我们来看下对一个地址的存取方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取操作的具体实现</span></span><br><span class="line"><span class="function">id <span class="title">objc_loadWeakRetained</span><span class="params">(id *location)</span> </span>&#123;</span><br><span class="line">    id obj;</span><br><span class="line">    id result;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    SideTable *table;</span><br><span class="line">    </span><br><span class="line"> retry:</span><br><span class="line">    <span class="comment">// 保证地址有数据且不是伪指针</span></span><br><span class="line">    obj = *location;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">// 根据地址取出对应的表</span></span><br><span class="line">    table = &amp;SideTables()[obj];</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    table-&gt;lock();</span><br><span class="line">    <span class="comment">// 如果数据被其他线程改变，则重试</span></span><br><span class="line">    <span class="keyword">if</span> (*location != obj) &#123;</span><br><span class="line">        table-&gt;unlock();</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    result = obj;</span><br><span class="line"></span><br><span class="line">    cls = obj-&gt;ISA();</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;hasCustomRR()) &#123;</span><br><span class="line">        <span class="comment">// 如果使用的是系统默认的内存管理，则保证了已经初始化</span></span><br><span class="line">        <span class="comment">// 所以可以直接rootTryRetain</span></span><br><span class="line">        assert(cls-&gt;isInitialized());</span><br><span class="line">        <span class="keyword">if</span> (! obj-&gt;rootTryRetain()) &#123;</span><br><span class="line">            result = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是默认的，则需要确保在初始化线程上执行自定义retain操作</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isInitialized() || _thisThreadIsInitializingClass(cls)) &#123;</span><br><span class="line">            BOOL (*tryRetain)(id, SEL) = (BOOL(*)(id, SEL))</span><br><span class="line">                class_getMethodImplementation(cls, SEL_retainWeakReference);</span><br><span class="line">            <span class="keyword">if</span> ((IMP)tryRetain == _objc_msgForward) &#123;</span><br><span class="line">                result = nil;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (*tryRetain)(obj, SEL_retainWeakReference)) &#123;</span><br><span class="line">                result = nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            table-&gt;unlock();</span><br><span class="line">            _class_initialize(cls);</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成后解锁</span></span><br><span class="line">    table-&gt;unlock();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保存操作的具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id <span class="title">storeWeak</span><span class="params">(id *location, objc_object *newObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两者必须有一个，不然没有执行的必要</span></span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) assert(newObj == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于有锁的机制，如果在期间值被改变了，则重试，直到成功</span></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj]; <span class="comment">// 根据内存地址获取表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁住这两张表，注意如果是同一张表也没关系，有对锁做判断</span></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查如果已经改变了，则重试</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查新对象类有没有初始化完，没有则重试</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果正在初始化，则让下一次绕过这个判断继续运行</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除之前保存的弱引用数据</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存新的弱引用数据</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        <span class="comment">// 保存成功就记录到对象指针中，这样可以在释放时检查</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存到对应位置</span></span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 操作成功后解锁</span></span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">    <span class="comment">// 返回最终数据</span></span><br><span class="line">    <span class="keyword">return</span> (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除去保护方法，其实 <code>objc_loadWeakRetained</code> 方法就是检查后返回 <code>*location</code>，也就是变量指向的实际地址。</p><p>而 <code>storeWeak</code> 方法则是根据模版，对旧对象执行 <code>weak_unregister_no_lock</code>，对新对象执行 <code>weak_register_no_lock</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注销引用</span></span><br><span class="line"><span class="keyword">void</span> weak_unregister_no_lock</span><br><span class="line">    (<span class="keyword">weak_table_t</span> *weak_table, id referent_id, id *referrer_id) &#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;   <span class="comment">//被引用人</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id; <span class="comment">//引用人</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取被引用人的引用数组</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">//移除引用人</span></span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果一个引用也没了，则删除节点</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">    <span class="comment">// 上面为苹果注释，看这意思应该是objc_storeWeak还需要使用引用地址做后续处理。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册引用</span></span><br><span class="line">id weak_register_no_lock</span><br><span class="line">    (<span class="keyword">weak_table_t</span> *weak_table, id referent_id, </span><br><span class="line">     id *referrer_id, <span class="keyword">bool</span> crashIfDeallocating) &#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;     <span class="comment">//被引用人</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;   <span class="comment">//引用人</span></span><br><span class="line">    <span class="comment">// taggedPointer没有引用计数，不需要处理</span></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证被引用人不在释放中，不然闪退</span></span><br><span class="line">    <span class="keyword">bool</span> deallocating;</span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        BOOL (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (BOOL(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((id)referent, </span><br><span class="line">                                           SEL_allowsWeakReference);</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Cannot form weak reference to instance (%p) of "</span></span><br><span class="line">                        <span class="string">"class %s. It is possible that this object was "</span></span><br><span class="line">                        <span class="string">"over-released, or is in the process of deallocation."</span>,</span><br><span class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((id)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取被引用人的引用数组，没有则创建</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry;</span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">weak_entry_t</span> new_entry(referent, referrer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放过程清空引用</span></span><br><span class="line"><span class="keyword">void</span> weak_clear_no_lock</span><br><span class="line">    (<span class="keyword">weak_table_t</span> *weak_table, id referent_id) &#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id; <span class="comment">//被引用人</span></span><br><span class="line">    <span class="comment">//获取被引用人的引用数组</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="comment">//这里应该肯定有entry，因为调用前判断了对象的WeaklyReferenced</span></span><br><span class="line">        <span class="comment">//如果确实没有，苹果认为可能是CF/objc原因</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空引用数组</span></span><br><span class="line">    <span class="keyword">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组，找到每个引用人，清空他们的指向地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></span><br><span class="line">                             <span class="string">"This is probably incorrect use of "</span></span><br><span class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除节点</span></span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，对申明是 <code>__weak</code> 的变量进行存取操作，其实都是通过被操作的对象地址查找到相应的表，然后增删表的引用数组内容。</p><h3 id="SideTable表怎么设计的？"><a href="#SideTable表怎么设计的？" class="headerlink" title="SideTable表怎么设计的？"></a>SideTable表怎么设计的？</h3><p>关键就在于怎么申明创建表，以及这个表是怎么设计及使用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SideTables 类型申明</span></span><br><span class="line"><span class="comment">// 这里之所以先使用数据的方式申明是因为考虑到加载顺序的问题</span></span><br><span class="line">alignas(StripedMap&lt;SideTable&gt;) <span class="keyword">static</span> <span class="keyword">uint8_t</span> </span><br><span class="line">    SideTableBuf[<span class="keyword">sizeof</span>(StripedMap&lt;SideTable&gt;)];</span><br><span class="line"><span class="comment">// 加载image时执行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SideTableInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> (SideTableBuf) StripedMap&lt;SideTable&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组还原成StripedMap类型</span></span><br><span class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StripedMap 的结构</span></span><br><span class="line"><span class="keyword">enum</span> &#123; CacheLineSize = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StripedMap</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 64位对齐</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PaddedT</span> &#123;</span></span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 手机系统数组个数为8</span></span><br><span class="line">    PaddedT <span class="built_in">array</span>[StripeCount];</span><br><span class="line">    <span class="comment">// 把指针地址匹配到数组的序号</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</span><br><span class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在加载镜像的过程中，通过 <code>SideTableInit</code> 方法创建全局表数组，可以看到手机系统是8个数组。</p><p>源码中使用 <code>&amp;SideTables()[obj]</code> 的方式，其实就是把 <code>obj</code> 的指针地址转成序号获取某一个 <code>table</code>，通过这种方式分散冗余。</p><p>接着我们看 <code>SideTable</code> 类的内部结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希散列表，使用补码的形式把指针地址作为Key，保存引用计数</span></span><br><span class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,<span class="keyword">size_t</span>,<span class="literal">true</span>&gt; RefcountMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Template parameters.</span></span><br><span class="line"><span class="keyword">enum</span> HaveOld &#123; DontHaveOld = <span class="literal">false</span>, DoHaveOld = <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span> HaveNew &#123; DontHaveNew = <span class="literal">false</span>, DoHaveNew = <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;       <span class="comment">// 自旋锁</span></span><br><span class="line">    RefcountMap refcnts;    <span class="comment">// 引用记数表</span></span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;<span class="comment">// 弱引用表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lockTwo</span><span class="params">(SideTable *lock1, SideTable *lock2)</span></span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;HaveOld, HaveNew&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unlockTwo</span><span class="params">(SideTable *lock1, SideTable *lock2)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries;     <span class="comment">//弱引用数组</span></span><br><span class="line">    <span class="keyword">size_t</span>    num_entries;          <span class="comment">//数组个数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> mask;                 <span class="comment">//计算辅助量，数值为数组总数-1</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;<span class="comment">//哈希最大偏移量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_MINUS_2 62</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_MINUS_2 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> DisguisedPtr&lt;objc_object *&gt; <span class="keyword">weak_referrer_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 被引用者</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 引用者数据结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">// 当数量超过4个时，结构转为指针，每次容量满的时候就扩容两倍</span></span><br><span class="line">            <span class="comment">// 需要与数组作区分，所以有out_of_line_ness标记</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span> *referrers;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_2;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        mask;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">// 四个数组</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span>  inline_referrers[<span class="number">4</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>SideTable</code> 存储的不仅有对象引用计数表，还有我们关注的弱引用表，其结构顺序如下：</p><p><code>SideTable-&gt;weak_table_t-&gt;weak_entry_t-&gt;weak_referrer_t</code></p><p>为了方便理解，我模拟一下找弱引用对象的步骤:</p><ol><li><p><code>sideTable = &amp;SideTables()[referent]</code> 把对象内存地址按照8取余后找到表</p></li><li><p><code>weakTable = &amp;sideTable-&gt;weak_table</code> 取出弱引用表</p></li><li><p><code>entry = weak_entry_for_referent(weakTable, referent)</code> 根据被引用人地址，遍历弱引用表找出入口</p></li><li><p><code>referrer = entry-&gt;referrers[index]</code> 入口有特殊的数组，其中保存了所有弱引用者的对象地址</p></li></ol><p>仔细一点的同学应该发现了 <code>weak_entry_t</code> 中有一个联合体，这又是怎么操作实现的呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加新引用者</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> append_referrer</span><br><span class="line">    (<span class="keyword">weak_entry_t</span> *entry, objc_object **new_referrer) &#123;</span><br><span class="line">    <span class="comment">// 没有超过4个，就用内敛数组</span></span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="comment">// 遍历数组，如果有空位置，则插入后返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == nil) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果超过4个了，就从数组结构转成指针结构</span></span><br><span class="line">        <span class="keyword">weak_referrer_t</span> *new_referrers = (<span class="keyword">weak_referrer_t</span> *)</span><br><span class="line">            <span class="built_in">calloc</span>(WEAK_INLINE_COUNT, <span class="keyword">sizeof</span>(<span class="keyword">weak_referrer_t</span>));</span><br><span class="line">        <span class="comment">// 拷贝原数据到指针指向的内容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry-&gt;referrers = new_referrers;                <span class="comment">//指针数组</span></span><br><span class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;             <span class="comment">//数组元素个数</span></span><br><span class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE; <span class="comment">//是否是指针的标记位</span></span><br><span class="line">        entry-&gt;mask = WEAK_INLINE_COUNT<span class="number">-1</span>;               <span class="comment">//数组最大下标，用于取余</span></span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;                <span class="comment">//最大hash移位次数，用于优化循环</span></span><br><span class="line">        <span class="comment">// 由于只有4个，会在下个判断后执行grow_refs_and_insert初始化并插入新对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断言必然是指针结构</span></span><br><span class="line">    assert(entry-&gt;out_of_line());</span><br><span class="line">    <span class="comment">// 如果指针数量超过3/4，就容量翻倍后再插入</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="keyword">size_t</span> index = begin;</span><br><span class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找一个空位置，不够就从头找</span></span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != nil) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask; <span class="comment">//下标+1后取余</span></span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存</span></span><br><span class="line">    <span class="keyword">weak_referrer_t</span> &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此对于弱引用的整体结构和逻辑都清楚了，对象根据修饰符进行内存管理，如果是弱引用，则找到其引用地址的引用表操作。</p><p>反过来讲，强对象被引用时在全局引用表中注册一个节点，保存所有引用者的地址，当释放时设置所有地址为空。</p><hr><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><p>被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？</p><p>对象被释放时执行 <code>obj-&gt;rootDealloc()</code>，如果有弱引用标记，则会执行 <code>objc_destructInstance</code> 方法后释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);           <span class="comment">//调用析构函数</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj); <span class="comment">//移除关联对象关系</span></span><br><span class="line">        obj-&gt;clearDeallocating();                   <span class="comment">//处理isa</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> objc_object::clearDeallocating() &#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> objc_object::sidetable_clearDeallocating() &#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除强引用和弱引用</span></span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123;</span><br><span class="line">            weak_clear_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        table.refcnts.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <code>sidetable_clearDeallocating</code> 方法中，最后执行了 <code>weak_clear_no_lock</code> 清空了所有引用关系。</p><p><code>SideTable</code> 表结构如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1571032889_32.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><hr><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>weak原理是绕不开的经典课题，通过阅读开源代码对苹果如何实现有了大致的了解，受益匪浅。</p><p>阅读过程中还惊叹于苹果各种花式小技巧，由于文章篇幅有限没来得及介绍，感兴趣可以了解一下，比如 <code>DisguisedPtr</code>。</p><h2 id="资料分享"><a href="#资料分享" class="headerlink" title="资料分享"></a>资料分享</h2><p><a href="https://blog.sunnyxx.com/2015/09/13/class-ivar-layout/" target="_blank" rel="noopener">Objective-C Class Ivar Layout 探索</a></p><p><a href="https://juejin.im/post/5ce2b7386fb9a07eff005b4c" target="_blank" rel="noopener">理解 ARC 实现原理</a></p><p><a href="https://www.desgard.com/weak/" target="_blank" rel="noopener">weak 弱引用的实现方式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前的文章有说过 &lt;code&gt;Atomic&lt;/code&gt; 原子操作的原理，其作为一个特殊的修饰前缀，影响了存取操作。&lt;/p&gt;
&lt;p&gt;在属性修
      
    
    </summary>
    
      <category term="iOS" scheme="https://vanchchen.github.io/categories/iOS/"/>
    
    
      <category term="原理分析" scheme="https://vanchchen.github.io/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Atomic原子操作原理剖析</title>
    <link href="https://vanchchen.github.io/p/168d.html"/>
    <id>https://vanchchen.github.io/p/168d.html</id>
    <published>2018-12-28T09:40:47.000Z</published>
    <updated>2019-10-08T06:34:01.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>绝大部分 <code>Objective-C</code> 程序员使用属性时，都不太关注一个特殊的修饰前缀，一般都无脑的使用其非默认缺省的状态，他就是 <code>atomic</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PropertyClass</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">strong</span>)    <span class="built_in">NSObject</span> *atomicObj;  <span class="comment">//缺省也是atomic</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *nonatomicObj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>入门教程中一般都建议使用非原子操作，因为新手大部分操作都在主线程，用不到线程安全的特性，大量使用还会降低执行效率。</p><p>那他到底怎么实现线程安全的呢？使用了哪种技术呢？</p><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="属性的实现"><a href="#属性的实现" class="headerlink" title="属性的实现"></a>属性的实现</h3><p>首先我们研究一下属性包含的内容。通过查阅源码，其结构如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> property_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;       <span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes; <span class="comment">//特性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>属性的结构比较简单，包含了固定的名字和元素，可以通过 <code>property_getName</code> 获取属性名，<code>property_getAttributes</code> 获取特性。</p><p>上例中 <code>atomicObj</code> 的特性为 <code>T@&quot;NSObject&quot;,&amp;,V_atomicObj</code>，其中 <code>&amp;</code> 代表了 <code>strong</code>，<code>atomic</code> 特性缺省没有显示，如果是 <code>nonatomic</code> 则显示 <code>N</code>。</p><p>那到底是怎么实现原子操作的呢？ 通过引入<code>runtime</code>，我们能调试一下调用的函数栈。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1545990117_87.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可以看到在编译时就把属性特性考虑进去了，<code>Setter</code> 方法直接调用了 <code>objc_setProperty</code> 的 <code>atomic</code> 版本。这里不用 <code>runtime</code> 去动态分析特性，应该是对执行性能的考虑。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> reallySetProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, </span><br><span class="line">    <span class="keyword">id</span> newValue, ptrdiff_t offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> <span class="keyword">copy</span>, <span class="keyword">bool</span> mutableCopy) &#123;</span><br><span class="line">    <span class="comment">//偏移为0说明改的是isa</span></span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(<span class="keyword">self</span>, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> oldValue;</span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);<span class="comment">//获取原值</span></span><br><span class="line">    <span class="comment">//根据特性拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">copy</span>) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断原子性</span></span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        <span class="comment">//非原子直接赋值</span></span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//原子操作使用自旋锁</span></span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> objc_getProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, ptrdiff_t offset, <span class="built_in">BOOL</span> atomic) &#123;</span><br><span class="line">    <span class="comment">// 取isa</span></span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非原子操作直接返回</span></span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);</span><br><span class="line">    <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 原子操作自旋锁</span></span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    <span class="keyword">id</span> value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出于性能考虑，在锁之外autorelease</span></span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么是自旋锁呢？"><a href="#什么是自旋锁呢？" class="headerlink" title="什么是自旋锁呢？"></a>什么是自旋锁呢？</h3><p>锁用于解决线程争夺资源的问题，一般分为两种，自旋锁(spin)和互斥锁(mutex)。</p><p>互斥锁可以解释为线程获取锁，发现锁被占用，就向系统申请锁空闲时唤醒他并立刻休眠。</p><p>自旋锁比较简单，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。</p><p>原子操作的颗粒度最小，只限于读写，对于性能的要求很高，如果使用了互斥锁势必在切换线程上耗费大量资源。相比之下，由于读写操作耗时比较小，能够在一个时间片内完成，自旋更适合这个场景。</p><h3 id="自旋锁的坑"><a href="#自旋锁的坑" class="headerlink" title="自旋锁的坑"></a>自旋锁的坑</h3><p>但是iOS 10之后，苹果因为一个巨大的缺陷弃用了 <code>OSSpinLock</code> 改为新的 <code>os_unfair_lock</code>。</p><blockquote><p>新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。</p><p>描述引用自 <strong>ibireme</strong> 大神的文章。</p></blockquote><p>我的理解是，当低优先级线程获取了锁，高优先级线程访问时陷入忙等状态，由于是循环调用，所以占用了系统调度资源，导致低优先级线程迟迟不能处理资源并释放锁，导致陷入死锁。</p><p>那为什么原子操作用的还是 <code>spinlock_t</code> 呢？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using spinlock_t = mutex_tt&lt;LOCKDEBUG&gt;;</span><br><span class="line">using mutex_t = mutex_tt&lt;LOCKDEBUG&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> mutex_tt : nocopy_t &#123;</span><br><span class="line">    os_unfair_lock mLock; <span class="comment">//处理了优先级的互斥锁</span></span><br><span class="line">    <span class="keyword">void</span> lock() &#123;</span><br><span class="line">        lockdebug_mutex_lock(<span class="keyword">this</span>);</span><br><span class="line">        os_unfair_lock_lock_with_options_inline</span><br><span class="line">            (&amp;mLock, OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> unlock() &#123;</span><br><span class="line">        lockdebug_mutex_unlock(<span class="keyword">this</span>);</span><br><span class="line">        os_unfair_lock_unlock_inline(&amp;mLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>差点被苹果骗了！原来系统中自旋锁已经全部改为互斥锁实现了，只是名称一直没有更改。</p><p>为了修复优先级反转的问题，苹果也只能放弃使用自旋锁，改用优化了性能的 <code>os_unfair_lock</code>，实际测试两者的效率差不多。</p><hr><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><h3 id="atomic的实现机制"><a href="#atomic的实现机制" class="headerlink" title="atomic的实现机制"></a>atomic的实现机制</h3><p>使用<code>atomic</code> 修饰属性，编译器会设置默认读写方法为原子读写，并使用互斥锁添加保护。</p><h3 id="为什么不能保证绝对的线程安全？"><a href="#为什么不能保证绝对的线程安全？" class="headerlink" title="为什么不能保证绝对的线程安全？"></a>为什么不能保证绝对的线程安全？</h3><p>单独的原子操作绝对是线程安全的，但是组合一起的操作就不能保证。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)competition &#123;</span><br><span class="line">    <span class="keyword">self</span>.intSource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">self</span>.intSource = <span class="keyword">self</span>.intSource + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">self</span>.intSource = <span class="keyword">self</span>.intSource + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终得到的结果肯定小于20000。当获取值的时候都是原子线程安全操作，比如两个线程依序获取了当前值 <code>0</code>，于是分别增量后变为了 <code>1</code>，所以两个队列依序写入值都是 <code>1</code>，所以不是线程安全的。</p><p>解决的办法应该是增加颗粒度，将读写两个操作合并为一个原子操作，从而解决写入过期数据的问题。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">os_unfair_lock_t unfairLock;</span><br><span class="line">- (<span class="keyword">void</span>)competition &#123;</span><br><span class="line">    <span class="keyword">self</span>.intSource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">          os_unfair_lock_lock(unfairLock);</span><br><span class="line">          <span class="keyword">self</span>.intSource = <span class="keyword">self</span>.intSource + <span class="number">1</span>;</span><br><span class="line">          os_unfair_lock_unlock(unfairLock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">          os_unfair_lock_lock(unfairLock);</span><br><span class="line">          <span class="keyword">self</span>.intSource = <span class="keyword">self</span>.intSource + <span class="number">1</span>;</span><br><span class="line">          os_unfair_lock_unlock(unfairLock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过学习属性的原子性，对系统中锁的理解又加深，包括自旋锁，互斥锁，读写锁等。</p><p>本来都以为实现是自旋锁了，还好留了个心眼多看了一层才发现最终实现还是互斥锁。这件事也给我一个小教训，查阅源码还是要刨根问底，只浮于表面的话，可能得不到想要的真相。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://github.com/gcfrun/objc4-750" target="_blank" rel="noopener">可以编译的runtime库</a></p><p><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;绝大部分 &lt;code&gt;Objective-C&lt;/code&gt; 程序员使用属性时，都不太关注一个特殊的修饰前缀，一般都无脑的使用其非默认缺省的状
      
    
    </summary>
    
      <category term="iOS" scheme="https://vanchchen.github.io/categories/iOS/"/>
    
    
      <category term="原理分析" scheme="https://vanchchen.github.io/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>三种UIScrollView嵌套实现方案</title>
    <link href="https://vanchchen.github.io/p/7448.html"/>
    <id>https://vanchchen.github.io/p/7448.html</id>
    <published>2018-12-25T09:34:25.000Z</published>
    <updated>2018-12-25T09:54:50.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着产品功能不断的迭代，总会有需求希望在保证不影响其他区域功能的前提下，在某一区域实现根据选择器切换不同的内容显示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/gif/gif_1699821243_12.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><p>苹果并不推荐嵌套滚动视图，如果直接添加的话，就会出现下图这种情况，手势的冲突造成了体验上的悲剧。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/gif/gif_1544777437_77.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在实际开发中，我也不断的在思考解决方案，经历了几次重构后，有了些改进的经验，因此抽空整理了三种方案，他们实现的最终效果都是一样的。</p><hr><h2 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h2><p>最常见的一种方案就是使用 <code>UITableView</code> 作为外部框架，将子视图的内容通过 <code>UITableViewCell</code> 的方式展现。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1545731447_55.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这种做法的好处在于解耦性，框架只要接受不同的数据源就能刷新对应的内容。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> </span><br><span class="line">    -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> indexPath.section == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NSTHeaderHeight</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> segmentView.selectedIndex == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tableSource.tableView(<span class="number">_</span>:tableView, heightForRowAt:indexPath)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> webSource.tableView(<span class="number">_</span>:tableView, heightForRowAt:indexPath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是相对的也有一个问题，如果内部是一个独立的滚动视图，比如 <code>UIWebView</code> 的子视图 <code>UIWebScrollView</code>，还是会有手势冲突的情况。</p><p>常规做法首先禁止内部视图的滚动，当滚动到网页的位置时，启动网页的滚动并禁止外部滚动，反之亦然。</p><p>不幸的是，这种方案最大的问题是<strong>顿挫感</strong>。</p><p>内部视图初始是不能滚动的，所以外部视图作为整套事件的接收者。当滚动到预设的位置并开启了内部视图的滚动，事件还是传递给唯一接收者外部视图，只有松开手结束事件后重新触发，才能使内部视图开始滚动。</p><p>好在有一个方法可以解决这个问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScroll</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> scrollView == tableView &#123;</span><br><span class="line">        <span class="comment">//外部在滚动</span></span><br><span class="line">        <span class="keyword">if</span> offset &gt; anchor &#123;</span><br><span class="line">            <span class="comment">//滚到过了锚点，还原外部视图位置，添加偏移到内部</span></span><br><span class="line">            tableView.setContentOffset(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: anchor), animated: <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">let</span> webOffset = webScrollView.contentOffset.y + offset - anchor</span><br><span class="line">            webScrollView.setContentOffset(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: webOffset), animated: <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> offset &lt; anchor &#123;</span><br><span class="line">            <span class="comment">//没滚到锚点，还原位置</span></span><br><span class="line">            webScrollView.setContentOffset(<span class="type">CGPoint</span>.zero, animated: <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//内部在滚动</span></span><br><span class="line">        <span class="keyword">if</span> offset &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">//内部滚动还原外部位置</span></span><br><span class="line">            tableView.setContentOffset(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: anchor), animated: <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> offset &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">//内部往上滚，添加偏移量到外部视图</span></span><br><span class="line">            <span class="keyword">let</span> tableOffset = tableView.contentOffset.y + offset</span><br><span class="line">            tableView.setContentOffset(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: tableOffset), animated: <span class="literal">false</span>)</span><br><span class="line">            webScrollView.setContentOffset(<span class="type">CGPoint</span>.zero, animated: <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndScroll</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">    <span class="comment">//根据滚动停止后的偏移量，计算谁可以滚动</span></span><br><span class="line">    <span class="keyword">var</span> outsideScrollEnable = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> scrollView == tableView &#123;</span><br><span class="line">        <span class="keyword">if</span> offset == anchor &amp;&amp;</span><br><span class="line">            webScrollView.contentOffset.y &gt; <span class="number">0</span> &#123;</span><br><span class="line">            outsideScrollEnable = <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outsideScrollEnable = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> offset == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            tableView.contentOffset.y &lt; anchor &#123;</span><br><span class="line">            outsideScrollEnable = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outsideScrollEnable = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置滚动，显示对应的滚动条</span></span><br><span class="line">    tableView.isScrollEnabled = outsideScrollEnable</span><br><span class="line">    tableView.showsHorizontalScrollIndicator = outsideScrollEnable</span><br><span class="line">    webScrollView.isScrollEnabled = !outsideScrollEnable</span><br><span class="line">    webScrollView.showsHorizontalScrollIndicator = !outsideScrollEnable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过接受滚动回调，我们就可以人为控制滚动行为。当滚动距离超过了我们的预设值，就可以设置另一个视图的偏移量模拟出滚动的效果。滚动状态结束后，再根据判断来定位哪个视图可以滚动。</p><p>当然要使用这个方法，我们就必须把两个滚动视图的代理都设置为控制器，可能会对代码逻辑有影响 (UIWebView 是 UIWebScrollView 的代理，后文有解决方案)。</p><p><code>UITableView</code> 嵌套的方式，能够很好的解决嵌套简单视图，遇到 <code>UIWebView</code> 这种复杂情况，也能人为控制解决。但是作为 <code>UITableView</code> 的一环，有很多限制(比如不同数据源需要不同的设定，有的希望动态高度，有的需要插入额外的视图)，这些都不能很好的解决。</p><hr><h2 id="各自为政"><a href="#各自为政" class="headerlink" title="各自为政"></a>各自为政</h2><p>另一种解决方案比较反客为主，灵感来源于下拉刷新的实现方式，也就是将需要显示的内容塞入负一屏。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1545731463_75.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>首先保证子视图撑满全屏，把主视图内容插入子视图，并设置 <code>ContentInset</code> 为头部高度，从而实现效果。</p><p>来看下代码实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadScrollView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//选择当前显示的视图</span></span><br><span class="line">    <span class="keyword">let</span> scrollView = segmentView.selectedIndex == <span class="number">0</span> ? </span><br><span class="line">        tableSource.tableView : webSource.webView.scrollView</span><br><span class="line">    <span class="comment">//相同视图就不操作了</span></span><br><span class="line">    <span class="keyword">if</span> currentScrollView == scrollView &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从上次的视图中移除外部内容</span></span><br><span class="line">    headLabel.removeFromSuperview()</span><br><span class="line">    segmentView.removeFromSuperview()</span><br><span class="line">    <span class="keyword">if</span> currentScrollView != <span class="literal">nil</span> &#123;</span><br><span class="line">        currentScrollView!.removeFromSuperview()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置新滚动视图的内嵌偏移量为外部内容的高度</span></span><br><span class="line">    scrollView.contentInset = <span class="type">UIEdgeInsets</span>(top: </span><br><span class="line">        <span class="type">NSTSegmentHeight</span> + <span class="type">NSTHeaderHeight</span>, <span class="keyword">left</span>: <span class="number">0</span>, bottom: <span class="number">0</span>, <span class="keyword">right</span>: <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//添加外部内容到新视图上</span></span><br><span class="line">    scrollView.addSubview(headLabel)</span><br><span class="line">    scrollView.addSubview(segmentView)</span><br><span class="line">    view.addSubview(scrollView)</span><br><span class="line">    </span><br><span class="line">    currentScrollView = scrollView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在UI层级就只存在一个滚动视图，所以巧妙的避开了冲突。</p><p>相对的，插入的头部视图必须要轻量，如果需要和我例子中一样实现浮动栏效果，就要观察偏移量的变化手动定位。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadScrollView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> currentScrollView != <span class="literal">nil</span> &#123;</span><br><span class="line">        currentScrollView!.removeFromSuperview()</span><br><span class="line">        <span class="comment">//移除之前的 KVO</span></span><br><span class="line">        observer?.invalidate()</span><br><span class="line">        observer = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新视图添加滚动观察</span></span><br><span class="line">    observer = scrollView.observe(\.contentOffset, options: [.new, .initial]) </span><br><span class="line">    &#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] object, change <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> strongSelf = <span class="keyword">self</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> closureScrollView = object <span class="keyword">as</span> <span class="type">UIScrollView</span></span><br><span class="line">        <span class="keyword">var</span> segmentFrame = strongSelf.segmentView.frame</span><br><span class="line">        <span class="comment">//计算偏移位置</span></span><br><span class="line">        <span class="keyword">let</span> safeOffsetY = closureScrollView.contentOffset.y + </span><br><span class="line">            closureScrollView.safeAreaInsets.top</span><br><span class="line">        <span class="comment">//计算浮动栏位置</span></span><br><span class="line">        <span class="keyword">if</span> safeOffsetY &lt; -<span class="type">NSTSegmentHeight</span> &#123;</span><br><span class="line">            segmentFrame.origin.y = -<span class="type">NSTSegmentHeight</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            segmentFrame.origin.y = safeOffsetY</span><br><span class="line">        &#125;</span><br><span class="line">        strongSelf.segmentView.frame = segmentFrame</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这方法有一个坑，如果加载的 <code>UITableView</code> 需要显示自己的 <code>SectionHeader</code> ，那么由于设置了 <code>ContentInset</code> ，就会导致浮动位置偏移。</p><p>我想到的解决办法就是在回调中不断调整 <code>ContentInset</code> 来解决。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">observer = scrollView.observe(\.contentOffset, options: [.new, .initial]) </span><br><span class="line">&#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] object, change <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> strongSelf = <span class="keyword">self</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> closureScrollView = object <span class="keyword">as</span> <span class="type">UIScrollView</span></span><br><span class="line">    <span class="comment">//计算偏移位置</span></span><br><span class="line">    <span class="keyword">let</span> safeOffsetY = closureScrollView.contentOffset.y + </span><br><span class="line">        closureScrollView.safeAreaInsets.top</span><br><span class="line">    <span class="comment">//ContentInset 根据当前滚动定制</span></span><br><span class="line">    <span class="keyword">var</span> contentInsetTop = <span class="type">NSTSegmentHeight</span> + <span class="type">NSTHeaderHeight</span></span><br><span class="line">    <span class="keyword">if</span> safeOffsetY &lt; <span class="number">0</span> &#123;</span><br><span class="line">        contentInsetTop = <span class="built_in">min</span>(contentInsetTop, fabs(safeOffsetY))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        contentInsetTop = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    closureScrollView.contentInset = <span class="type">UIEdgeInsets</span>(top: </span><br><span class="line">    contentInsetTop, <span class="keyword">left</span>: <span class="number">0</span>, bottom: <span class="number">0</span>, <span class="keyword">right</span>: <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法好在保证了有且仅有一个滚动视图，所有的手势操作都是原生实现，减少了可能存在的联动问题。</p><p>但也有一个小缺陷，那就是头部内容的偏移量都是负数，这不利于三方调用和系统原始调用的实现，需要维护。</p><hr><h2 id="中央集权"><a href="#中央集权" class="headerlink" title="中央集权"></a>中央集权</h2><p>最后介绍一种比较完善的方案。外部视图采用 <code>UIScrollView</code> ，内部视图永远不可滚动，外部边滚动边调整内部的位置，保证了双方的独立性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1545731478_85.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>与第二种方法相比，切换不同功能就比较简单，只需要替换内部视图，并实现外部视图的代理，滚动时设置内部视图的偏移量就可以了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadScrollView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//获取当前数据源</span></span><br><span class="line">    <span class="keyword">let</span> contentScrollView = segmentView.selectedIndex == <span class="number">0</span> ? </span><br><span class="line">    tableSource.tableView : webSource.webView.scrollView</span><br><span class="line">    <span class="comment">//移除之前的视图</span></span><br><span class="line">    <span class="keyword">if</span> currentScrollView != <span class="literal">nil</span> &#123;</span><br><span class="line">        currentScrollView!.removeFromSuperview()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//禁止滚动后添加新视图</span></span><br><span class="line">    contentScrollView.isScrollEnabled = <span class="literal">false</span></span><br><span class="line">    scrollView.addSubview(contentScrollView)</span><br><span class="line">    <span class="comment">//保存当前视图</span></span><br><span class="line">    currentScrollView = contentScrollView</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScroll</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">    <span class="comment">//根据偏移量刷新 Segment 和内部视图的位置</span></span><br><span class="line">    <span class="keyword">self</span>.view.setNeedsLayout()</span><br><span class="line">    <span class="keyword">self</span>.view.layoutIfNeeded()</span><br><span class="line">    <span class="comment">//根据外部视图数据计算内部视图的偏移量</span></span><br><span class="line">    <span class="keyword">var</span> floatOffset = scrollView.contentOffset</span><br><span class="line">    floatOffset.y -= (<span class="type">NSTHeaderHeight</span> + <span class="type">NSTSegmentHeight</span>)</span><br><span class="line">    floatOffset.y = <span class="built_in">max</span>(floatOffset.y, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//同步内部视图的偏移</span></span><br><span class="line">    <span class="keyword">if</span> currentScrollView?.contentOffset.equalTo(floatOffset) == <span class="literal">false</span> &#123;</span><br><span class="line">        currentScrollView?.setContentOffset(floatOffset, animated: <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line">    <span class="comment">//撑满全部</span></span><br><span class="line">    scrollView.frame = view.bounds</span><br><span class="line">    <span class="comment">//头部固定</span></span><br><span class="line">    headLabel.frame = <span class="type">CGRect</span>(x: <span class="number">15</span>, y: <span class="number">0</span>, </span><br><span class="line">        width: scrollView.frame.size.width - <span class="number">30</span>, height: <span class="type">NSTHeaderHeight</span>)</span><br><span class="line">    <span class="comment">//Segment的位置是偏移和头部高度的最大值</span></span><br><span class="line">    <span class="comment">//保证滚动到头部位置时不浮动</span></span><br><span class="line">    segmentView.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, </span><br><span class="line">        y: <span class="built_in">max</span>(<span class="type">NSTHeaderHeight</span>, scrollView.contentOffset.y), </span><br><span class="line">        width: scrollView.frame.size.width, height: <span class="type">NSTSegmentHeight</span>)</span><br><span class="line">    <span class="comment">//调整内部视图的位置</span></span><br><span class="line">    <span class="keyword">if</span> currentScrollView != <span class="literal">nil</span> &#123;</span><br><span class="line">        currentScrollView?.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: segmentView.frame.maxY, </span><br><span class="line">            width: scrollView.frame.size.width, </span><br><span class="line">            height: view.bounds.size.height - <span class="type">NSTSegmentHeight</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当外部视图开始滚动时，其实一直在根据偏移量调整内部视图的位置。</p><p>外部视图的内容高度不是固定的，而是内部视图内容高度加上头部高度，所以需要观察其变化并刷新。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadScrollView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> currentScrollView != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//移除KVO</span></span><br><span class="line">        observer?.invalidate()</span><br><span class="line">        observer = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加内容尺寸的 KVO</span></span><br><span class="line">    observer = contentScrollView.observe(\.contentSize, options: [.new, .initial]) </span><br><span class="line">    &#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] object, change <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> strongSelf = <span class="keyword">self</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> closureScrollView = object <span class="keyword">as</span> <span class="type">UIScrollView</span></span><br><span class="line">        <span class="keyword">let</span> contentSizeHeight = <span class="type">NSTHeaderHeight</span> + <span class="type">NSTSegmentHeight</span> + </span><br><span class="line">            closureScrollView.contentSize.height</span><br><span class="line">        <span class="comment">//当内容尺寸改变时，刷新外部视图的总尺寸，保证滚动距离</span></span><br><span class="line">        strongSelf.scrollView.contentSize = <span class="type">CGSize</span>(width: <span class="number">0</span>, height: contentSizeHeight)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也有一个问题，由于内部滚动都是由外部来实现，没有手势的参与，因此得不到 <code>scrollViewDidEndDragging</code> 等滚动回调，如果涉及翻页之类的需求就会遇到困难。</p><p>解决办法是获取内部视图原本的代理，当外部视图代理收到回调时，转发给该代理实现功能。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadScrollView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ClosureType</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">AnyObject</span>, <span class="type">Selector</span>) -&gt; <span class="type">AnyObject</span></span><br><span class="line">    <span class="comment">//定义获取代理方法</span></span><br><span class="line">    <span class="keyword">let</span> sel = #selector(getter: <span class="type">UIScrollView</span>.delegate)</span><br><span class="line">    <span class="comment">//获取滚动视图代理的实现</span></span><br><span class="line">    <span class="keyword">let</span> imp = class_getMethodImplementation(<span class="type">UIScrollView</span>.<span class="keyword">self</span>, sel)</span><br><span class="line">    <span class="comment">//包装成闭包的形式</span></span><br><span class="line">    <span class="keyword">let</span> delegateFunc : <span class="type">ClosureType</span> = <span class="built_in">unsafeBitCast</span>(imp, to: <span class="type">ClosureType</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="comment">//获得实际的代理对象</span></span><br><span class="line">    currentScrollDelegate = delegateFunc(contentScrollView, sel) <span class="keyword">as</span>? <span class="type">UIScrollViewDelegate</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndDragging</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView, willDecelerate decelerate: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> currentScrollDelegate != <span class="literal">nil</span> &#123;</span><br><span class="line">        currentScrollDelegate!.scrollViewDidEndDragging?</span><br><span class="line">            (currentScrollView!, willDecelerate: decelerate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里我并没有使用 <code>contentScrollView.delegate</code>，这是因为 <code>UIWebScrollView</code> 重载了这个方法并返回了 <code>UIWebView</code> 的代理。但实际真正的代理是一个 <code>NSProxy</code> 对象，他负责把回调传给 <code>UIWebView</code> 和外部代理。要保证 <code>UIWebView</code> 能正常处理的话，就要让它也收到回调，所以使用 <code>Runtime</code> 执行 <code>UIScrollView</code> 原始获取代理的实现来获取。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前在生产环境中我使用的是最后一种方法，但其实这些方法互有优缺点。</p><table><thead><tr><th>方案</th><th>分而治之</th><th>各自为政</th><th>中央集权</th></tr></thead><tbody><tr><td>方式</td><td>嵌套</td><td>内嵌</td><td>嵌套</td></tr><tr><td>联动</td><td>手动</td><td>自动</td><td>手动</td></tr><tr><td>切换</td><td>数据源</td><td>整体更改</td><td>局部更改</td></tr><tr><td>优势</td><td>便于理解</td><td>滚动效果好</td><td>独立性</td></tr><tr><td>劣势</td><td>联动复杂</td><td>复杂场景苦手</td><td>模拟滚动隐患</td></tr><tr><td>评分</td><td>🌟🌟🌟</td><td>🌟🌟🌟🌟</td><td>🌟🌟🌟🌟</td></tr></tbody></table><p>技术没有对错，只有适不适合当前的需求。</p><p>分而治之适合 <code>UITableView</code> 互相嵌套的情况，通过数据源的变化能够很好实现切换功能。</p><p>各自为政适合相对简单的页面需求，如果能够避免浮动框，那使用这个方法能够实现最好的滚动效果。</p><p>中央集权适合复杂的场景，通过独立不同类型的滚动视图，使得互相最少影响，但是由于其模拟滚动的特性，需要小心处理。</p><p>希望本文能给大家带来启发，项目开源代码<a href="https://github.com/VanchChen/NestedScrollview" target="_blank" rel="noopener">在此</a>，欢迎指教与Star。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;随着产品功能不断的迭代，总会有需求希望在保证不影响其他区域功能的前提下，在某一区域实现根据选择器切换不同的内容显示。&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
      <category term="iOS" scheme="https://vanchchen.github.io/categories/iOS/"/>
    
    
      <category term="重构" scheme="https://vanchchen.github.io/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云Mac图床插件</title>
    <link href="https://vanchchen.github.io/p/648.html"/>
    <id>https://vanchchen.github.io/p/648.html</id>
    <published>2018-12-07T06:16:09.000Z</published>
    <updated>2018-12-07T06:52:08.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1544160967_34.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>随着博客越写越多，难免会遇到需要插入图片来说明的情况。</p><h3 id="图床选择"><a href="#图床选择" class="headerlink" title="图床选择"></a>图床选择</h3><p>首先调研了市面上的图床服务，本着稳定长期的目标，过滤掉了打一枪换一个地方的野鸡小网站，剩余比较靠谱的优缺点如下。</p><table><thead><tr><th>图床</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>腾讯云</td><td>免费 无需域名</td><td>未来可能会收费</td></tr><tr><td>七牛</td><td>免费</td><td>需要域名和备案</td></tr><tr><td>又拍云</td><td>免费 无需域名</td><td>未来可能会收费</td></tr><tr><td>阿里云</td><td>目前最完备</td><td>收费 需要域名</td></tr><tr><td>微博</td><td>免费 无需域名</td><td>不稳定 匿名上传</td></tr></tbody></table><p>作为一个刚起步的小博客，应该把精力更多关注于内容，以后再考虑域名备案或者大流量套餐，因此尽量选择免费的图床。 <del>其实是穷</del></p><p>微博作为国内首屈一指的流量大户，其图床的CDN和质量肯定没有问题，但是上传图片会自带水印，且匿名上传总觉得不靠谱。</p><p>剩下的选择还有两个，又拍云进军对象存储领域比腾讯云早而且更成熟，但是就规模和技术来说，我还是更愿意相信腾讯。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>注册完腾讯云账号后，下一个问题就是怎么更方便的将图床与 MarkDown 结合起来使用，提高效率和体验。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1544165437_77.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>iPic</strong> 完美符合我的需求，这是一款 <strong>Mac</strong> 上的状态栏软件，支持上传本地图片到设定的图床，获取图片地址后按照 <code>![](url)</code> 格式复制到剪贴板。</p><p><strong><em>那么好的应用为啥不用呢？</em></strong></p><p>因为不想<strong>按年交钱</strong>。应用默认是微博图床，如果要使用其他图床就需要购买专业版，每年60元。如果是一次买断的话，也就买了，年费心里总有疙瘩 <del>矫情</del>。</p><p>突然，我就想到！ 自己开发一个！ <del>闲的蛋疼</del></p><p>开发<code>iPhone</code>应用已经好多年了，还从未开发过<code>Mac</code>上的状态栏软件，正好还能锻炼下<code>Swift</code>，于是说干就干。<del>没想到开发了一个月</del></p><hr><h2 id="需求设计"><a href="#需求设计" class="headerlink" title="需求设计"></a>需求设计</h2><p>产品使用逻辑基本与 <strong>iPic</strong> 一致，基于状态栏交互，选择<code>png</code> <code>jpg</code>文件上传。</p><p>可以设置是否压缩图片，压缩会压到<code>500K</code>以下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1544165455_60.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>还需要有一个登录界面记录腾讯云的账号和存储库信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1544165470_40.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>文件上传成功后，弹出通知提醒，并复制到剪贴板。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1544165482_81.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如果不慎复制了其他文本导致丢失了链接，再点击一次通知就可以重新获取。</p><hr><h2 id="遇到的难题"><a href="#遇到的难题" class="headerlink" title="遇到的难题"></a>遇到的难题</h2><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><p>第一关就是编程语言。</p><p>虽然也曾系统的学过<code>Swift</code>，但由于常年使用<code>Objective-C</code> 开发，思维方式还转不过来。</p><h4 id="严格的空变量"><a href="#严格的空变量" class="headerlink" title="严格的空变量"></a>严格的空变量</h4><p>比较明显的区别就是处理空变量的方式。</p><p>在<code>ObjC</code>中，指针变量可以是<code>nil</code>（也就是0），对<code>nil</code>执行方法不会发生任何事情，因此可以算是部分安全。</p><p><code>Swift</code>对待空变量更严格，<code>!</code>修饰的变量必须有具体值，<code>?</code>修饰的变量才具有空值的可能性。</p><p><code>nil</code>不再表示为空对象，而是一个空值，向空值调用方法会导致闪退。对待<code>?</code>修饰的变量必须要小心，最好先判断是否有值再使用，好在有语法糖可以解决这类问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认为nil</span></span><br><span class="line"><span class="keyword">var</span> money : <span class="type">String</span>?</span><br><span class="line"><span class="comment">//变量有值</span></span><br><span class="line">money = <span class="string">"million"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断肯定有值后再使用</span></span><br><span class="line"><span class="keyword">if</span> money != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I have \(money!) dollars."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保证变量有值并赋值给安全变量后执行</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> account = money &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I have \(account) dollars."</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量如果没有值就执行else事件并return</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> account = money <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I have no money."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"I have \(account) dollars."</span>)</span><br></pre></td></tr></table></figure><p>合理使用<code>! ?</code> 会使我们的代码更安全与简洁。</p><blockquote><p>Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型。</p></blockquote><h4 id="抛出警告"><a href="#抛出警告" class="headerlink" title="抛出警告"></a>抛出警告</h4><p><code>ObjC</code> 有 <code>@throw</code> 的用法，但是根据苹果官方的描述，执行的成本很大。究其原因在于 <code>ObjC</code> 基于 <code>C</code> 语言而不是 <code>C++</code>，所以只能使用 <code>setjmp()</code>和<code>longjmp()</code> 方法实现，因此可能会造成内存泄漏。</p><blockquote><p>Important: Exceptions are resource-intensive in Objective-C. You should not use exceptions for general flow-control, or simply to signify errors (such as a file not being accessible)</p></blockquote><p><code>Swift</code> 从根本解决了这个问题，并结合枚举优化了整个流程。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompressError</span> : <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">NoImage</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">OverSize</span>(size : <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compressImage</span><span class="params">(<span class="number">_</span> imageData: Data?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> compressData = imageData <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">CompressError</span>.<span class="type">NoImage</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> compressData.<span class="built_in">count</span> &gt; maxSize &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">CompressError</span>.<span class="type">OverSize</span>(size: compressData.<span class="built_in">count</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uploadImage</span><span class="params">(<span class="number">_</span> imageData: Data?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> compressData : <span class="type">Data</span>? = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        compressData = <span class="keyword">try</span> <span class="keyword">self</span>.compressImage(imageData)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="type">CompressError</span>.<span class="type">NoImage</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Image Not Exist"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="type">CompressError</span>.<span class="type">OverSize</span>(<span class="keyword">let</span> size) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Image over size of \(size)"</span>)</span><br><span class="line">    &#125;  <span class="keyword">catch</span> <span class="number">_</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简洁的方式，忽略处理警告</span></span><br><span class="line">    <span class="keyword">let</span> compressData = <span class="keyword">try</span>? <span class="keyword">self</span>.compressImage(imageData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用<code>Swift</code>强大的枚举类型，可以定制化警告从而传递出我们需要的信息，使得整个流程更为顺畅。</p><p>语法还支持 <code>try?</code>忽略警告获取一个可能为空值的变量，如果自信绝对不会抛出异常的话，还能使用<code>try!</code>获取一个肯定值。</p><h3 id="Mac-OS-开发"><a href="#Mac-OS-开发" class="headerlink" title="Mac OS 开发"></a>Mac OS 开发</h3><p>实际编写<code>Cocoa</code>代码过程中，发现与<code>UIKit</code>相差还是比较多的。</p><h4 id="控件逻辑"><a href="#控件逻辑" class="headerlink" title="控件逻辑"></a>控件逻辑</h4><p><code>UIKit</code> 的层级一般是 <code>UINavigationController -&gt; UIViewController</code></p><p><code>Cocoa</code> 的层级则不太一样，<code>NSWindowController -&gt; NSViewController</code></p><p>原因也很简单，手机上一般只有一个窗口，依靠导航栏进行页面跳转。但是桌面端逻辑就不太一样，新页面一般都是以新窗口的形式弹出。</p><p>其次桌面端拥有特定的状态栏控件<code>NSMenu</code>，在其中操作菜单项也是一个新的挑战。</p><h4 id="腾讯云相关"><a href="#腾讯云相关" class="headerlink" title="腾讯云相关"></a>腾讯云相关</h4><p>由于腾讯云只提供了<code>iOS</code>的库，所以我还需要先把库文件重新调整为<code>Cocoa</code>代码。<br>这一部分也是吃了不少苦头，需要把设备相关的代码与应用、进出后台的通知等都去除，还要处理类似功能的转换（比如<code>UIImage -&gt; NSImage</code>）。</p><p>同时还有第二个坑，腾讯云的库都是<code>ObjC</code>代码，所以需要混编。</p><p>创建一个工作空间后拖入两个工程，在主工程的 <code>Targets / Build Phases / Embed Frameworks</code> 中加入SDK库。</p><p>接着在<code>Swift</code>工程中创建<code>Project-Bridging-Header.h</code> 头文件，在其中引用SDK库。</p><p>最后在 <code>Targets / Build Settings / Objective-C Bridging Header</code> 设置头文件，就可以解决代码混编的问题。</p><p>其原理在于自动创建了基于头文件的<code>pch</code>，把头文件中引用到的<code>ObjC</code>代码，都桥接到工程中。</p><h3 id="图片压缩算法"><a href="#图片压缩算法" class="headerlink" title="图片压缩算法"></a>图片压缩算法</h3><p>之所以不使用现成的软件还有一个原因，就是我想自己控制压缩图片的参数和效果。</p><p>通过调研和实验图片压缩效果，最终我选择压制成<code>jpg</code>格式，<code>500k</code>大小限制，压缩率限制为最小<code>0.75</code>，等比宽度限制为<code>1280px</code>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1544165504_98.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>文首那张美女图，初始是<code>1.9M 5087x3661</code>，由于尺寸过大，第一次压缩图片质量后，容量反而增加到了<code>2.4M</code>。</p><p>将宽高等比缩小到<code>1280x922</code>，图片又变大了，这次增加到了<code>4.7M</code>。（改变宽高需要新建一张画布，创建时必须要有alpha通道等其他设置，所以会变大）</p><p>我们接着压缩，最终在压缩率为<code>0.9</code>的情况下把图片压到了<code>260K</code>，成功达到了目标。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>距离上一次博客已经有两个月的间隔，其中一部分原因在于生活上的一些变故，另一个原因就在于不熟悉 <code>Cocoa + Swift</code> 开发。</p><p>好在最终还是啃出来了，<a href="https://github.com/VanchChen/Image2Url" target="_blank" rel="noopener">Github项目</a>已开源，欢迎大家指点与吐槽。</p><p>这次项目最大的收获在于脱离自己的舒适区。人的本性包含惰性，总是趋向于在熟悉的领域干熟悉的活。但是就和企业一样，不创新就死，技术不断在发展，如果没有跟上潮流，最终就会被淘汰。以此共勉！</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.swift51.com/swift4.0/" target="_blank" rel="noopener">Swift 4.0 教程</a></p><p><a href="https://www.jianshu.com/p/9b47fc25f526" target="_blank" rel="noopener">App图片压缩裁剪原理和上传方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;

      
    
    </summary>
    
      <category term="iOS" scheme="https://vanchchen.github.io/categories/iOS/"/>
    
    
      <category term="效率工具" scheme="https://vanchchen.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>刨根问底KVO原理</title>
    <link href="https://vanchchen.github.io/p/52b3.html"/>
    <id>https://vanchchen.github.io/p/52b3.html</id>
    <published>2018-10-15T09:31:00.000Z</published>
    <updated>2018-10-16T01:15:41.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>KVO( <code>NSKeyValueObserving</code> )是一种监测对象属性值变化的观察者模式机制。其特点是无需事先修改被观察者代码，利用 <code>runtime</code> 实现运行中修改某一实例达到目的，保证了未侵入性。</p><p>A对象指定观察B对象的属性后，当属性发生变更，A对象会收到通知，获取变更前以及变更的状态，从而做进一步处理。</p><p>在实际生产环境中，多用于应用层观察模型层数据变动，接收到通知后更新，从而达成比较好的设计模式。</p><p>另一种常用的用法是 <code>Debug</code>，通过观察问题属性的变化，追踪问题出现的堆栈，更有效率的解决问题。</p><hr><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="观察回调"><a href="#观察回调" class="headerlink" title="观察回调"></a>观察回调</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath </span><br><span class="line">                      ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object </span><br><span class="line">                        change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change </span><br><span class="line">                       context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure><p>观察者需要实现这个方法来接受回调，其中<code>keyPath</code> 是 <code>KVC</code> 路径， <code>object</code> 是观察者，<code>context</code> 区分不同观察的标识。</p><h4 id="改变字典"><a href="#改变字典" class="headerlink" title="改变字典"></a>改变字典</h4><p>最关键的是改变字典，其中包含了 <code>NSKeyValueChangeKey</code>，通过预定义的字符串来获取特定的数值。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> * <span class="built_in">NSKeyValueChangeKey</span> <span class="built_in">NS_STRING_ENUM</span>;</span><br><span class="line"></span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSKeyValueChangeKey</span> <span class="keyword">const</span> <span class="built_in">NSKeyValueChangeKindKey</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSKeyValueChangeKey</span> <span class="keyword">const</span> <span class="built_in">NSKeyValueChangeNewKey</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSKeyValueChangeKey</span> <span class="keyword">const</span> <span class="built_in">NSKeyValueChangeOldKey</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSKeyValueChangeKey</span> <span class="keyword">const</span> <span class="built_in">NSKeyValueChangeIndexesKey</span>;</span><br><span class="line">FOUNDATION_EXPORT <span class="built_in">NSKeyValueChangeKey</span> <span class="keyword">const</span> <span class="built_in">NSKeyValueChangeNotificationIsPriorKey</span></span><br></pre></td></tr></table></figure><p><code>NSKeyValueChangeKindKey</code> 中定义的是改变的类型，如果调用的是<code>Setter</code>方法，那就是<code>NSKeyValueChangeSetting</code>。</p><p>剩余的三种分别是插入、删除、替换，当观察的属性属于集合类（这点会在之后讲），变动时就会通知这些类型。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSKeyValueChange</span>) &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueChangeSetting</span> = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">NSKeyValueChangeInsertion</span> = <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">NSKeyValueChangeRemoval</span> = <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">NSKeyValueChangeReplacement</span> = <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>NSKeyValueChangeNewKey</code> 获取变更的最新值，<code>NSKeyValueChangeOldKey</code> 获取原始数值。</p><p><code>NSKeyValueChangeIndexesKey</code> 如果观察的是集合，那这个键值返回索引集合。</p><p><code>NSKeyValueChangeNotificationIsPriorKey</code> 如果设置了接受提前通知，那么修改之前会先发送通知，修改后再发一次。为了区分这两次，第一次会带上这个键值对，其内容为 <code>@1</code>。</p><h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><p>在注册类型时，苹果使用了<code>NS_STRING_ENUM</code>宏。</p><p>虽然这个宏在<code>ObjC</code>下毫无作用，但是对于<code>Swift</code>有优化<br>，上面的定义会变成这样。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NSKeyValueChangeKey</span>: <span class="title">String</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> kind</span><br><span class="line">    <span class="keyword">case</span> new</span><br><span class="line">    <span class="keyword">case</span> old</span><br><span class="line">    <span class="keyword">case</span> indexes </span><br><span class="line">    <span class="keyword">case</span> notificationIsPrior</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dict: [<span class="type">NSKeyValueChangeKey</span> : <span class="type">Any</span>] = [......]</span><br><span class="line"><span class="keyword">let</span> kind = dict[.kind] <span class="keyword">as</span>! <span class="type">Number</span></span><br></pre></td></tr></table></figure></p><p>字符串枚举对于使用来说是非常直观和安全的。</p><h3 id="添加与删除"><a href="#添加与删除" class="headerlink" title="添加与删除"></a>添加与删除</h3><p>对于普通对象，使用这两个方法就能注册与注销观察。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer </span><br><span class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath </span><br><span class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options </span><br><span class="line">            context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer </span><br><span class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath </span><br><span class="line">               context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure></p><p>可以设置多种观察模式来匹配需求。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSKeyValueObservingOptions</span>) &#123;</span><br><span class="line">    <span class="comment">//可以收到新改变的数值</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionNew</span> = <span class="number">0x01</span>,</span><br><span class="line">    <span class="comment">//可以收到改变前的数值</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionOld</span> = <span class="number">0x02</span>,</span><br><span class="line">    <span class="comment">//addObserver后立刻触发通知，只有new，没有old</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionInitial</span> = <span class="number">0x04</span>,</span><br><span class="line">    <span class="comment">//会在改变前与改变后发送两次通知</span></span><br><span class="line">    <span class="comment">//改变前的通知带有notificationIsPrior=@1，old</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionPrior</span> = <span class="number">0x08</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>由于不符合 <code>KVC</code> 的访问器标准，苹果规定 <code>NSArray NSOrderedSet NSSet</code> 不可以执行 <code>addObserver</code> 方法，不然会抛出异常。针对 <code>NSArray</code> 有特殊的方法，如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer </span><br><span class="line"> toObjectsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes </span><br><span class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath </span><br><span class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options </span><br><span class="line">            context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer </span><br><span class="line">  fromObjectsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes </span><br><span class="line">            forKeyPath:(<span class="built_in">NSString</span> *)keyPath </span><br><span class="line">               context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure></p><p>主要的区别在于多了一个<code>ObjectsAtIndexes</code>，其实做的事情是一样的，根据索引找到对象，再逐一建立观察关系。</p><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p><code>NSKeyValueObserving</code>  与 <code>NSKeyValueCoding</code>  一起定义在 <code>Foundation</code>  库，而这个库是不开源的，我们先从苹果开发者文档中获取信息。</p><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p></blockquote><p>看描述猜测苹果应该是通过重新设置被观察者的 <code>Class</code> (<code>isa</code> 中包含 <code>Class</code> 信息)，该类继承了原类并且重载属性的 <code>Setter</code> 方法，添加发通知的操作达到目的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ConcreteSubject</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> obj;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">ConcreteSubject *sub = [ConcreteSubject new];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, class_getName(object_getClass(sub)));</span><br><span class="line"><span class="comment">//改变前 outprint--&gt; ConcreteSubject</span></span><br><span class="line"></span><br><span class="line">[sub addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"obj"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//执行观察方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, class_getName(object_getClass(sub)));</span><br><span class="line"><span class="comment">//改变后 outprint--&gt; NSKVONotifying_ConcreteSubject</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, class_getName(object_getClass(class_getSuperclass(cls))));</span><br><span class="line"><span class="comment">//获取超类名 outprint--&gt; ConcreteSubject</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, class_getName(sub.class));</span><br><span class="line"><span class="comment">//获取类名 outprint--&gt; ConcreteSubject</span></span><br><span class="line"></span><br><span class="line">class_getMethodImplementation(cls, <span class="keyword">@selector</span>(setObj:));</span><br><span class="line"><span class="comment">//imp = (IMP)(Foundation`_NSSetObjectValueAndNotify)</span></span><br><span class="line"></span><br><span class="line">class_getMethodImplementation(cls, <span class="keyword">@selector</span>(<span class="keyword">class</span>));</span><br><span class="line"><span class="comment">//imp = (IMP)(Foundation`NSKVOClass)</span></span><br></pre></td></tr></table></figure><p>试了一下果然 <code>Class</code> 被替换了，变成加了 <code>NSKVONotifying_</code> 前缀的新类。</p><p>新类继承自原类，但是这个类的 <code>class</code> 方法返回的还是原类，这保证了外部逻辑完整。</p><h3 id="反编译源码"><a href="#反编译源码" class="headerlink" title="反编译源码"></a>反编译源码</h3><p>通过 <code>Runtime</code> ，我们只能知道 <code>KVO</code> 使用了一个继承了原类的类，并且替换了原方法的实现，<code>setObj: = _NSSetObjectValueAndNotify</code> <code>class = _NSKVOClass</code>。如果我们想进一步了解详情，只能通过反编译 <code>Foundation</code> 来查找汇编代码。</p><blockquote><p>这里我使用了 <code>Hopper</code> 工具，分析的二进制文件路径是/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/Foundation.framework/Foundation</p></blockquote><h3 id="替换的实现"><a href="#替换的实现" class="headerlink" title="替换的实现"></a>替换的实现</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码，仅供理解</span></span><br><span class="line"><span class="keyword">void</span> _NSKVOClass(<span class="keyword">id</span> <span class="keyword">self</span>,  SEL _cmd) &#123;</span><br><span class="line">    Class cls = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    Class originCls = __NSKVONotifyingOriginalClassForIsa(cls);</span><br><span class="line">    <span class="keyword">if</span> (cls != originCls) &#123;</span><br><span class="line">        <span class="keyword">return</span> [originCls <span class="keyword">class</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Method method = class_getInstanceMethod(cls, _cmd);</span><br><span class="line">        <span class="keyword">return</span> method_invoke(<span class="keyword">self</span>, method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看原 <code>class</code> 方法，获取了当前类和原类，如果不一致就返回原类，如果一致就执行原 <code>class</code> 实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码，仅供理解</span></span><br><span class="line"><span class="keyword">void</span> __NSSetObjectValueAndNotify(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="comment">//获取额外的变量</span></span><br><span class="line">    <span class="keyword">void</span> *indexedIvars = object_getIndexedIvars(object_getClass(<span class="keyword">self</span>));</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    pthread_mutex_lock(indexedIvars + <span class="number">0x20</span>);</span><br><span class="line">    <span class="comment">//从SEL获取KeyPath</span></span><br><span class="line">    <span class="built_in">NSString</span> *keyPath = [<span class="built_in">CFDictionaryGetValue</span>(*(indexedIvars) + <span class="number">0x18</span>), _cmd) copyWithZone:<span class="number">0x0</span>];</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    pthread_mutex_unlock(indexedIvars + <span class="number">0x20</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//改变前发通知</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:keyPath];</span><br><span class="line">    <span class="comment">//实现Setter方法</span></span><br><span class="line">    IMP imp = class_getMethodImplementation(*indexedIvars, _cmd);</span><br><span class="line">    (imp)(<span class="keyword">self</span>, _cmd, value);</span><br><span class="line">    <span class="comment">//改变后发通知</span></span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:keyPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看改变后的 <code>Setter</code> 方法，其中 <code>indexedIvars</code> 是原类之外的成员变量，第一个指针是改变后的类，<code>0x20</code> 的偏移量是线程锁，<code>0x18</code> 地址储存了改变过的方法字典。</p><p>在执行原方法实现前调用了 <code>willChangeValueForKey</code> 发起通知，同样在之后调用 <code>didChangeValueForKey</code>。</p><h3 id="添加观察方法"><a href="#添加观察方法" class="headerlink" title="添加观察方法"></a>添加观察方法</h3><p>那么是在哪个方法中替换的实现呢？先看 <code>[NSObject addObserver:forKeyPath:options:context:]</code> 方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码，仅供理解</span></span><br><span class="line"><span class="keyword">void</span> -[<span class="built_in">NSObject</span> addObserver:forKeyPath:options:context:]</span><br><span class="line">(<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">void</span> * arg2, <span class="keyword">void</span> * arg3, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> arg4, <span class="keyword">void</span> * arg5) &#123;</span><br><span class="line">    pthread_mutex_lock(__NSKeyValueObserverRegistrationLock);</span><br><span class="line">    *__NSKeyValueObserverRegistrationLockOwner = pthread_self();</span><br><span class="line">    rax = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    rax = _NSKeyValuePropertyForIsaAndKeyPath(rax, arg3);</span><br><span class="line">    [<span class="keyword">self</span> _addObserver:arg2 forProperty:rax options:arg4 context:arg5];</span><br><span class="line">    *__NSKeyValueObserverRegistrationLockOwner = <span class="number">0x0</span>;</span><br><span class="line">    pthread_mutex_unlock(__NSKeyValueObserverRegistrationLock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法很简单，根据 <code>KeyPath</code> 获取具体属性后进一步调用方法。由于这个方法比较长，我特地整理成 <code>ObjC</code> 代码，方便大家理解。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码，仅供理解</span></span><br><span class="line">- (<span class="keyword">void</span> *)_addObserver:(<span class="keyword">id</span>)observer </span><br><span class="line">           forProperty:(<span class="built_in">NSKeyValueProperty</span> *)property </span><br><span class="line">               options:(<span class="built_in">NSKeyValueObservingOptions</span>)option </span><br><span class="line">               context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="comment">//需要注册通知</span></span><br><span class="line">    <span class="keyword">if</span> (option &amp; <span class="built_in">NSKeyValueObservingOptionInitial</span>) &#123;</span><br><span class="line">        <span class="comment">//获取属性名路径</span></span><br><span class="line">        <span class="built_in">NSString</span> *keyPath = [property keyPath];</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(__NSKeyValueObserverRegistrationLock);</span><br><span class="line">        <span class="comment">//如果注册了获得新值，就获取数值</span></span><br><span class="line">        <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (option &amp; <span class="built_in">NSKeyValueObservingOptionNew</span>) &#123;</span><br><span class="line">            value = [<span class="keyword">self</span> valueForKeyPath:keyPath];</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">nil</span>) &#123;</span><br><span class="line">                value = [<span class="built_in">NSNull</span> null];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送注册通知</span></span><br><span class="line">        _NSKeyValueNotifyObserver(observer, keyPath, <span class="keyword">self</span>, context, value, </span><br><span class="line">        <span class="number">0</span> <span class="comment">/*originalObservable*/</span>, <span class="number">1</span> <span class="comment">/*NSKeyValueChangeSetting*/</span>);</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(__NSKeyValueObserverRegistrationLock);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//获取属性的观察信息</span></span><br><span class="line">    Info *info = __NSKeyValueRetainedObservationInfoForObject(<span class="keyword">self</span>, property-&gt;_containerClass);</span><br><span class="line">    <span class="comment">//判断是否需要获取新的数值</span></span><br><span class="line">    <span class="keyword">id</span> _additionOriginalObservable = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (option &amp; <span class="built_in">NSKeyValueObservingOptionNew</span>) &#123;</span><br><span class="line">        <span class="comment">//0x15没有找到定义，猜测为保存是否可观察的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">id</span> tsd = _CFGetTSD(<span class="number">0x15</span>);</span><br><span class="line">        <span class="keyword">if</span> (tsd != <span class="literal">nil</span>) &#123;</span><br><span class="line">            _additionOriginalObservable = *(tsd + <span class="number">0x10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在原有信息上生成新的信息</span></span><br><span class="line">    Info *newInfo = __NSKeyValueObservationInfoCreateByAdding</span><br><span class="line">    (info, observer, property, option, context, _additionOriginalObservable, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//替换属性的观察信息</span></span><br><span class="line">    __NSKeyValueReplaceObservationInfoForObject(<span class="keyword">self</span>, property-&gt;_containerClass, info, newInfo);</span><br><span class="line">    <span class="comment">//属性添加后递归添加关联属性</span></span><br><span class="line">    [property object:<span class="keyword">self</span> didAddObservance:newInfo recurse:<span class="literal">true</span>];</span><br><span class="line">    <span class="comment">//获取新的isa</span></span><br><span class="line">    Class cls = [property isaForAutonotifying];</span><br><span class="line">    <span class="keyword">if</span> ((cls != <span class="literal">NULL</span>) &amp;&amp; (object_getClass(<span class="keyword">self</span>) != cls)) &#123;</span><br><span class="line">        <span class="comment">//如果是第一次就替换isa</span></span><br><span class="line">        object_setClass(<span class="keyword">self</span>, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放观察信息</span></span><br><span class="line">    [newInfo release];</span><br><span class="line">    <span class="keyword">if</span> (info != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [info release];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有可能替换方法实现的步骤是获取 <code>isa</code> 的时候，猜测当第一次创建新类的时候，会注册新的方法，接着追踪 <code>isaForAutonotifying</code> 方法。 </p><h3 id="获取观察类"><a href="#获取观察类" class="headerlink" title="获取观察类"></a>获取观察类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * -[<span class="built_in">NSKeyValueUnnestedProperty</span> _isaForAutonotifying]</span><br><span class="line">    (<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd) &#123;</span><br><span class="line">    rbx = <span class="keyword">self</span>;</span><br><span class="line">    r14 = *_OBJC_IVAR_$_NSKeyValueProperty._containerClass;</span><br><span class="line">    <span class="keyword">if</span> ([*(rbx + r14)-&gt;_originalClass </span><br><span class="line">        automaticallyNotifiesObserversForKey:rbx-&gt;_keyPath] != <span class="number">0x0</span>) &#123;</span><br><span class="line">            r14 = __NSKeyValueContainerClassGetNotifyingInfo(*(rbx + r14));</span><br><span class="line">            <span class="keyword">if</span> (r14 != <span class="number">0x0</span>) &#123;</span><br><span class="line">                    __NSKVONotifyingEnableForInfoAndKey(r14, rbx-&gt;_keyPath);</span><br><span class="line">                    rax = *(r14 + <span class="number">0x8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    rax = <span class="number">0x0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            rax = <span class="number">0x0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>立刻发现了熟悉的方法！</p><p><code>automaticallyNotifiesObserversForKey:</code> 是一个类方法，如果你不希望某个属性被观察，那么就设为 <code>NO</code>，<code>isa</code> 返回是空也就宣告这次添加观察失败。</p><p>如果一切顺利的话，将会执行<code>__NSKVONotifyingEnableForInfoAndKey(info, keyPath)</code> 改变 <code>class</code> 的方法，最终返回其 <code>isa</code>。</p><h3 id="实质替换方法"><a href="#实质替换方法" class="headerlink" title="实质替换方法"></a>实质替换方法</h3><p>由于该方法实在太长，且使用了<code>goto</code>不方便阅读，所以依旧整理成伪代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码，仅供理解</span></span><br><span class="line"><span class="keyword">int</span> __NSKVONotifyingEnableForInfoAndKey(<span class="keyword">void</span> *info, <span class="keyword">id</span> keyPath) &#123;</span><br><span class="line">    <span class="comment">//线程锁加锁</span></span><br><span class="line">    pthread_mutex_lock(info + <span class="number">0x20</span>);</span><br><span class="line">    <span class="comment">//添加keyPath到数组</span></span><br><span class="line">    <span class="built_in">CFSetAddValue</span>(*(info + <span class="number">0x10</span>), keyPath);</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    pthread_mutex_unlock(info + <span class="number">0x20</span>);</span><br><span class="line">    <span class="comment">//判断原类实现能不能替换</span></span><br><span class="line">    Class originClass = *info;</span><br><span class="line">    MethodClass *methodClass = </span><br><span class="line">    __NSKeyValueSetterForClassAndKey(originClass, keyPath, originClass);</span><br><span class="line">    <span class="keyword">if</span> (![methodClass isKindOfClass:[<span class="built_in">NSKeyValueMethodSetter</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        swizzleMutableMethod(info, keyPath);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断Setter方法返回值</span></span><br><span class="line">    Method method = [methodClass method];</span><br><span class="line">    <span class="keyword">if</span> (*(int8_t *)method_getTypeEncoding(method) != _C_VOID) &#123;</span><br><span class="line">        _NSLog(<span class="string">@"KVO autonotifying only supports -set&lt;Key&gt;: methods that return void."</span>);</span><br><span class="line">        swizzleMutableMethod(info, keyPath);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取Setter方法参数</span></span><br><span class="line">    <span class="keyword">char</span> *typeEncoding = method_copyArgumentType(method, <span class="number">0x2</span>);</span><br><span class="line">    <span class="keyword">char</span> type = sign_extend_64(*(int8_t *)typeEncoding);</span><br><span class="line">    SEL sel;<span class="comment">//根据参数类型选择替换的方法</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> _C_BOOL: sel = __NSSetBoolValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_UCHR: sel = __NSSetUnsignedCharValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_UINT: sel = __NSSetUnsignedIntValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_ULNG: sel = __NSSetUnsignedLongValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_ULNG_LNG: sel = __NSSetUnsignedLongLongValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_CHR: sel = __NSSetCharValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_DBL: sel = __NSSetDoubleValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_FLT: sel = __NSSetFloatValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_INT: sel = __NSSetIntValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_LNG: sel = __NSSetLongValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_LNG_LNG: sel = __NSSetLongLongValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_SHT: sel = __NSSetShortValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_USHT: sel = __NSSetUnsignedShortValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_LNG_LNG: sel = __NSSetLongLongValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> _C_ID: sel = __NSSetObjectValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"&#123;CGPoint=dd&#125;"</span>: sel = __NSSetPointValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"&#123;_NSRange=QQ&#125;"</span>: sel = __NSSetRangeValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;"</span>: sel = __NSSetRectValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"&#123;CGSize=dd&#125;"</span>: sel = __NSSetSizeValueAndNotify;</span><br><span class="line">        <span class="keyword">case</span> *_NSKeyValueOldSizeObjCTypeName: sel = __CF_forwarding_prep_0;</span><br><span class="line">        <span class="keyword">default</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不支持的参数类型打印错误信息</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _NSLog(<span class="string">@"KVO autonotifying only supports -set&lt;Key&gt;: methods that take id,</span></span><br><span class="line"><span class="string">        NSNumber-supported scalar types, and some NSValue-supported structure types."</span>)</span><br><span class="line">        swizzleMutableMethod(info, keyPath);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//替换方法实现</span></span><br><span class="line">    SEL methodSel = method_getName(method);</span><br><span class="line">    _NSKVONotifyingSetMethodImplementation(info, methodSel, sel, keyPath);</span><br><span class="line">    <span class="keyword">if</span> (sel == __CF_forwarding_prep_0) &#123;</span><br><span class="line">        _NSKVONotifyingSetMethodImplementation(info, <span class="keyword">@selector</span>(forwardInvocation:), </span><br><span class="line">         _NSKVOForwardInvocation, <span class="literal">false</span>);</span><br><span class="line">        Class cls = *(info + <span class="number">0x8</span>);</span><br><span class="line">        SEL newSel = sel_registerName(<span class="string">"_original_"</span> + sel_getName(methodSel));</span><br><span class="line">        Imp imp = method_getImplementation(method);</span><br><span class="line">        TypeEncoding type = method_getTypeEncoding(method);</span><br><span class="line">        class_addMethod(cls, newSel, imp, type);</span><br><span class="line">    &#125;</span><br><span class="line">    swizzleMutableMethod(info, keyPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以表述为根据 <code>Setter</code> 方法输入参数类型，匹配合适的 <code>NSSetValueAndNotify</code> 实现来替换，从而实现效果。</p><p>那么 <code>swizzleMutableMethod</code> 是干嘛的呢？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换可变数组集合的方法</span></span><br><span class="line"><span class="keyword">int</span> swizzleMutableMethod(<span class="keyword">void</span> *info, <span class="keyword">id</span> keyPath) &#123;</span><br><span class="line">    <span class="comment">//NSKeyValueArray</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> getterSet = __NSKeyValueMutableArrayGetterForIsaAndKey(*info, keyPath);</span><br><span class="line">    <span class="keyword">if</span> ([getterSet respondsToSelector:mutatingMethods]) &#123;</span><br><span class="line">        mutatingMethods methodList = [getterSet mutatingMethods];</span><br><span class="line">        replace methodList-&gt;insertObjectAtIndex _NSKVOInsertObjectAtIndexAndNotify</span><br><span class="line">        replace methodList-&gt;insertObjectsAtIndexes _NSKVOInsertObjectsAtIndexesAndNotify</span><br><span class="line">        replace methodList-&gt;removeObjectAtIndex _NSKVORemoveObjectAtIndexAndNotify</span><br><span class="line">        replace methodList-&gt;removeObjectsAtIndexes _NSKVORemoveObjectsAtIndexesAndNotify</span><br><span class="line">        replace methodList-&gt;replaceObjectAtIndex _NSKVOReplaceObjectAtIndexAndNotify</span><br><span class="line">        replace methodList-&gt;replaceObjectsAtIndexes _NSKVOReplaceObjectsAtIndexesAndNotify</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//NSKeyValueOrderedSet</span></span><br><span class="line">    getterSet = __NSKeyValueMutableOrderedSetGetterForIsaAndKey(*info, keyPath);</span><br><span class="line">    <span class="keyword">if</span> ([getterSet respondsToSelector:mutatingMethods]) &#123;</span><br><span class="line">        mutatingMethods methodList = [getterSet mutatingMethods];</span><br><span class="line">        replace methodList-&gt;insertObjectAtIndex _NSKVOInsertObjectAtIndexAndNotify</span><br><span class="line">        replace methodList-&gt;insertObjectsAtIndexes _NSKVOInsertObjectsAtIndexesAndNotify</span><br><span class="line">        replace methodList-&gt;removeObjectAtIndex _NSKVORemoveObjectAtIndexAndNotify</span><br><span class="line">        replace methodList-&gt;removeObjectsAtIndexes _NSKVORemoveObjectsAtIndexesAndNotify</span><br><span class="line">        replace methodList-&gt;replaceObjectAtIndex _NSKVOReplaceObjectAtIndexAndNotify</span><br><span class="line">        replace methodList-&gt;replaceObjectsAtIndexes _NSKVOReplaceObjectsAtIndexesAndNotify</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//NSKeyValueSet</span></span><br><span class="line">    getterSet = __NSKeyValueMutableSetGetterForClassAndKey(*info, keyPath);</span><br><span class="line">    <span class="keyword">if</span> ([getterSet respondsToSelector:mutatingMethods]) &#123;</span><br><span class="line">        mutatingMethods methodList = [getterSet mutatingMethods];</span><br><span class="line">        replace methodList-&gt;addObject _NSKVOAddObjectAndNotify</span><br><span class="line">        replace methodList-&gt;intersectSet _NSKVOIntersectSetAndNotify</span><br><span class="line">        replace methodList-&gt;minusSet _NSKVOMinusSetAndNotify</span><br><span class="line">        replace methodList-&gt;removeObject _NSKVORemoveObjectAndNotify</span><br><span class="line">        replace methodList-&gt;unionSet _NSKVOUnionSetAndNotify</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变新类的方法缓存</span></span><br><span class="line">    __NSKeyValueInvalidateCachedMutatorsForIsaAndKey(*(info + <span class="number">0x8</span>), keyPath);</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面提到的都是一对一，那如果我想观察一对多的集合类呢？就是通过 <code>KVC</code> 中的 <code>mutableArrayValueForKey:</code> 返回一个代理集合，改变这些代理类的实现做到的。具体的例子之后会介绍。</p><h3 id="创建新类"><a href="#创建新类" class="headerlink" title="创建新类"></a>创建新类</h3><p>还有一个疑问就是替换的类是怎么创建的？具体方法在 <code>__NSKVONotifyingEnableForInfoAndKey</code> 中实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码，仅供理解</span></span><br><span class="line"><span class="keyword">int</span> __NSKVONotifyingCreateInfoWithOriginalClass(Class cls) &#123;</span><br><span class="line">    <span class="comment">//拼接新名字</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = class_getName(cls);</span><br><span class="line">    <span class="keyword">int</span> length = strlen(r12) + <span class="number">0x10</span>;<span class="comment">//16是NSKVONotifying_的长度</span></span><br><span class="line">    <span class="keyword">char</span> *newName = malloc(length);</span><br><span class="line">    __strlcpy_chk(newName, <span class="string">"NSKVONotifying_"</span>, length, <span class="number">-1</span>);</span><br><span class="line">    __strlcat_chk(newName, name, length, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//生成一个继承原类的新类</span></span><br><span class="line">    Class newCls = objc_allocateClassPair(cls, newName, <span class="number">0x68</span>);</span><br><span class="line">    free(newName);</span><br><span class="line">    <span class="keyword">if</span> (newCls != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        objc_registerClassPair(newCls);</span><br><span class="line">        <span class="comment">//获取额外的实例变量表</span></span><br><span class="line">        <span class="keyword">void</span> *indexedIvars = object_getIndexedIvars(newCls);</span><br><span class="line">        *indexedIvars = cls;            <span class="comment">//记录原isa</span></span><br><span class="line">        *(indexedIvars + <span class="number">0x8</span>) = newCls; <span class="comment">//记录新isa</span></span><br><span class="line">        <span class="comment">//新建一个集合，保存观察的keyPath</span></span><br><span class="line">        *(indexedIvars + <span class="number">0x10</span>) = <span class="built_in">CFSetCreateMutable</span>(<span class="number">0x0</span>, <span class="number">0x0</span>, _kCFCopyStringSetCallBacks);</span><br><span class="line">        <span class="comment">//新建一个字典，保存改变过的SEL</span></span><br><span class="line">        *(indexedIvars + <span class="number">0x18</span>) = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>,   </span><br><span class="line">                                _kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        <span class="comment">//新建一个线程锁</span></span><br><span class="line">        pthread_mutexattr_init(var_38);</span><br><span class="line">        pthread_mutexattr_settype(var_38, <span class="number">0x2</span>);</span><br><span class="line">        pthread_mutex_init(indexedIvars + <span class="number">0x20</span>, var_38);</span><br><span class="line">        pthread_mutexattr_destroy(var_38);</span><br><span class="line">        <span class="comment">//获取NSObject类默认的实现</span></span><br><span class="line">        <span class="keyword">if</span> (*__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectIMPLookupOnce == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">            <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">                *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectWillChange = </span><br><span class="line">                class_getMethodImplementation([<span class="built_in">NSObject</span> <span class="keyword">class</span>],</span><br><span class="line">                <span class="keyword">@selector</span>(willChangeValueForKey:));</span><br><span class="line"></span><br><span class="line">                *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectDidChange = </span><br><span class="line">                class_getMethodImplementation([<span class="built_in">NSObject</span> <span class="keyword">class</span>], </span><br><span class="line">                <span class="keyword">@selector</span>(didChangeValueForKey:));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置是否替换过ChangeValue方法的flag</span></span><br><span class="line">        <span class="built_in">BOOL</span> isChangedImp = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">if</span> (class_getMethodImplementation(cls, <span class="keyword">@selector</span>(willChangeValueForKey:)) == </span><br><span class="line">        *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectWillChange) &#123;</span><br><span class="line">            <span class="built_in">BOOL</span> isChangedDidImp = </span><br><span class="line">                class_getMethodImplementation(cls, <span class="keyword">@selector</span>(didChangeValueForKey:)) </span><br><span class="line">                != </span><br><span class="line">                *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectDidChange;</span><br><span class="line">            isChangedImp = isChangedDidImp ? <span class="literal">YES</span> : <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *(int8_t *)(indexedIvars + <span class="number">0x60</span>) = isChangedImp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用KVO的实现替换原类方法</span></span><br><span class="line">        _NSKVONotifyingSetMethodImplementation(indexedIvars, <span class="keyword">@selector</span>(_isKVOA),</span><br><span class="line">         _NSKVOIsAutonotifying, <span class="literal">false</span><span class="comment">/*是否需要保存SEL到字典*/</span>);</span><br><span class="line"></span><br><span class="line">        _NSKVONotifyingSetMethodImplementation(indexedIvars, <span class="keyword">@selector</span>(dealloc), </span><br><span class="line">         _NSKVODeallocate, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        _NSKVONotifyingSetMethodImplementation(indexedIvars, <span class="keyword">@selector</span>(<span class="keyword">class</span>), </span><br><span class="line">         _NSKVOClass, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newCls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建立关系"><a href="#建立关系" class="headerlink" title="建立关系"></a>建立关系</h3><p>还有一种情况就是观察的属性依赖于多个关系，比如 <code>color</code> 可能依赖于 <code>r g b a</code>，其中任何一个改变，都需要通知 <code>color</code> 的变化。</p><p>建立关系的方法是 </p><p><code>+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key</code></p><p>或 <code>+ (NSSet *)keyPathsForValuesAffecting&lt;key&gt;</code></p><p>返回依赖键值的字符串集合</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"keyPathsForValuesAffecting"</span> + key;</span><br><span class="line">    SEL sel = sel_registerName(str);</span><br><span class="line">    Method method = class_getClassMethod(<span class="keyword">self</span>, sel);</span><br><span class="line">    <span class="keyword">if</span> (method != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        result = method_invoke(<span class="keyword">self</span>, method);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = [<span class="keyword">self</span> _keysForValuesAffectingValueForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得之前在 <code>_addObserver</code> 方法中有这段代码吗？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属性添加后递归添加关联属性</span></span><br><span class="line">[property object:<span class="keyword">self</span> didAddObservance:newInfo recurse:<span class="literal">true</span>];</span><br></pre></td></tr></table></figure><p>其中 <code>NSKeyValueProperty</code> 也是一个类簇，具体分为 <code>NSKeyValueProperty NSKeyValueComputedProperty NSKeyValueUnnestedProperty NSKeyValueNestedProperty</code>，从名字也看出 <code>NSKeyValueNestedProperty</code> 是指嵌套子属性的属性类，那我们观察下他的实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">- (<span class="keyword">void</span>)object:(<span class="keyword">id</span>)obj didAddObservance:(<span class="keyword">id</span>)info recurse:(<span class="built_in">BOOL</span>)isRecurse &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;_isAllowedToResultInForwarding != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//获得关系键</span></span><br><span class="line">        relateObj = [obj valueForKey:<span class="keyword">self</span>-&gt;_relationshipKey];</span><br><span class="line">        <span class="comment">//注册所有关系通知</span></span><br><span class="line">        [relateObj addObserver:info </span><br><span class="line">                    forKeyPath:<span class="keyword">self</span>-&gt;_keyPathFromRelatedObject </span><br><span class="line">                       options:info-&gt;options </span><br><span class="line">                       context:<span class="literal">nil</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//再往下递归</span></span><br><span class="line">    [<span class="keyword">self</span>-&gt;_relationshipProperty object:obj didAddObservance:info recurse:isRecurse];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，实现的大致整体轮廓比较了解了，下面会讲一下怎么把原理运用到实际。</p><hr><h2 id="应用原理"><a href="#应用原理" class="headerlink" title="应用原理"></a>应用原理</h2><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>当 <code>+(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key</code> 返回是 <code>YES</code>，那么注册的这个 <code>Key</code> 就会替换对应的 <code>Setter</code> ，从而在改变的时候调用 <code>-(void)willChangeValueForKey:(NSString *)key</code> 与 <code>-(void)didChangeValueForKey:(NSString *)key</code> 发送通知给观察者。</p><p>那么只要把自动通知设为 <code>NO</code>，并代码实现这两个通知方法，就可以达到手动触发的要求。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"object"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="built_in">NSObject</span> *)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (object != _object) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"object"</span>];</span><br><span class="line">        _object = object;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"object"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果操作的是之前提到的集合对象，那么实现的方法就需要变为</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)willChange:(<span class="built_in">NSKeyValueChange</span>)changeKind </span><br><span class="line">   valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes </span><br><span class="line">            forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)didChange:(<span class="built_in">NSKeyValueChange</span>)changeKind </span><br><span class="line">  valuesAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes </span><br><span class="line">           forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key </span><br><span class="line">              withSetMutation:(<span class="built_in">NSKeyValueSetMutationKind</span>)mutationKind </span><br><span class="line">                 usingObjects:(<span class="built_in">NSSet</span> *)objects;</span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key </span><br><span class="line">             withSetMutation:(<span class="built_in">NSKeyValueSetMutationKind</span>)mutationKind </span><br><span class="line">                usingObjects:(<span class="built_in">NSSet</span> *)objects;</span><br></pre></td></tr></table></figure><h3 id="依赖键观察"><a href="#依赖键观察" class="headerlink" title="依赖键观察"></a>依赖键观察</h3><p>之前也有提过构建依赖关系的方法，具体操作如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"color"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"r"</span>,<span class="string">@"g"</span>,<span class="string">@"b"</span>,<span class="string">@"a"</span>,<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建议使用静态指针地址作为上下文区分不同的观察</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="keyword">const</span> kColorContext = (<span class="keyword">void</span>*)&amp;kColorContext;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"color"</span> </span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span> </span><br><span class="line">              context:kColorContext];</span><br><span class="line">    <span class="keyword">self</span>.r = <span class="number">133</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath </span><br><span class="line">                      ofObject:(<span class="keyword">id</span>)object </span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change </span><br><span class="line">                       context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == kColorContext) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, keyPath); </span><br><span class="line">        <span class="comment">//outprint --&gt; color</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变数组与集合"><a href="#可变数组与集合" class="headerlink" title="可变数组与集合"></a>可变数组与集合</h3><p>不可变的数组与集合由于内部结构固定，所以只能通过观察容器类内存地址来判断是否变化，也就是 <code>NSKeyValueChangeSetting</code>。</p><p>集合和数组的观察都很类似，我们先关注如果要观察可变数组内部插入移除的变化呢？</p><p>先了解一下集合代理方法，<code>- (NSMutableArray *)mutableArrayValueForKey:</code>，这是一个 <code>KVC</code> 方法，能够返回一个可供观察的 <code>NSKeyValueArray</code> 对象。</p><p>根据苹果注释，其搜索顺序如下</p><p>1.搜索是否实现最少一个插入与一个删除方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-insertObject:<span class="keyword">in</span>&lt;Key&gt;AtIndex:</span><br><span class="line">-removeObjectFrom&lt;Key&gt;AtIndex:</span><br><span class="line">-insert&lt;Key&gt;:atIndexes:</span><br><span class="line">-remove&lt;Key&gt;AtIndexes:</span><br></pre></td></tr></table></figure></p><p>2.否则搜索是否有 <code>set&lt;Key&gt;:</code> 方法，有的话每次都把修改数组重新赋值回原属性。</p><p>3.否则检查 <code>+ (BOOL)accessInstanceVariablesDirectly</code>，如果是<code>YES</code>，就查找成员变量<code>_&lt;key&gt; or &lt;key&gt;</code>，此后所有的操作针对代理都转接给成员变量执行。</p><p>4.最后进入保护方法<code>valueForUndefinedKey:</code></p><h4 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)insertObject:(<span class="built_in">NSObject</span> *)object inDataArrayAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    [_dataArray insertObject:object atIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectFromDataArrayAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    [_dataArray removeObjectAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    _dataArray = @[].mutableCopy;</span><br><span class="line">    [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"dataArray"</span> </span><br><span class="line">    options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> |  </span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionPrior</span> context:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span> insertObject:@<span class="number">1</span> inDataArrayAtIndex:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现了<code>insert</code>与<code>remove</code>方法，使得代理数组能够正常运作数组变量，<code>KVO</code> 观察了代理数组的这两个方法，发出了我们需要的通知。</p><p>这种方式使用了第一步搜索，比较容易理解，缺点是改动的代码比较多，改动数组必须通过自定义方法。</p><h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSMutableArray</span> *dataArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> dataArray = _dataArray;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableArray</span> *)dataArray &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> mutableArrayValueForKey:<span class="string">@"dataArray"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    _dataArray = @[].mutableCopy;</span><br><span class="line">    [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"dataArray"</span> </span><br><span class="line">    options:<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span> |   </span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionPrior</span> context:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span>.dataArray addObject:@<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式相对来说更简洁，修改数组的方法与平时一致，比较适合使用。</p><p>下面说一下原理，首先我们没有实现对应的<code>insert</code>与<code>remove</code>方法，其次<code>readonly</code>属性也没有<code>set&lt;key&gt;:</code>方法，但我们实现了 <code>@synthesize dataArray = _dataArray;</code> 所以根据第三步对代理数组的操作都会实际操作到实例变量中。</p><p>然后重载了 <code>dataArray</code> 的 <code>Getter</code> 方法，保证了修改数组时必须调用主体是<code>self.dataArray</code>，也就是代理数组，从而发送通知。</p><hr><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><h3 id="KVO的底层实现？"><a href="#KVO的底层实现？" class="headerlink" title="KVO的底层实现？"></a>KVO的底层实现？</h3><p><code>KVO</code> 就是通过 <code>Runtime</code> 替换被观察类的 <code>Setter</code> 实现，从而在发生改变时发起通知。</p><h3 id="如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？"><a href="#如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？" class="headerlink" title="如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？"></a>如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？</h3><p>通过设置 <code>automaticallyNotifiesObserversForKey</code> 为 <code>False</code> 实现取消自动触发。</p><p>符合条件再触发可以这么实现。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="built_in">NSObject</span> *)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (object == _object) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> needNotify = [object isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]];</span><br><span class="line">    <span class="keyword">if</span> (needNotify) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"object"</span>];    </span><br><span class="line">    &#125;</span><br><span class="line">    _object = object;</span><br><span class="line">    <span class="keyword">if</span> (needNotify) &#123;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"object"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于对汇编语言、反编译工具、<code>objc4</code>开源代码的不熟悉，这篇文章写了一周时间，结构也有点混乱。</p><p>所幸还是理顺了整体结构，在整理的过程中学会了很多很多。</p><p>由于才疏学浅，其中对汇编和源码的解释难免出错，还望大佬多多指教！</p><hr><h2 id="资料分享"><a href="#资料分享" class="headerlink" title="资料分享"></a>资料分享</h2><p>ObjC中国的期刊 <a href="https://objccn.io/issue-7-3/" target="_blank" rel="noopener">KVC和KVO</a></p><p>杨大牛的 <a href="http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/" target="_blank" rel="noopener">Objective-C中的KVC和KVO</a></p><p><a href="https://www.jianshu.com/p/45cbd324ea65" target="_blank" rel="noopener">iOS开发技巧系列—详解KVC(我告诉你KVC的一切)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;KVO( &lt;code&gt;NSKeyValueObserving&lt;/code&gt; )是一种监测对象属性值变化的观察者模式机制。其特点是无需事先修改
      
    
    </summary>
    
      <category term="iOS" scheme="https://vanchchen.github.io/categories/iOS/"/>
    
    
      <category term="原理分析" scheme="https://vanchchen.github.io/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>脚本处理iOS的Crash日志</title>
    <link href="https://vanchchen.github.io/p/2616.html"/>
    <id>https://vanchchen.github.io/p/2616.html</id>
    <published>2018-10-08T08:06:38.000Z</published>
    <updated>2018-12-07T06:16:41.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当我们打包app时，可以选择生成对应的符号表，其保存 16 进制函数地址映射信息，通过给定的函数起始地址和偏移量，可以对应函数具体信息以供分析。</p><p>所以我们拿到测试给的闪退日志(<code>.crash</code>)时，需要找到打包时对应生成的符号表(<code>.dSYM</code>)作为钥匙解析。具体分为下面几个步骤</p><ol><li><code>dwarfdump --uuid</code> 命令获取 <code>.dSYM</code> 的 <code>uuid</code></li><li>打开 <code>.crash</code> 文件，在特定位置找到 <code>uuid</code></li><li>根据 <code>arm</code> 版本比对两者是否一致</li><li><p>到 <code>Xcode</code> 目录下寻找 <code>symbolicatecrash</code> 工具</p><blockquote><p>不同版本文件路径不同，具体版本请谷歌。Xcode9路径是/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/</p></blockquote></li><li><p>设置终端环境变量</p><p> <code>export DEVELOPER_DIR=&quot;/Applications/Xcode.app/Contents/Developer&quot;</code></p></li><li>使用 <code>symbolicatecrash</code> 工具解析日志<br> <code>symbolicatecrash .crash .dsym &gt; a.out</code></li></ol><p>虽然过程不复杂，但是每次都需要手动执行一次检查与命令，过于繁琐，所以决定用脚本化提高效率。</p><hr><h2 id="步骤实现"><a href="#步骤实现" class="headerlink" title="步骤实现"></a>步骤实现</h2><h3 id="输入Crash日志"><a href="#输入Crash日志" class="headerlink" title="输入Crash日志"></a>输入Crash日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>要求输入crash文件路径</span><br><span class="line">inputFile 'Please Input Crash File' 'crash'</span><br><span class="line">crashPath=$filePath</span><br></pre></td></tr></table></figure><p>由于需要输入两种不同后缀的文件路径，且都需要检查，因此统一定义一个方法。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>定义全局变量</span><br><span class="line">filePath=</span><br><span class="line"><span class="meta">#</span>输入文件路径</span><br><span class="line">inputFile() &#123;</span><br><span class="line">    readSuccess=false</span><br><span class="line">    #首先清空变量值</span><br><span class="line">    filePath=</span><br><span class="line">    while [ $readSuccess = false ]; do </span><br><span class="line">        echo $1</span><br><span class="line">        #读取到变量中</span><br><span class="line">        read -a filePath</span><br><span class="line">        if [[ ! -e $filePath || $&#123;filePath##*.&#125; != $2 ]]; then</span><br><span class="line">            echo "Input file is not ."$2</span><br><span class="line">        else</span><br><span class="line">            readSuccess=true</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>.dSYM</code> 是文件夹路径，所以这里简单的判断了路径是否存在，如果不存在就继续让用户输入。</p><blockquote><p>Shell命令中判断分为[]与[[]]，后者比前者更通用，可以使用 || 正则运算等。</p><p>判断中，-f表示检查是否存在该文件，-d表示检查是否存在文件夹，-e表示检查是否存在该路径</p></blockquote><h3 id="输入dSYM符号表"><a href="#输入dSYM符号表" class="headerlink" title="输入dSYM符号表"></a>输入dSYM符号表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dsymSuccess=false</span><br><span class="line">while [ $dsymSuccess = false ]; do</span><br><span class="line">    #要求输入dSYM文件路径</span><br><span class="line">    inputFile 'Please Input dSYM File' 'dSYM'</span><br><span class="line">    dsymPath=$filePath</span><br><span class="line">    #检查是否匹配</span><br><span class="line">    checkUUID "$crashPath" "$dsymPath"</span><br><span class="line">    match=$?</span><br><span class="line">    if [ $match -eq 0 ]; then</span><br><span class="line">        echo 'UUID not match!'</span><br><span class="line">    else</span><br><span class="line">        dsymSuccess=true</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>循环获取匹配 <code>UUID</code> 的 <code>dSYM</code> ，这里使用了另一种方法获取方法返回值，具体之后章节会总结。</p><h3 id="查找symbolicatecrash工具"><a href="#查找symbolicatecrash工具" class="headerlink" title="查找symbolicatecrash工具"></a>查找symbolicatecrash工具</h3><p>在 <code>Xcode</code> 文件夹指定路径下查找工具，加快效率，如果没找到就停止运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查找symbolicatecrash解析工具，内置在Xcode的库文件中</span><br><span class="line">toolPath=`find /Applications/Xcode.app/Contents/SharedFrameworks -name symbolicatecrash | head -n 1`</span><br><span class="line">if [ ! -f $toolPath ]; then</span><br><span class="line">    echo "Symbolicatecrash not exist!"</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="执行解析命令"><a href="#执行解析命令" class="headerlink" title="执行解析命令"></a>执行解析命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>先设置环境变量</span><br><span class="line">export DEVELOPER_DIR="/Applications/Xcode.app/Contents/Developer"</span><br><span class="line"><span class="meta">#</span>指定解析结果路径</span><br><span class="line">crashName=`basename $crashPath`</span><br><span class="line">afterPath="$(dirname "$crashPath")"/"$&#123;crashName%%.*&#125;""_after.crash"</span><br><span class="line"><span class="meta">#</span>开始解析</span><br><span class="line"><span class="meta">$</span>toolPath "$crashPath" "$dsymPath" &gt; "$afterPath" 2&gt; /dev/null</span><br></pre></td></tr></table></figure><p>这里我将错误信息导流到 <code>/dev/null</code>，保证解析文件没有杂乱信息。</p><hr><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="怎么获取函数返回值？"><a href="#怎么获取函数返回值？" class="headerlink" title="怎么获取函数返回值？"></a>怎么获取函数返回值？</h3><p>之前没有处理过需要返回数值的方法，所以一开始有点懵，查询资料后最终采用了两种方式实现了效果，现在做一些总结。</p><h4 id="全局变量记录"><a href="#全局变量记录" class="headerlink" title="全局变量记录"></a>全局变量记录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>定义全局变量</span><br><span class="line">filePath=</span><br><span class="line">inputFile() &#123;</span><br><span class="line">    #读取到变量中</span><br><span class="line">    read -a filePath</span><br><span class="line">&#125;</span><br><span class="line">inputFile</span><br><span class="line">crashPath=$filePath</span><br></pre></td></tr></table></figure><p>通过 <code>inputFile</code> 方法来了解一下，首先定义一个全局变量为 <code>filePath</code>，在方法中重新赋值，方法结束后读取全局变量中的数据。</p><p>这种方法的好处是可以自定义返回参数类型和个数，缺点是容易和其他变量搞混。</p><h4 id="Return返回值"><a href="#Return返回值" class="headerlink" title="Return返回值"></a>Return返回值</h4><p>类似与C语言中的用法，脚本也支持 <code>retrun 0</code> 返回结果并停止运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkUUID() &#123;</span><br><span class="line">    grep "$arm64id" "$1"</span><br><span class="line">    if [ $? -ne 0 ]; then</span><br><span class="line">        return 1;</span><br><span class="line">    fi</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">checkUUID "$crashPath" "$dsymPath"</span><br><span class="line">match=$?</span><br></pre></td></tr></table></figure><p>获取结果的方式为 <code>$?</code>，其能够返回环境中最后一个指令结果，也就是之前执行的<code>checkUUID</code>的结果。</p><p>优点是简洁明了，符合编码习惯，缺点是返回值只能是 <code>0-255</code> 的数字，不能返回其他类型的数据。</p><h4 id="获取打印值"><a href="#获取打印值" class="headerlink" title="获取打印值"></a>获取打印值</h4><p>还有一种方法其实平时一直在使用，只不过并不了解其运行方式。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crashName=`basename $crashPath`</span><br><span class="line"></span><br><span class="line">print() &#123;</span><br><span class="line">    echo "Hello World"</span><br><span class="line">&#125;</span><br><span class="line">text=$(print)</span><br></pre></td></tr></table></figure></p><p>运行系统预设的方法或者自定义方法，将执行命令用 <code>$()</code> 的方式使用，就可以获取该命令中所有打印的信息，赋值到变量就可以拿到需要的返回值。</p><p>优点是功能全效率高，使用字符串的方式可以传递定制化信息，缺点是不可预期返回结果，需要通过字符串查找等命令辅助。</p><h3 id="循环输入合法路径"><a href="#循环输入合法路径" class="headerlink" title="循环输入合法路径"></a>循环输入合法路径</h3><p>在我的设想中，需要用户输入匹配的 <code>dSYM</code> 文件路径，如果不匹配，则重新输入，直到合法。为了支持嵌套，需要定义局部变量控制循环，具体代码如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dsymSuccess=false</span><br><span class="line">while [ $dsymSuccess = false ]; do</span><br><span class="line">    #要求输入dSYM文件路径</span><br><span class="line">    inputFile 'Please Input dSYM File' 'dSYM'</span><br><span class="line">    dsymPath=$filePath</span><br><span class="line">    #检查是否匹配</span><br><span class="line">    checkUUID "$crashPath" "$dsymPath"</span><br><span class="line">    match=$?</span><br><span class="line">    if [ $match -eq 0 ]; then</span><br><span class="line">        echo 'UUID not match!'</span><br><span class="line">    else</span><br><span class="line">        dsymSuccess=true</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h3 id="处理字符串"><a href="#处理字符串" class="headerlink" title="处理字符串"></a>处理字符串</h3><p>获取到 <code>UUID</code> 所有输出信息后，需要截取出对应平台的信息，处理还是不太熟悉，特地整理如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>原始信息</span><br><span class="line">UUID: 92E495AA-C2D4-3E9F-A759-A50AAEF446CD (armv7) /Volumes/.dSYM/Contents/Resources/DWARF/app</span><br><span class="line">UUID: 536527A8-0243-34DB-AE08-F1F64ACA4351 (arm64) /Volumes/.dSYM/Contents/Resources/DWARF/app</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>去除中间间隔-</span><br><span class="line">uuid=$&#123;uuid//-/&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>从后往前找第一个匹配 \(arm64的，并且都删除</span><br><span class="line">arm64id=$&#123;uuid% \(arm64*&#125;</span><br><span class="line"><span class="meta">#</span>处理后</span><br><span class="line">UUID: 92E495AAC2D43E9FA759A50AAEF446CD (armv7) /Volumes/.dSYM/Contents/Resources/DWARF/app</span><br><span class="line">UUID: 536527A8024334DBAE08F1F64ACA4351</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>从前往后找最后一个UUID: ，并删除</span><br><span class="line">arm64id=$&#123;arm64id##*UUID: &#125;</span><br><span class="line"><span class="meta">#</span>处理后 </span><br><span class="line">536527A8024334DBAE08F1F64ACA4351</span><br></pre></td></tr></table></figure></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看似简单的脚本，也花了一天时间编写，总体还是不太熟练，仍需努力联系。</p><p>这次特地尝试了与上次不同的参数输入方法，使用提示输入的方式，果然遇到了新的问题。好在都查资料解决了，结果还算满意。</p><p>脚本我提交到了<a href="https://github.com/VanchChen/AnalysisCrash" target="_blank" rel="noopener">Github</a>，欢迎大家指教共同进步！给个关注最好啦～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;当我们打包app时，可以选择生成对应的符号表，其保存 16 进制函数地址映射信息，通过给定的函数起始地址和偏移量，可以对应函数具体信息以供分
      
    
    </summary>
    
      <category term="Shell" scheme="https://vanchchen.github.io/categories/Shell/"/>
    
    
      <category term="效率工具" scheme="https://vanchchen.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>AssociatedObject关联对象原理实现</title>
    <link href="https://vanchchen.github.io/p/f39e.html"/>
    <id>https://vanchchen.github.io/p/f39e.html</id>
    <published>2018-09-29T09:55:21.000Z</published>
    <updated>2018-10-16T01:15:41.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>关联对象（AssociatedObject）是Objective-C 2.0运行时的一个特性，允许开发者对已经存在的类在扩展中添加自定义的属性。在实际生产过程中，比较常用的方式是给分类（Category）添加成员变量。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> property;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"><span class="keyword">@dynamic</span> property;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)property &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setProperty:(<span class="built_in">NSString</span> *)property &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(property), property, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>通过实现代码可以稍微分析下，<code>objc_getAssociatedObject</code> 拿着不变的指针地址（示例传入selector作为参数，实际是void*），从实例中获取需要的对象。<code>objc_setAssociatedObject</code> 根据传入的参数协议，保存指定的对象。</p><h3 id="参数协议"><a href="#参数协议" class="headerlink" title="参数协议"></a>参数协议</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object. The association is made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied. The association is made atomically. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实这五个协议就是我们平时定义属性时使用的，需要注意的是，虽然苹果在注释中说 <code>OBJC_ASSOCIATION_ASSIGN</code> 相当于一个 <code>weak reference</code>，但其实等于 <code>assign/unsafe_unretained</code>。</p><p>对于与<code>weak</code>的区别不在本文讨论范围内，浅显的区别在于变量释放后，<code>weak</code> 会把引用置空，<code>unsafe_unretained</code>会保留内存地址，一旦获取可能会野指针闪退。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们知道，如果类要添加变量，只有在<code>objc_allocateClassPair</code>与<code>objc_registerClassPair</code>之间<code>addIvar</code>。等类注册后，变量结构就不允许再被改变，这是为了防止两个相同类的实例拥有不同变量导致运行困惑。</p><p>那么在runtime时给实例添加变量，又不改变类内部变量结构，关联对象就是一个比较好的做法。</p><hr><h2 id="关联对象的实现"><a href="#关联对象的实现" class="headerlink" title="关联对象的实现"></a>关联对象的实现</h2><h3 id="外部方法"><a href="#外部方法" class="headerlink" title="外部方法"></a>外部方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sets an associated value for a given object using a given key and association policy.</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> * key, <span class="keyword">id</span> value, objc_AssociationPolicy policy);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Returns the value associated with a given object for a given key.</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> * key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Removes all associations for a given object.</span></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object);</span><br></pre></td></tr></table></figure><p>相比刚刚例子中的用法，多了一个<code>objc_removeAssociatedObjects</code>，那么可不可以用这个方法来删除不用的关联对象呢？</p><p>苹果的文档中解释说这个方法主要用来还原对象到类初始的状态，会移除所有的关联，包括其他模块添加的，因此应该用 <code>objc_setAssociatedObject(..,nil,..)</code> 的方式去卸载。</p><hr><h3 id="Setter实现"><a href="#Setter实现" class="headerlink" title="Setter实现"></a>Setter实现</h3><p><code>objc_setAssociatedObject</code>实际调用的是<code>_object_set_associative_reference</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</span><br><span class="line">    <span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> acquireValue(<span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (policy &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">        <span class="keyword">return</span> objc_retain(value);</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(value, SEL_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> releaseValue(<span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123;</span><br><span class="line">        <span class="keyword">return</span> objc_release(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</span><br><span class="line"><span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">    old_association = ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br></pre></td></tr></table></figure><p>我们摘出与对象内存相关的代码仔细分析下，首先把新传入的对象，根据协议进行<code>retain/copy</code>，在赋值的过程中获取旧值，在方法结束前<code>release</code>。</p><hr><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">AssociationsManager manager;</span><br><span class="line">AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line"><span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">    <span class="comment">//需要赋值</span></span><br><span class="line">    AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">    <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">        <span class="comment">//找到了这个对象的关联表</span></span><br><span class="line">        ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">        ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">        <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">            <span class="comment">//找到了这个key的关联对象</span></span><br><span class="line">            old_association = j-&gt;second;</span><br><span class="line">            j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没找到，新增一个关联</span></span><br><span class="line">            (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没找到，创建一个新的关联表</span></span><br><span class="line">        ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">        associations[disguised_object] = refs;</span><br><span class="line">        (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">        object-&gt;setHasAssociatedObjects();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先了解一下<code>AssociationsManager</code>与<code>AssociationsHashMap</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AssociationsManager &#123;</span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;</span><br><span class="line">public:</span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_map == <span class="literal">NULL</span>)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        <span class="keyword">return</span> *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ObjectAssociationMap : public std::map&lt;<span class="keyword">void</span> *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt;；</span><br></pre></td></tr></table></figure></p><p><code>AssociationsManager</code>通过一个以指针地址为主键，值为关联表的哈希表，来管理应用内所有的关联对象。</p><p>首先以对象的指针地址去寻找关联表，再通过指定的键值查找关联关系，从而获取关联对象。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line"><span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">    ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">    ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">    <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">        old_association = j-&gt;second;</span><br><span class="line">        refs-&gt;erase(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和修改方法类似，找到关联关系后，执行哈希表的<code>erase</code>方法删除。</p><hr><h3 id="Getter实现"><a href="#Getter实现" class="headerlink" title="Getter实现"></a>Getter实现</h3><p><code>objc_getAssociatedObject</code>实际调用的是<code>_object_get_associative_reference</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    <span class="keyword">uintptr_t</span> policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value();</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</span><br><span class="line">                    objc_retain(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        objc_autorelease(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找哈希表的方法和Setter一样，区别在于如果策略中需要retain和autorelease的话，都需要处理。那么是怎么约定这些策略呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; </span><br><span class="line">    OBJC_ASSOCIATION_SETTER_ASSIGN      = <span class="number">0</span>,</span><br><span class="line">    OBJC_ASSOCIATION_SETTER_RETAIN      = <span class="number">1</span>,</span><br><span class="line">    OBJC_ASSOCIATION_SETTER_COPY        = <span class="number">3</span>,            <span class="comment">// <span class="doctag">NOTE:</span>  both bits are set, so we can simply test 1 bit in releaseValue below.</span></span><br><span class="line">    OBJC_ASSOCIATION_GETTER_READ        = (<span class="number">0</span> &lt;&lt; <span class="number">8</span>), </span><br><span class="line">    OBJC_ASSOCIATION_GETTER_RETAIN      = (<span class="number">1</span> &lt;&lt; <span class="number">8</span>), </span><br><span class="line">    OBJC_ASSOCIATION_GETTER_AUTORELEASE = (<span class="number">2</span> &lt;&lt; <span class="number">8</span>)</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">OBJC_ENUM</span><span class="params">(<span class="keyword">uintptr_t</span>, objc_AssociationPolicy)</span> </span>&#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>, </span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>OBJC_ASSOCIATION_RETAIN = 01401</code>，其中<code>01401</code>开头是<code>0</code>，所以是八进制数字，翻译为二进制就是<code>0000 0011 0000 0001</code>，取位判断就是<code>OBJC_ASSOCIATION_SETTER_RETAIN</code> <code>OBJC_ASSOCIATION_GETTER_RETAIN</code> <code>OBJC_ASSOCIATION_GETTER_AUTORELEASE</code>。</p><p>在保存的时候，需要<code>retain</code>，在获取的时候，需要先<code>retain</code>增加引用计数，再执行<code>autorelease</code>等待释放，从而实现原子性。</p><h3 id="Remove实现"><a href="#Remove实现" class="headerlink" title="Remove实现"></a>Remove实现</h3><p><code>objc_removeAssociatedObjects</code>会判断对象是否存在关联，然后再执行<code>_object_set_associative_reference</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_remove_assocations(id object) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            <span class="keyword">delete</span> refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现方式也可以看出为什么在介绍里不推荐使用，因为会遍历所有的关联对象，并且全部释放，可能会造成别的模块功能缺陷。</p><h4 id="判断关联对象"><a href="#判断关联对象" class="headerlink" title="判断关联对象"></a>判断关联对象</h4><p>比较有意思的是判断对象是否有关联对象的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> objc_object::hasAssociatedObjects()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (isa.nonpointer) <span class="keyword">return</span> isa.has_assoc;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> objc_object::setHasAssociatedObjects()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">isa_t</span> oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    <span class="keyword">isa_t</span> newisa = oldisa;</span><br><span class="line">    <span class="keyword">if</span> (!newisa.nonpointer  ||  newisa.has_assoc) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newisa.has_assoc = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认返回的结果都是<code>true</code>，只有在64位系统下，才保存一个标记位。这么处理我推测是为了加快释放周期速度，在析构对象时，会根据这个方法判断是否需要释放关联对象。试想如果每次都查询哈希表，执行效率必定会降低，不如都先通过，之后再做处理。</p><blockquote><p>关于<code>nonpointer</code>不在本文介绍范围内，简单描述为在64位系统下，指针地址保存不仅仅为内存地址，还存有其他标记信息，包括本文涉及的has_assoc。</p><p><code>taggedPointer</code>是一种优化策略，把简单的数字或字符串信息直接保存在指针地址中，从而不申请额外内存加快运行效率。</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>关联对象的实现不复杂，保存的方式为一个全局的哈希表，存取都通过查询表找到关联来执行。哈希表的特点就是牺牲空间换取时间，所以执行速度也可以保证。</p><hr><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><h3 id="关联对象有什么应用？"><a href="#关联对象有什么应用？" class="headerlink" title="关联对象有什么应用？"></a>关联对象有什么应用？</h3><p>关联对象可以在运行时给指定对象绑定一个有生命周期的变量。</p><p>1.由于不改变原类的实现，所以可以给原生类或者是打包的库进行扩展，一般配合Category实现完整的功能。</p><p>2.ObjC类定义的变量，由于runtime的特性，都会暴露到外部，使用关联对象可以隐藏关键变量，保证安全。</p><p>3.可以用于KVO，使用关联对象作为观察者，可以避免观察自身导致循环。</p><h3 id="系统如何管理关联对象？"><a href="#系统如何管理关联对象？" class="headerlink" title="系统如何管理关联对象？"></a>系统如何管理关联对象？</h3><p>系统通过管理一个全局哈希表，通过对象指针地址和传递的固定参数地址来获取关联对象。根据<code>setter</code>传入的参数协议，来管理对象的生命周期。</p><h3 id="其被释放的时候需要手动将其指针置空么？"><a href="#其被释放的时候需要手动将其指针置空么？" class="headerlink" title="其被释放的时候需要手动将其指针置空么？"></a>其被释放的时候需要手动将其指针置空么？</h3><p>当对象被释放时，如果设置的协议是<code>OBJC_ASSOCIATION_ASSIGN</code>，那么他的关联对象不会减少引用计数，其他的协议都会减少从而释放关联对象。</p><p><code>unsafe_unretain</code>一般认为外部有对象控制，所以对象不用处理，因此不管什么协议，对象释放时都无需手动讲关联对象置空。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;关联对象（AssociatedObject）是Objective-C 2.0运行时的一个特性，允许开发者对已经存在的类在扩展中添加自定义的属
      
    
    </summary>
    
      <category term="iOS" scheme="https://vanchchen.github.io/categories/iOS/"/>
    
    
      <category term="原理分析" scheme="https://vanchchen.github.io/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>初试Shell脚本</title>
    <link href="https://vanchchen.github.io/p/3f22.html"/>
    <id>https://vanchchen.github.io/p/3f22.html</id>
    <published>2018-09-20T08:45:12.000Z</published>
    <updated>2018-12-07T06:16:35.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>临上线前测试比较努力，遇到闪退或者其他问题，会把日志包打给我，由于app内存限制，目前每次打包都是1m大小，所以有时查找问题的上下文比较吃力。同时由于日志比较多，根据关键词过滤的需求越来越重要。</p><p>于是决定学写脚本完成这个任务，根据我的要求，工作流程应该是传入压缩包，根据后缀名解压，根据日期排序后合并成一个文件，按需过滤关键词。</p><hr><h2 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/usr/bin/env bash</span><br><span class="line"><span class="meta">#</span> Created By Vanch at 2018/9/20</span><br><span class="line"></span><br><span class="line">printHelp() &#123;</span><br><span class="line">    echo "Uncompess log files from inputed zip"</span><br><span class="line">    echo "Then Merge these logs to one file"</span><br><span class="line">    echo "Supported file types: zip tar tar.gz tar.bz2"</span><br><span class="line">    echo</span><br><span class="line">    echo "Use -s for filtering socket result to socket.log"</span><br><span class="line">    echo </span><br><span class="line">    echo "Have fun!"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>如果没输入参数，就打印帮助信息</span><br><span class="line">if [ $# -eq 0 ]; then</span><br><span class="line">    printHelp</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>把长选项转到短选项</span><br><span class="line">for arg in "$@"; do</span><br><span class="line">  shift</span><br><span class="line">  case "$arg" in</span><br><span class="line">    "--help")       set -- "$@" "-h" ;;</span><br><span class="line">    "--version")    set -- "$@" "-v" ;;</span><br><span class="line">    "--list")       set -- "$@" "-l" ;;</span><br><span class="line">    *)              set -- "$@" "$arg"</span><br><span class="line">  esac</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span>获取短选项</span><br><span class="line">OPTIND=1</span><br><span class="line">printS=false;</span><br><span class="line">while getopts "dmksahvl" opt; do</span><br><span class="line">    case $opt in</span><br><span class="line">        h) #输入为help，就打印帮助信息</span><br><span class="line">            printHelp</span><br><span class="line">            exit 0;;</span><br><span class="line">        l) #支持单独获取支持文件后缀列表</span><br><span class="line">            echo "Supported file types: zip tar tar.gz tar.bz2"</span><br><span class="line">            exit 0;;</span><br><span class="line">        v) #支持查找版本号</span><br><span class="line">            echo "1.0.0"</span><br><span class="line">            exit 0;;</span><br><span class="line">        s) #过滤Socket</span><br><span class="line">            printS=true;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>获得压缩包地址</span><br><span class="line">file=$&#123;!#&#125;</span><br><span class="line"><span class="meta">#</span>如果不存在就退出</span><br><span class="line">if [ ! -f "$file" ]; then</span><br><span class="line">    echo "File not exist!"</span><br><span class="line">    exit 0;</span><br><span class="line">fi </span><br><span class="line"><span class="meta">#</span>获取压缩后缀</span><br><span class="line">fileName=`basename $file`</span><br><span class="line">suffix=$&#123;fileName#*.&#125;</span><br><span class="line"><span class="meta">#</span>判断文件类型</span><br><span class="line">support=('tar','tar.gz','tar.bz2','zip')</span><br><span class="line">if [ -z `echo "$&#123;support[@]&#125;" | grep -w "$suffix"` ] ; then</span><br><span class="line">    echo "File type not support!"</span><br><span class="line">    exit 0;    </span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span>拼接文件夹地址</span><br><span class="line">fileDir=$(dirname $file)/$&#123;fileName%%.*&#125;</span><br><span class="line">if [ -d $fileDir ]; then</span><br><span class="line">    rm -rf $fileDir</span><br><span class="line">fi</span><br><span class="line">mkdir $fileDir</span><br><span class="line">cd $fileDir</span><br><span class="line"><span class="meta">#</span>解压文件</span><br><span class="line">case $suffix in</span><br><span class="line">    'tar')</span><br><span class="line">        eval "tar xvf $file &gt; /dev/null 2&gt;&amp;1";;</span><br><span class="line">    'tar.gz')</span><br><span class="line">        eval "tar zxvf $file &gt; /dev/null 2&gt;&amp;1";;</span><br><span class="line">    'tar.bz2')</span><br><span class="line">        eval "tar jxvf $file &gt; /dev/null 2&gt;&amp;1";;</span><br><span class="line">    'zip')</span><br><span class="line">        eval "unzip -o $file &gt; /dev/null 2&gt;&amp;1";;</span><br><span class="line">esac</span><br><span class="line">echo 'Uncompass Success!'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>获取日志列表，按排序合并到一个日志</span><br><span class="line">mergeFile=./merge.log</span><br><span class="line">logCount=0</span><br><span class="line"><span class="meta">#</span>搜索com开头的日志，按日期排序，用？临时代替空格</span><br><span class="line">for logName in `ls | grep 'com' | sort -n | tr " " "?"`; do</span><br><span class="line">    logName=$&#123;logName//'?'/' '&#125;</span><br><span class="line">    cat ./"$logName" &gt;&gt; $mergeFile</span><br><span class="line">    ((logCount++))</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span>不存在日志就打断</span><br><span class="line">if [ $logCount -eq 0 ]; then</span><br><span class="line">    echo "Log not exist!"</span><br><span class="line">    exit </span><br><span class="line">fi</span><br><span class="line">echo 'Merge Success!'</span><br><span class="line"><span class="meta">#</span>打印socket</span><br><span class="line">if [ $printS = true ]; then</span><br><span class="line">    cat $mergeFile | grep -i 'socket' &gt;&gt; ./socket.log</span><br><span class="line">    echo 'Filter socket'</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><hr><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>查询了很多资料后写完了这个脚本，基本满足了我的需求，下面总结一下怎么解决遇到的问题。</p><h3 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h3><p>一开始学脚本时，书上都说<code>#! /bin/bash</code>，但是看项目中大神写的脚本，都是<code>#!/usr/bin/env bash</code>，有什么区别呢？</p><blockquote><p>脚本用env启动的原因，是因为脚本解释器在linux中可能被安装于不同的目录，env可以在系统的PATH目录中查找。<br>同时，env还规定一些系统环境变量。</p></blockquote><p>不同的系统，解释器的路径可能也不同，所以使用绝对路径是比较危险的方式。通过从环境中查找，可以保证兼容性。</p><hr><h3 id="获取选项"><a href="#获取选项" class="headerlink" title="获取选项"></a>获取选项</h3><p>开发中我们经常用到命令，这些命令一般都配合选项达到不同的效果，比如最常用的<code>ls -al</code>，通过<code>-a</code>来指定结果包含隐藏文件，通过<code>-l</code>达到列表显示的效果。</p><p>通过查询相关资料，我发现获取选项普遍的做法是使用<code>getopts</code>命令，但是这个方法只能获取<code>-h</code>这种短选项，对于<code>--help</code>长选项就不行。</p><p>第一种办法是换成<code>getopt</code>命令，但是并不是每个系统都支持这个命令。具体使用和<code>getopts</code>类似，比如<code>getopt -o ab:c -l a-long:b-long</code></p><p>第二种方法是把支持的长命令转成短命令，我使用的就是这种方式，相对来说比较容易理解，且case写的比较统一。通过<code>shift</code>取出参数，再<code>set --</code>的方式重写，最后<code>OPTIND=1</code>把指针指回第一个选项。</p><hr><h3 id="文件路径和文件后缀"><a href="#文件路径和文件后缀" class="headerlink" title="文件路径和文件后缀"></a>文件路径和文件后缀</h3><p>按需求需要判断后缀名来解压，那么就需要判断<code>tar.gz</code>之类的问题。同时，如果传入的文件目录是隐藏目录，也会造成一定的障碍。我们假设传入文件路径为<code>/a/.b/c.tar.gz</code>。</p><blockquote><p>${param#pattern}    从param前面删除pattern的最小匹配<br>${param##pattern}    从param前面删除pattern的最大匹配<br>${param%pattern}    从param后面删除pattern的最小匹配<br>${param%%pattern}    从param后面删除pattern的最大匹配</p></blockquote><p>如果按照<code>${fileName##*.}</code>来截取，那么只能拿到<code>gz</code>。<br>如果按照<code>${fileName#*.}</code>来截取，拿到的又是<code>b/c.tar.gz</code>。那怎么办呢？</p><p>好在有<code>dirname</code>可以直接获取文件路径，<code>basename</code>拿到文件名，单独对文件名进行<code>${fileName#*.}</code>就可以拿到<code>tar.gz</code>了。</p><hr><h3 id="去除不必要的打印"><a href="#去除不必要的打印" class="headerlink" title="去除不必要的打印"></a>去除不必要的打印</h3><p>执行解压命令时，会打印解压步骤，一般来说也需要显示，那如果我们不想要打印出来呢？有一个办法就是在命令之后加上<code>&gt; /dev/null 2&gt;&amp;1</code></p><blockquote><p>/dev/null ：代表空设备文件</p><p>>  ：代表重定向到哪里，例如：echo “123” &gt; /home/123.txt</p><p>1  ：表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null”</p><p>2  ：表示stderr标准错误</p><p>&amp;  ：表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1</p></blockquote><p>所以含义就是把命令输出结果和错误输出重定向，使得输出不在当前屏幕显示，由于null比较特殊，向这个文件输入等于进入黑洞，因此达到效果。</p><hr><h3 id="数组与空格"><a href="#数组与空格" class="headerlink" title="数组与空格"></a>数组与空格</h3><p>使用<code>ls | grep</code>的方式来过滤结果获取文件名数组的最大问题是，如果文件名包含空格，那么前后会被分割成两个单元，导致处理比较困难。</p><p>比较讨巧的方法是临时用特殊符号代替空格，在使用时再替换回来。这种方法不会改变文件名，也不用写复杂的数组合并，比较符合简单的设计。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tr " " "?"</span><br><span class="line"><span class="meta">$</span>&#123;logName//'?'/' '&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次简单的脚本实验，对shell有了新的认识，及时记录遇到的问题，相信下次会更有印象。使用脚本，可以让工作更有效率，相信以后也会越用越多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;临上线前测试比较努力，遇到闪退或者其他问题，会把日志包打给我，由于app内存限制，目前每次打包都是1m大小，所以有时查找问题的上下文比较吃力
      
    
    </summary>
    
      <category term="Shell" scheme="https://vanchchen.github.io/categories/Shell/"/>
    
    
      <category term="效率工具" scheme="https://vanchchen.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Category探索</title>
    <link href="https://vanchchen.github.io/p/5cb0.html"/>
    <id>https://vanchchen.github.io/p/5cb0.html</id>
    <published>2018-09-17T07:29:29.000Z</published>
    <updated>2018-10-16T01:15:41.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Category"><a href="#什么是Category" class="headerlink" title="什么是Category?"></a>什么是Category?</h2><p>Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已经存在的类添加方法，一般称为分类，文件名格式是”NSObject+A.h”。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">    <span class="keyword">struct</span> property_list_t *_classProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结构能看出分类可以扩展实例方法列表、类方法列表、协议列表，也支持扩展属性，但不支持扩展成员变量（之后会说）。</p><p>一般使用的场景有扩展现有类方法、代码分区、添加私有方法（不对外暴露category.h）、模拟多继承（使用关联对象的方式添加属性实现）</p><hr><h2 id="什么是Extension？"><a href="#什么是Extension？" class="headerlink" title="什么是Extension？"></a>什么是Extension？</h2><p>Extension一般被称为类扩展、匿名分类，用于定义私有属性和方法，不可被继承。只能依附自定义类写于.m中，定义一般为:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>类扩展支持写在多个.h文件，但都必须在.m文件中引用，且不能有自己的实现。</p><p>类扩展很多时候会与分类搞混，我在文后问答环节详细整理了他们的区别。</p><hr><h2 id="Category如何加载的？"><a href="#Category如何加载的？" class="headerlink" title="Category如何加载的？"></a>Category如何加载的？</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    class_data_bits_t bits; </span><br><span class="line">    class_rw_t *data() &#123;</span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars; <span class="comment">//只有ro才有实例变量表</span></span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先简单了解一下Class对象的结构，每个<code>objc_class</code>都包含有<code>class_data_bits_t</code>数据位，其中储存了<code>class_rw_t</code>的指针地址和一些其他标记。<code>class_rw_t</code>中包含有属性方法协议列表，以及<code>class_ro_t</code>指针地址。而在<code>class_ro_t</code>结构中，储存的是编译器决定的属性方法协议。</p><h3 id="那么是怎么运行的呢？"><a href="#那么是怎么运行的呢？" class="headerlink" title="那么是怎么运行的呢？"></a>那么是怎么运行的呢？</h3><p>在编译期类的结构中的<code>class_data_bits_t</code>指向的是一个 <code>class_ro_t</code>指针。</p><p>在运行时调用<code>realizeClass</code>方法，初始化一个<code>class_rw_t</code>结构体，设置ro值为原数据中的<code>class_ro_t</code>后设为数据位中的指向，最后调用<code>methodizeClass</code>方法加载。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> methodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line">    auto ro = rw-&gt;ro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从ro中加载方法表</span></span><br><span class="line">    method_list_t *list = ro-&gt;baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;list, <span class="number">1</span>, <span class="literal">YES</span>, isBundleClass(cls));</span><br><span class="line">        rw-&gt;methods.attachLists(&amp;list, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加载属性</span></span><br><span class="line">    property_list_t *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加载协议</span></span><br><span class="line">    protocol_list_t *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">        rw-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基类添加初始化方法</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, <span class="string">""</span>, <span class="literal">NO</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加载分类</span></span><br><span class="line">    category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</span><br><span class="line">    attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don't flush caches*/</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cats) free(cats);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在<code>methodizeClass</code>中加载了原先类在编译期决定的方法属性和协议，然后获取了未连接的分类表，将列表中的扩展方法添加到运行期类中。</p><hr><h2 id="Category方法覆盖"><a href="#Category方法覆盖" class="headerlink" title="Category方法覆盖"></a>Category方法覆盖</h2><p>如果不同的分类实现了相同名字的方法，那么调用时会使用最后加入的实现，这是为什么呢？</p><h3 id="加载Category"><a href="#加载Category" class="headerlink" title="加载Category"></a>加载Category</h3><p>dyld链接并初始化二进制文件后，交由<code>ImageLoader</code>读取，接着通知<code>runtime</code>处理，<code>runtime</code>调用<code>map_images</code>解析，然后执行<code>_read_images</code>分析文件中包含的类和分类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载分类</span></span><br><span class="line">category_t **catlist = </span><br><span class="line">    _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line"><span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    category_t *cat = catlist[i];</span><br><span class="line">    Class cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">        <span class="comment">//分类指定的类还没加载，可能是链接库顺序的问题</span></span><br><span class="line">        catlist[i] = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加分类到类的分类表中，伺机重载入</span></span><br><span class="line">    <span class="keyword">bool</span> classExists = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">        ||  cat-&gt;instanceProperties) </span><br><span class="line">    &#123;</span><br><span class="line">        addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">            remethodizeClass(cls);</span><br><span class="line">            classExists = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加分类到元类中</span></span><br><span class="line">    <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">        ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">    &#123;</span><br><span class="line">        addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">            remethodizeClass(cls-&gt;ISA());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加方法属性和协议"><a href="#添加方法属性和协议" class="headerlink" title="添加方法属性和协议"></a>添加方法属性和协议</h3><p>如果有新增的分类，就分别添加到原类和meta类，并通过<code>remethodizeClass</code>更新，具体就是调用<code>attachCategories</code>方法把分类中所有的方法都添加到指定类中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attachCategories</span><span class="params">(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新建数组指针</span></span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;<span class="comment">//倒序获取最新的分类</span></span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</span><br><span class="line">        <span class="comment">//分别获取列表</span></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line">    <span class="comment">//加载列表到rw中</span></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    <span class="built_in">free</span>(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    <span class="built_in">free</span>(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    <span class="built_in">free</span>(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                    oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">            <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">            List* oldList = <span class="built_in">list</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到最后调用了<code>rw-&gt;methods.attachLists(mlists, mcount);</code> 把新增分类中的方法列表添加到实际运行时查询的方法列表头部。</p><p>在进行方法调用时会从头部查询，一旦查到后就返回结果，因此后编译的文件中的方法会被优先调用。</p><p>同时之前添加的方法实现也保存了，可以通过获取同名方法的方式查找原类的实现。</p><hr><h2 id="Category实现属性"><a href="#Category实现属性" class="headerlink" title="Category实现属性"></a>Category实现属性</h2><h3 id="分类不能添加成员变量"><a href="#分类不能添加成员变量" class="headerlink" title="分类不能添加成员变量"></a>分类不能添加成员变量</h3><p>属性（Property）包含了成员变量（Ivar）和Setter&amp;Getter。</p><p>可以在分类中定义属性，但由于分类是在运行时添加分类属性到类的属性列表中，所以并没有创建对应的成员变量和方法实现。</p><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>如果我们想让分类实现添加新的属性，一般都通过关联对象的方式。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明文件</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestObject</span> (<span class="title">Category</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *object;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现文件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="keyword">const</span> kAssociatedObjectKey = (<span class="keyword">void</span> *)&amp;kAssociatedObjectKey;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestObject</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSObject</span> *)object &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, kAssociatedObjectKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="built_in">NSObject</span> *)object &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, kAssociatedObjectKey, object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>这种方式可以实现存取对象，但是不能获取<code>_object</code>变量。</p><hr><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><h3 id="分类和扩展有什么区别？"><a href="#分类和扩展有什么区别？" class="headerlink" title="分类和扩展有什么区别？"></a>分类和扩展有什么区别？</h3><p>1.分类多用于扩展方法实现，类扩展多用于申明私有变量和方法。</p><p>2.类扩展作用在编译期，直接和原类在一起，而分类作用在运行时，加载类的时候动态添加到原类中。</p><p>3.类扩展可以定义属性，分类中定义的属性只会申明setter/getter，并没有相关实现和变量。</p><h3 id="分类有哪些局限性？"><a href="#分类有哪些局限性？" class="headerlink" title="分类有哪些局限性？"></a>分类有哪些局限性？</h3><p>1.分类只能给现有的类加方法或协议，不能添加实例变量（ivar）。</p><p>2.分类添加的方法如果与现有的重名，会覆盖原有方法的实现。如果多个分类方法都重名，则根据编译顺序执行最后一个。</p><h3 id="分类的结构体里面有哪些成员？"><a href="#分类的结构体里面有哪些成员？" class="headerlink" title="分类的结构体里面有哪些成员？"></a>分类的结构体里面有哪些成员？</h3><p>分类结构体包含了分类名，绑定的类，实例与类方法列表，实例与类方法属性以及协议表。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">深入理解Objective-C：Category</a></p><p><a href="https://halfrost.com/objc_runtime_isa_class/" target="_blank" rel="noopener">神经病院 Objective-C Runtime 入院第一天—— isa 和 Class</a></p><p><a href="https://www.jianshu.com/p/0dc2513e117b" target="_blank" rel="noopener">探秘Runtime - 深入剖析Category</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Category&quot;&gt;&lt;a href=&quot;#什么是Category&quot; class=&quot;headerlink&quot; title=&quot;什么是Category?&quot;&gt;&lt;/a&gt;什么是Category?&lt;/h2&gt;&lt;p&gt;Category是Objective-C 2.0之后添加的语言特
      
    
    </summary>
    
      <category term="iOS" scheme="https://vanchchen.github.io/categories/iOS/"/>
    
    
      <category term="原理分析" scheme="https://vanchchen.github.io/tags/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题</title>
    <link href="https://vanchchen.github.io/p/6ea5.html"/>
    <id>https://vanchchen.github.io/p/6ea5.html</id>
    <published>2018-09-14T09:40:01.000Z</published>
    <updated>2018-10-16T01:35:44.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文借鉴整理了iOS高级开发常见的面试题，并且分博客一一分析，希望能和大家一起进步学习。</p><p>欢迎大家关注我的 <a href="https://github.com/VanchChen" target="_blank" rel="noopener">Github</a>👏以及相关博客 <a href="https://www.jianshu.com/u/a3a36cfc4cb6" target="_blank" rel="noopener">简书</a> <a href="https://www.cnblogs.com/vanch/" target="_blank" rel="noopener">博客园</a></p><p>大家的鼓励是我前进的动力😄</p><h2 id="iOS基础题"><a href="#iOS基础题" class="headerlink" title="iOS基础题"></a>iOS基础题</h2><ol><li>分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？<br> <a href="https://vanchchen.github.io/p/5cb0.html">Category探索</a></li><li>讲一下atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？</li><li>被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？</li><li>关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将其指针置空么？<br> <a href="https://vanchchen.github.io/p/f39e.html">AssociatedObject关联对象原理实现</a></li><li>KVO的底层实现？如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？<br> <a href="https://vanchchen.github.io/p/52b3.html">刨根问底KVO原理</a></li><li><code>Autoreleasepool</code>所使用的数据结构是什么？<code>AutoreleasePoolPage</code>结构体了解么？</li><li>讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的？为什么对象方法没有保存的对象结构体里，而是保存在类对象的结构体里？</li><li><code>class_ro_t</code> 和  <code>class_rw_t</code> 的区别？</li><li>iOS 中内省的几个方法？<code>class</code>方法和<code>objc_getClass</code>方法有什么区别?</li><li>在运行时创建类的方法<code>objc_allocateClassPair</code>的方法名尾部为什么是pair（成对的意思）？</li><li>一个int变量被<code>__block</code>修饰与否的区别？<br>\12. 为什么在block外部使用<code>__weak</code>修饰的同时需要在内部使用<code>__strong</code>修饰？</li><li>RunLoop的作用是什么？它的内部工作机制了解么？（最好结合线程和内存管理来说）</li><li>哪些场景可以触发离屏渲染？（知道多少说多少）</li></ol><hr><h2 id="iOS-实战题"><a href="#iOS-实战题" class="headerlink" title="iOS 实战题"></a>iOS 实战题</h2><ol><li>AppDelegate如何瘦身？</li><li>反射是什么？可以举出几个应用场景么？（知道多少说多少）</li><li>有哪些场景是NSOperation比GCD更容易实现的？（或是NSOperation优于GCD的几点，知道多少说多少）</li><li>App 启动优化策略？最好结合启动流程来说（main()函数的执行前后都分别说一下，知道多少说多少）</li><li>App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？（知道多少说多少）</li><li>你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？（知道多少说多少）</li><li>你知道有哪些情况会导致app卡顿，分别可以用什么方法来避免？（知道多少说多少）</li></ol><hr><h2 id="网络题"><a href="#网络题" class="headerlink" title="网络题"></a>网络题</h2><ol><li>App 网络层有哪些优化策略？</li><li>TCP为什么要三次握手，四次挥手？</li><li>对称加密和非对称加密的区别？分别有哪些算法的实现？</li><li>HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么？</li><li>HTTPS是如何实现验证身份和验证完整性的？</li><li>如何用Charles抓HTTPS的包？其中原理和流程是什么？</li><li>什么是中间人攻击？如何避免？</li></ol><hr><h2 id="计算机系统题"><a href="#计算机系统题" class="headerlink" title="计算机系统题"></a>计算机系统题</h2><ol><li>了解编译的过程么？分为哪几个步骤？</li><li>静态链接了解么？静态库和动态库的区别？</li><li>内存的几大区域，各自的职能分别是什么？</li><li>static和const有什么区别？</li><li>了解内联函数么？</li><li>什么时候会出现死锁？如何避免？</li><li>说一说你对线程安全的理解？</li><li>列举你知道的线程同步策略？</li><li>有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说</li></ol><hr><h2 id="设计模式题"><a href="#设计模式题" class="headerlink" title="设计模式题"></a>设计模式题</h2><ol><li>除了单例，观察者设计模式以外，还知道哪些设计模式？分别介绍一下</li><li>最喜欢哪个设计模式？为什么？</li><li>iOS SDK 里面有哪些设计模式的实践？</li><li>**设计模式是为了解决什么问题的？</li><li>**设计模式的成员构成以及工作机制是什么？</li><li>**设计模式的优缺点是什么？</li></ol><hr><h2 id="架构-amp-设计题"><a href="#架构-amp-设计题" class="headerlink" title="架构 &amp; 设计题"></a>架构 &amp; 设计题</h2><ol><li>MVC和MVVM的区别？MVVM和MVP的区别？</li><li>面向对象的几个设计原则了解么？最好可以结合场景来说。</li><li>可以说几个重构的技巧么？你觉得重构适合什么时候来做？</li><li>你觉得框架和设计模式的区别是什么？</li><li>看过哪些第三方框架的源码，它们是怎么设计的？设计好的地方在哪里，不好的地方在哪里，如何改进？（这道题的后三个问题的难度已经很高了，如果不是太N的公司不建议深究）</li></ol><hr><h2 id="数据结构-amp-算法题"><a href="#数据结构-amp-算法题" class="headerlink" title="数据结构&amp;算法题"></a>数据结构&amp;算法题</h2><ol><li>链表和数组的区别是什么？插入和查询的时间复杂度分别是多少？</li><li>哈希表是如何实现的？如何解决地址冲突？</li><li>排序题：冒泡排序，选择排序，插入排序，快速排序（二路，三路）能写出那些？</li><li>链表题：如何检测链表中是否有环？如何删除链表中等于某个值的所有节点？</li><li>数组题：如何在有序数组中找出和等于给定值的两个元素？如何合并两个有序的数组之后保持有序？</li><li>二叉树题：如何反转二叉树？如何验证两个二叉树是完全相等的？</li></ol><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://mp.weixin.qq.com/s/-cefmEo7RcZ5wifXX8JB5g" target="_blank" rel="noopener">出一套 iOS 高级面试题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文借鉴整理了iOS高级开发常见的面试题，并且分博客一一分析，希望能和大家一起进步学习。&lt;/p&gt;
&lt;p&gt;欢迎大家关注我的 &lt;a href=&quot;
      
    
    </summary>
    
      <category term="iOS" scheme="https://vanchchen.github.io/categories/iOS/"/>
    
    
      <category term="面试" scheme="https://vanchchen.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
