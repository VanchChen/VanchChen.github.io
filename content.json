{"meta":{"title":"Vanch's Blog","subtitle":"欢迎来到我的世界","description":"嘿嘿嘿～","author":"Vanch","url":"https://vanchchen.github.io"},"pages":[{"title":"","date":"2019-01-30T09:20:32.560Z","updated":"2017-11-07T01:57:43.000Z","comments":true,"path":"404.html","permalink":"https://vanchchen.github.io/404.html","excerpt":"","text":"404"},{"title":"","date":"2019-01-30T09:20:32.566Z","updated":"2018-10-08T01:55:15.826Z","comments":true,"path":"baidu_verify_taFsHIjAWm.html","permalink":"https://vanchchen.github.io/baidu_verify_taFsHIjAWm.html","excerpt":"","text":"taFsHIjAWm"},{"title":"","date":"2019-01-30T09:20:32.546Z","updated":"2018-10-08T01:55:15.827Z","comments":true,"path":"google706759de818b3de4.html","permalink":"https://vanchchen.github.io/google706759de818b3de4.html","excerpt":"","text":"google-site-verification: google706759de818b3de4.html"},{"title":"我是谁？","date":"2018-10-06T07:34:27.000Z","updated":"2019-03-29T05:45:30.100Z","comments":true,"path":"about/index.html","permalink":"https://vanchchen.github.io/about/index.html","excerpt":"","text":"@card{ 我叫陈文琦，英文名Vanch，现居上海，从事iOS开发工作，对代码有点强迫症。 近期才决定把最近所学整理成博客记录下来，目前主要方向为面试题准备。 坚信知识只有整理成自己的文字，才算理解学会。 } 兴趣@column-2{ @card{ 左脑主攻 iOS，Linux 原理实现与各种有意思的课题 正在学Shell脚本提高效率 准备边学 Swift4.4 边学算法 真够贪心 会Cocos开发微信小游戏 对Python有兴趣 } @card{ 右脑喜欢读文学、推理、历史书籍 大爱古典音乐，但也喜欢Rap 什么鬼.. 吉他 只会爬音阶 围棋 初级电脑都打不过 画画 只会简笔画 } } 健身计划 周一 周二 周三 周四 周五 周六 周日 胸\b臂 背肩 臀腿 胸\b臂 背肩 臀腿 \b休息 腹部 腹部 腹部 腹部 腹部 腹部 \b休息 @card{ 胸\b臂：\b弹力带夹胸、反手夹胸、交叉夹胸，\b俯卧撑，哑铃推举、弯举。 背肩：反手划船、对握划船，弹力带下压。 臀腿：深蹲，硬拉。 腹部：卷腹，平板支撑，腹健轮。 } 求勾搭@card{ 欢迎大家和我交流～ 微信：Vanch0714 邮箱：447389831@qq.com 可以在评论区留言，有时间我都会回复！ }"},{"title":"categories","date":"2018-09-14T09:13:36.000Z","updated":"2018-09-14T09:15:05.482Z","comments":false,"path":"categories/index.html","permalink":"https://vanchchen.github.io/categories/index.html","excerpt":"","text":""},{"title":"里世界","date":"1991-07-14T04:00:00.000Z","updated":"2019-03-29T07:21:35.639Z","comments":false,"path":"sage/index.html","permalink":"https://vanchchen.github.io/sage/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-14T09:00:14.000Z","updated":"2018-09-14T09:14:24.713Z","comments":false,"path":"tags/index.html","permalink":"https://vanchchen.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"如何优雅的隐藏 Hexo 博客文章","slug":"隐藏分类","date":"2019-03-29T06:08:07.000Z","updated":"2019-03-29T09:53:38.215Z","comments":true,"path":"p/7587.html","link":"","permalink":"https://vanchchen.github.io/p/7587.html","excerpt":"","text":"背景随着生活不断发生变故，有着想把自己私密隐私写成文字记录下来的想法，这些文字将会包含我最真实丑陋的一面，绝对不想让除了我之外的人看到。 但是Hexo以及Indigo主题并不支持隐藏文章的功能，所以花了几小时查阅资料实现了这个功能。 现记录实现细节如下。 隐藏文章首先要隐藏指定的文章，通过阅读与实践，最终采用了 为 Hexo 博客添加隐藏文章 / 限定公开功能 这个方案。 与该文作者不同的是，由于我是自用，并不需要做成插件的方式，所以直接修改了plugins.js 文件。 12345678910111213141516171819202122232425262728//themes/indigo/scripts/plugins.js//生成前过滤文章hexo.extend.filter.register('before_generate', function () &#123; const all_posts = this.locals.get('posts'); //找到所有hide标记为true的文章 const hide_posts = this.locals.get('posts').find(&#123; 'hide': true &#125;); //过滤hide文章 const normal_posts = this.locals.get('posts').filter(post =&gt; !post['hide']); this._bindLocals(); this.locals.set('all_posts', all_posts); this.locals.set('sage_posts', sage_posts); //更新生成的文章为过滤后的文章 //页面调用时获取的数据就是这个 this.locals.set('posts', normal_posts);&#125;)const original_post_generator = hexo.extend.generator.get('post');hexo.extend.generator.register('post', function (locals) &#123; //发送时需要把过滤的页面也加入 return original_post_generator.bind(this)(&#123; posts: new locals.posts.constructor( locals.posts.data.concat(locals.sage_posts.data) ) &#125;);&#125;); 接着只要设置页面的属性hide:true，就能够保证网站中找不到任何该页面的蛛丝马迹，但是可以直接访问链接(https://vanchchen.github.io/p/7587.html)查阅。 导航页面文章确实找不到了，虽然能够通过记录下每一个网址链接的方式访问，但是始终不够优雅，能不能像分类一样有一个导航页面呢？ Hexo页面的渲染需要使用模板，直接使用 page category tag 这些模板无法定制化成需要的数据，所以建立一个新的layout模版。 1234567891011121314151617//themes/indigo/layout/hide.ejs//标题栏&lt;%- partial('_partial/header', &#123; title: '里世界', hdClass: 'page-header'&#125;) %&gt;&lt;div class=\"container body-wrap fade\"&gt; &lt;!--&gt;仿照分类页面的设计，去除了分类头&lt;--&gt; &lt;div class=\"waterfall\"&gt; &lt;!--&gt;获取了之前脚本中设置的隐藏文章表&lt;--&gt; &lt;% site.hide_posts.each(function(post)&#123; %&gt; &lt;%- partial('_partial/archive', &#123;post: post, date_format: config.date_format&#125;) %&gt; &lt;% &#125;)%&gt; &lt;/div&gt; &lt;%- partial('_partial/paginator') %&gt;&lt;/div&gt; 接着设置一个新的index页面作为入口。1234//source/hide/index.mdlayout: hidetitle: 里世界 文章设置是这样的。1234567---title: 如何优雅的隐藏 Hexo 博客文章categories: Hexoabbrlink: '7587'tags:hide: true--- 隐藏导航Indigo主题默认会在帖子页的底部，展示上一个下一个贴的导航。 这会暴露我们隐藏的帖子链接，所以必须要去除。 1234//themes/indigo/_config.yml# 帖子页面是否展示上一个下一个导航栏showNav: false 123456//themes/indigo/layout/_partial/post.ejs//根据配置选择是否显示导航栏&lt;% if (theme.showNav == true) &#123; %&gt; &lt;%- partial('post/nav') %&gt;&lt;% &#125; %&gt; 总结通过这两个改动，就可以很方便的隐藏文章，并且通过访问hide路由进入隐藏文章列表页面，从而优雅的解决需求。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://vanchchen.github.io/categories/Hexo/"}],"tags":[]},{"title":"Atomic原子操作原理剖析","slug":"Atomic原理","date":"2018-12-28T09:40:47.000Z","updated":"2018-12-28T09:44:26.694Z","comments":true,"path":"p/168d.html","link":"","permalink":"https://vanchchen.github.io/p/168d.html","excerpt":"","text":"前言绝大部分 Objective-C 程序员使用属性时，都不太关注一个特殊的修饰前缀，一般都无脑的使用其非默认缺省的状态，他就是 atomic。 123456@interface PropertyClass@property (atomic, strong) NSObject *atomicObj; //缺省也是atomic@property (nonatomic, strong) NSObject *nonatomicObj;@end 入门教程中一般都建议使用非原子操作，因为新手大部分操作都在主线程，用不到线程安全的特性，大量使用还会降低执行效率。 那他到底怎么实现线程安全的呢？使用了哪种技术呢？ 原理属性的实现首先我们研究一下属性包含的内容。通过查阅源码，其结构如下： 1234struct property_t &#123; const char *name; //名字 const char *attributes; //特性&#125;; 属性的结构比较简单，包含了固定的名字和元素，可以通过 property_getName 获取属性名，property_getAttributes 获取特性。 上例中 atomicObj 的特性为 T@&quot;NSObject&quot;,&amp;,V_atomicObj，其中 V 代表了 strong，atomic 特性缺省没有显示，如果是 nonatomic 则显示 N。 那到底是怎么实现原子操作的呢？ 通过引入runtime，我们能调试一下调用的函数栈。 可以看到在编译时就把属性特性考虑进去了，Setter 方法直接调用了 objc_setProperty 的 atomic 版本。这里不用 runtime 去动态分析特性，应该是对执行性能的考虑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) &#123; //偏移为0说明改的是isa if (offset == 0) &#123; object_setClass(self, newValue); return; &#125; id oldValue; id *slot = (id*) ((char*)self + offset);//获取原值 //根据特性拷贝 if (copy) &#123; newValue = [newValue copyWithZone:nil]; &#125; else if (mutableCopy) &#123; newValue = [newValue mutableCopyWithZone:nil]; &#125; else &#123; if (*slot == newValue) return; newValue = objc_retain(newValue); &#125; //判断原子性 if (!atomic) &#123; //非原子直接赋值 oldValue = *slot; *slot = newValue; &#125; else &#123; //原子操作使用自旋锁 spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; objc_release(oldValue);&#125;id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) &#123; // 取isa if (offset == 0) &#123; return object_getClass(self); &#125; // 非原子操作直接返回 id *slot = (id*) ((char*)self + offset); if (!atomic) return *slot; // 原子操作自旋锁 spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); id value = objc_retain(*slot); slotlock.unlock(); // 出于性能考虑，在锁之外autorelease return objc_autoreleaseReturnValue(value);&#125; 什么是自旋锁呢？锁用于解决线程争夺资源的问题，一般分为两种，自旋锁(spin)和互斥锁(mutex)。 互斥锁可以解释为线程获取锁，发现锁被占用，就向系统申请锁空闲时唤醒他并立刻休眠。 自旋锁比较简单，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。 原子操作的颗粒度最小，只限于读写，对于性能的要求很高，如果使用了互斥锁势必在切换线程上耗费大量资源。相比之下，由于读写操作耗时比较小，能够在一个时间片内完成，自旋更适合这个场景。 自旋锁的坑但是iOS 10之后，苹果因为一个巨大的缺陷弃用了 OSSpinLock 改为新的 os_unfair_lock。 新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。 描述引用自 ibireme 大神的文章。 我的理解是，当低优先级线程获取了锁，高优先级线程访问时陷入忙等状态，由于是循环调用，所以占用了系统调度资源，导致低优先级线程迟迟不能处理资源并释放锁，导致陷入死锁。 那为什么原子操作用的还是 spinlock_t 呢？ 123456789101112131415using spinlock_t = mutex_tt&lt;LOCKDEBUG&gt;;using mutex_t = mutex_tt&lt;LOCKDEBUG&gt;;class mutex_tt : nocopy_t &#123; os_unfair_lock mLock; //处理了优先级的互斥锁 void lock() &#123; lockdebug_mutex_lock(this); os_unfair_lock_lock_with_options_inline (&amp;mLock, OS_UNFAIR_LOCK_DATA_SYNCHRONIZATION); &#125; void unlock() &#123; lockdebug_mutex_unlock(this); os_unfair_lock_unlock_inline(&amp;mLock); &#125;&#125; 差点被苹果骗了！原来系统中自旋锁已经全部改为互斥锁实现了，只是名称一直没有更改。 为了修复优先级反转的问题，苹果也只能放弃使用自旋锁，改用优化了性能的 os_unfair_lock，实际测试两者的效率差不多。 问答atomic的实现机制使用atomic 修饰属性，编译器会设置默认读写方法为原子读写，并使用互斥锁添加保护。 为什么不能保证绝对的线程安全？单独的原子操作绝对是线程安全的，但是组合一起的操作就不能保证。 123456789101112131415- (void)competition &#123; self.intSource = 0; dispatch_async(queue1, ^&#123; for (int i = 0; i &lt; 10000; i++) &#123; self.intSource = self.intSource + 1; &#125; &#125;); dispatch_async(queue2, ^&#123; for (int i = 0; i &lt; 10000; i++) &#123; self.intSource = self.intSource + 1; &#125; &#125;);&#125; 最终得到的结果肯定小于20000。当获取值的时候都是原子线程安全操作，比如两个线程依序获取了当前值 0，于是分别增量后变为了 1，所以两个队列依序写入值都是 1，所以不是线程安全的。 解决的办法应该是增加颗粒度，将读写两个操作合并为一个原子操作，从而解决写入过期数据的问题。 123456789101112131415161718192021os_unfair_lock_t unfairLock;- (void)competition &#123; self.intSource = 0; unfairLock = &amp;(OS_UNFAIR_LOCK_INIT); dispatch_async(queue1, ^&#123; for (int i = 0; i &lt; 10000; i++) &#123; os_unfair_lock_lock(unfairLock); self.intSource = self.intSource + 1; os_unfair_lock_unlock(unfairLock); &#125; &#125;); dispatch_async(queue2, ^&#123; for (int i = 0; i &lt; 10000; i++) &#123; os_unfair_lock_lock(unfairLock); self.intSource = self.intSource + 1; os_unfair_lock_unlock(unfairLock); &#125; &#125;);&#125; 总结通过学习属性的原子性，对系统中锁的理解又加深，包括自旋锁，互斥锁，读写锁等。 本来都以为实现是自旋锁了，还好留了个心眼多看了一层才发现最终实现还是互斥锁。这件事也给我一个小教训，查阅源码还是要刨根问底，只浮于表面的话，可能得不到想要的真相。 引用可以编译的runtime库 不再安全的 OSSpinLock","categories":[{"name":"iOS","slug":"iOS","permalink":"https://vanchchen.github.io/categories/iOS/"}],"tags":[{"name":"原理分析","slug":"原理分析","permalink":"https://vanchchen.github.io/tags/原理分析/"}]},{"title":"三种UIScrollView嵌套实现方案","slug":"UIScrollView嵌套","date":"2018-12-25T09:34:25.000Z","updated":"2018-12-25T09:54:50.335Z","comments":true,"path":"p/7448.html","link":"","permalink":"https://vanchchen.github.io/p/7448.html","excerpt":"","text":"背景随着产品功能不断的迭代，总会有需求希望在保证不影响其他区域功能的前提下，在某一区域实现根据选择器切换不同的内容显示。 苹果并不推荐嵌套滚动视图，如果直接添加的话，就会出现下图这种情况，手势的冲突造成了体验上的悲剧。 在实际开发中，我也不断的在思考解决方案，经历了几次重构后，有了些改进的经验，因此抽空整理了三种方案，他们实现的最终效果都是一样的。 分而治之最常见的一种方案就是使用 UITableView 作为外部框架，将子视图的内容通过 UITableViewCell 的方式展现。 这种做法的好处在于解耦性，框架只要接受不同的数据源就能刷新对应的内容。 123456789101112func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123; if indexPath.section == 0 &#123; return NSTHeaderHeight &#125; if segmentView.selectedIndex == 0 &#123; return tableSource.tableView(_:tableView, heightForRowAt:indexPath) &#125; return webSource.tableView(_:tableView, heightForRowAt:indexPath)&#125; 但是相对的也有一个问题，如果内部是一个独立的滚动视图，比如 UIWebView 的子视图 UIWebScrollView，还是会有手势冲突的情况。 常规做法首先禁止内部视图的滚动，当滚动到网页的位置时，启动网页的滚动并禁止外部滚动，反之亦然。 不幸的是，这种方案最大的问题是顿挫感。 内部视图初始是不能滚动的，所以外部视图作为整套事件的接收者。当滚动到预设的位置并开启了内部视图的滚动，事件还是传递给唯一接收者外部视图，只有松开手结束事件后重新触发，才能使内部视图开始滚动。 好在有一个方法可以解决这个问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; if scrollView == tableView &#123; //外部在滚动 if offset &gt; anchor &#123; //滚到过了锚点，还原外部视图位置，添加偏移到内部 tableView.setContentOffset(CGPoint(x: 0, y: anchor), animated: false) let webOffset = webScrollView.contentOffset.y + offset - anchor webScrollView.setContentOffset(CGPoint(x: 0, y: webOffset), animated: false) &#125; else if offset &lt; anchor &#123; //没滚到锚点，还原位置 webScrollView.setContentOffset(CGPoint.zero, animated: false) &#125; &#125; else &#123; //内部在滚动 if offset &gt; 0 &#123; //内部滚动还原外部位置 tableView.setContentOffset(CGPoint(x: 0, y: anchor), animated: false) &#125; else if offset &lt; 0 &#123; //内部往上滚，添加偏移量到外部视图 let tableOffset = tableView.contentOffset.y + offset tableView.setContentOffset(CGPoint(x: 0, y: tableOffset), animated: false) webScrollView.setContentOffset(CGPoint.zero, animated: false) &#125; &#125;&#125;func scrollViewDidEndScroll(_ scrollView: UIScrollView) &#123; //根据滚动停止后的偏移量，计算谁可以滚动 var outsideScrollEnable = true if scrollView == tableView &#123; if offset == anchor &amp;&amp; webScrollView.contentOffset.y &gt; 0 &#123; outsideScrollEnable = false &#125; else &#123; outsideScrollEnable = true &#125; &#125; else &#123; if offset == 0 &amp;&amp; tableView.contentOffset.y &lt; anchor &#123; outsideScrollEnable = true &#125; else &#123; outsideScrollEnable = false &#125; &#125; //设置滚动，显示对应的滚动条 tableView.isScrollEnabled = outsideScrollEnable tableView.showsHorizontalScrollIndicator = outsideScrollEnable webScrollView.isScrollEnabled = !outsideScrollEnable webScrollView.showsHorizontalScrollIndicator = !outsideScrollEnable&#125; 通过接受滚动回调，我们就可以人为控制滚动行为。当滚动距离超过了我们的预设值，就可以设置另一个视图的偏移量模拟出滚动的效果。滚动状态结束后，再根据判断来定位哪个视图可以滚动。 当然要使用这个方法，我们就必须把两个滚动视图的代理都设置为控制器，可能会对代码逻辑有影响 (UIWebView 是 UIWebScrollView 的代理，后文有解决方案)。 UITableView 嵌套的方式，能够很好的解决嵌套简单视图，遇到 UIWebView 这种复杂情况，也能人为控制解决。但是作为 UITableView 的一环，有很多限制(比如不同数据源需要不同的设定，有的希望动态高度，有的需要插入额外的视图)，这些都不能很好的解决。 各自为政另一种解决方案比较反客为主，灵感来源于下拉刷新的实现方式，也就是将需要显示的内容塞入负一屏。 首先保证子视图撑满全屏，把主视图内容插入子视图，并设置 ContentInset 为头部高度，从而实现效果。 来看下代码实现。 123456789101112131415161718192021222324func reloadScrollView() &#123; //选择当前显示的视图 let scrollView = segmentView.selectedIndex == 0 ? tableSource.tableView : webSource.webView.scrollView //相同视图就不操作了 if currentScrollView == scrollView &#123; return &#125; //从上次的视图中移除外部内容 headLabel.removeFromSuperview() segmentView.removeFromSuperview() if currentScrollView != nil &#123; currentScrollView!.removeFromSuperview() &#125; //设置新滚动视图的内嵌偏移量为外部内容的高度 scrollView.contentInset = UIEdgeInsets(top: NSTSegmentHeight + NSTHeaderHeight, left: 0, bottom: 0, right: 0) //添加外部内容到新视图上 scrollView.addSubview(headLabel) scrollView.addSubview(segmentView) view.addSubview(scrollView) currentScrollView = scrollView&#125; 由于在UI层级就只存在一个滚动视图，所以巧妙的避开了冲突。 相对的，插入的头部视图必须要轻量，如果需要和我例子中一样实现浮动栏效果，就要观察偏移量的变化手动定位。 12345678910111213141516171819202122232425262728func reloadScrollView() &#123; if currentScrollView != nil &#123; currentScrollView!.removeFromSuperview() //移除之前的 KVO observer?.invalidate() observer = nil &#125; //新视图添加滚动观察 observer = scrollView.observe(\\.contentOffset, options: [.new, .initial]) &#123;[weak self] object, change in guard let strongSelf = self else &#123; return &#125; let closureScrollView = object as UIScrollView var segmentFrame = strongSelf.segmentView.frame //计算偏移位置 let safeOffsetY = closureScrollView.contentOffset.y + closureScrollView.safeAreaInsets.top //计算浮动栏位置 if safeOffsetY &lt; -NSTSegmentHeight &#123; segmentFrame.origin.y = -NSTSegmentHeight &#125; else &#123; segmentFrame.origin.y = safeOffsetY &#125; strongSelf.segmentView.frame = segmentFrame &#125;&#125; 这方法有一个坑，如果加载的 UITableView 需要显示自己的 SectionHeader ，那么由于设置了 ContentInset ，就会导致浮动位置偏移。 我想到的解决办法就是在回调中不断调整 ContentInset 来解决。 12345678910111213141516171819observer = scrollView.observe(\\.contentOffset, options: [.new, .initial]) &#123;[weak self] object, change in guard let strongSelf = self else &#123; return &#125; let closureScrollView = object as UIScrollView //计算偏移位置 let safeOffsetY = closureScrollView.contentOffset.y + closureScrollView.safeAreaInsets.top //ContentInset 根据当前滚动定制 var contentInsetTop = NSTSegmentHeight + NSTHeaderHeight if safeOffsetY &lt; 0 &#123; contentInsetTop = min(contentInsetTop, fabs(safeOffsetY)) &#125; else &#123; contentInsetTop = 0 &#125; closureScrollView.contentInset = UIEdgeInsets(top: contentInsetTop, left: 0, bottom: 0, right: 0)&#125; 这个方法好在保证了有且仅有一个滚动视图，所有的手势操作都是原生实现，减少了可能存在的联动问题。 但也有一个小缺陷，那就是头部内容的偏移量都是负数，这不利于三方调用和系统原始调用的实现，需要维护。 中央集权最后介绍一种比较完善的方案。外部视图采用 UIScrollView ，内部视图永远不可滚动，外部边滚动边调整内部的位置，保证了双方的独立性。 与第二种方法相比，切换不同功能就比较简单，只需要替换内部视图，并实现外部视图的代理，滚动时设置内部视图的偏移量就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func reloadScrollView() &#123; //获取当前数据源 let contentScrollView = segmentView.selectedIndex == 0 ? tableSource.tableView : webSource.webView.scrollView //移除之前的视图 if currentScrollView != nil &#123; currentScrollView!.removeFromSuperview() &#125; //禁止滚动后添加新视图 contentScrollView.isScrollEnabled = false scrollView.addSubview(contentScrollView) //保存当前视图 currentScrollView = contentScrollView&#125;func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; //根据偏移量刷新 Segment 和内部视图的位置 self.view.setNeedsLayout() self.view.layoutIfNeeded() //根据外部视图数据计算内部视图的偏移量 var floatOffset = scrollView.contentOffset floatOffset.y -= (NSTHeaderHeight + NSTSegmentHeight) floatOffset.y = max(floatOffset.y, 0) //同步内部视图的偏移 if currentScrollView?.contentOffset.equalTo(floatOffset) == false &#123; currentScrollView?.setContentOffset(floatOffset, animated: false) &#125;&#125;override func viewDidLayoutSubviews() &#123; super.viewDidLayoutSubviews() //撑满全部 scrollView.frame = view.bounds //头部固定 headLabel.frame = CGRect(x: 15, y: 0, width: scrollView.frame.size.width - 30, height: NSTHeaderHeight) //Segment的位置是偏移和头部高度的最大值 //保证滚动到头部位置时不浮动 segmentView.frame = CGRect(x: 0, y: max(NSTHeaderHeight, scrollView.contentOffset.y), width: scrollView.frame.size.width, height: NSTSegmentHeight) //调整内部视图的位置 if currentScrollView != nil &#123; currentScrollView?.frame = CGRect(x: 0, y: segmentView.frame.maxY, width: scrollView.frame.size.width, height: view.bounds.size.height - NSTSegmentHeight) &#125;&#125; 当外部视图开始滚动时，其实一直在根据偏移量调整内部视图的位置。 外部视图的内容高度不是固定的，而是内部视图内容高度加上头部高度，所以需要观察其变化并刷新。 1234567891011121314151617181920func reloadScrollView() &#123; if currentScrollView != nil &#123; //移除KVO observer?.invalidate() observer = nil &#125; //添加内容尺寸的 KVO observer = contentScrollView.observe(\\.contentSize, options: [.new, .initial]) &#123;[weak self] object, change in guard let strongSelf = self else &#123; return &#125; let closureScrollView = object as UIScrollView let contentSizeHeight = NSTHeaderHeight + NSTSegmentHeight + closureScrollView.contentSize.height //当内容尺寸改变时，刷新外部视图的总尺寸，保证滚动距离 strongSelf.scrollView.contentSize = CGSize(width: 0, height: contentSizeHeight) &#125;&#125; 这个方法也有一个问题，由于内部滚动都是由外部来实现，没有手势的参与，因此得不到 scrollViewDidEndDragging 等滚动回调，如果涉及翻页之类的需求就会遇到困难。 解决办法是获取内部视图原本的代理，当外部视图代理收到回调时，转发给该代理实现功能。 123456789101112131415161718func reloadScrollView() &#123; typealias ClosureType = @convention(c) (AnyObject, Selector) -&gt; AnyObject //定义获取代理方法 let sel = #selector(getter: UIScrollView.delegate) //获取滚动视图代理的实现 let imp = class_getMethodImplementation(UIScrollView.self, sel) //包装成闭包的形式 let delegateFunc : ClosureType = unsafeBitCast(imp, to: ClosureType.self) //获得实际的代理对象 currentScrollDelegate = delegateFunc(contentScrollView, sel) as? UIScrollViewDelegate&#125;func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) &#123; if currentScrollDelegate != nil &#123; currentScrollDelegate!.scrollViewDidEndDragging? (currentScrollView!, willDecelerate: decelerate) &#125;&#125; 注意这里我并没有使用 contentScrollView.delegate，这是因为 UIWebScrollView 重载了这个方法并返回了 UIWebView 的代理。但实际真正的代理是一个 NSProxy 对象，他负责把回调传给 UIWebView 和外部代理。要保证 UIWebView 能正常处理的话，就要让它也收到回调，所以使用 Runtime 执行 UIScrollView 原始获取代理的实现来获取。 总结目前在生产环境中我使用的是最后一种方法，但其实这些方法互有优缺点。 方案 分而治之 各自为政 中央集权 方式 嵌套 内嵌 嵌套 联动 手动 自动 手动 切换 数据源 整体更改 局部更改 优势 便于理解 滚动效果好 独立性 劣势 联动复杂 复杂场景苦手 模拟滚动隐患 评分 🌟🌟🌟 🌟🌟🌟🌟 🌟🌟🌟🌟 技术没有对错，只有适不适合当前的需求。 分而治之适合 UITableView 互相嵌套的情况，通过数据源的变化能够很好实现切换功能。 各自为政适合相对简单的页面需求，如果能够避免浮动框，那使用这个方法能够实现最好的滚动效果。 中央集权适合复杂的场景，通过独立不同类型的滚动视图，使得互相最少影响，但是由于其模拟滚动的特性，需要小心处理。 希望本文能给大家带来启发，项目开源代码在此，欢迎指教与Star。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://vanchchen.github.io/categories/iOS/"}],"tags":[{"name":"重构","slug":"重构","permalink":"https://vanchchen.github.io/tags/重构/"}]},{"title":"腾讯云Mac图床插件","slug":"图床插件","date":"2018-12-07T06:16:09.000Z","updated":"2018-12-07T06:52:08.715Z","comments":true,"path":"p/648.html","link":"","permalink":"https://vanchchen.github.io/p/648.html","excerpt":"","text":"背景 随着博客越写越多，难免会遇到需要插入图片来说明的情况。 图床选择首先调研了市面上的图床服务，本着稳定长期的目标，过滤掉了打一枪换一个地方的野鸡小网站，剩余比较靠谱的优缺点如下。 图床 优点 缺点 腾讯云 免费 无需域名 未来可能会收费 七牛 免费 需要域名和备案 又拍云 免费 无需域名 未来可能会收费 阿里云 目前最完备 收费 需要域名 微博 免费 无需域名 不稳定 匿名上传 作为一个刚起步的小博客，应该把精力更多关注于内容，以后再考虑域名备案或者大流量套餐，因此尽量选择免费的图床。 其实是穷 微博作为国内首屈一指的流量大户，其图床的CDN和质量肯定没有问题，但是上传图片会自带水印，且匿名上传总觉得不靠谱。 剩下的选择还有两个，又拍云进军对象存储领域比腾讯云早而且更成熟，但是就规模和技术来说，我还是更愿意相信腾讯。 工具注册完腾讯云账号后，下一个问题就是怎么更方便的将图床与 MarkDown 结合起来使用，提高效率和体验。 iPic 完美符合我的需求，这是一款 Mac 上的状态栏软件，支持上传本地图片到设定的图床，获取图片地址后按照 ![](url) 格式复制到剪贴板。 那么好的应用为啥不用呢？ 因为不想按年交钱。应用默认是微博图床，如果要使用其他图床就需要购买专业版，每年60元。如果是一次买断的话，也就买了，年费心里总有疙瘩 矫情。 突然，我就想到！ 自己开发一个！ 闲的蛋疼 开发iPhone应用已经好多年了，还从未开发过Mac上的状态栏软件，正好还能锻炼下Swift，于是说干就干。没想到开发了一个月 需求设计产品使用逻辑基本与 iPic 一致，基于状态栏交互，选择png jpg文件上传。 可以设置是否压缩图片，压缩会压到500K以下。 还需要有一个登录界面记录腾讯云的账号和存储库信息。 文件上传成功后，弹出通知提醒，并复制到剪贴板。 如果不慎复制了其他文本导致丢失了链接，再点击一次通知就可以重新获取。 遇到的难题Swift第一关就是编程语言。 虽然也曾系统的学过Swift，但由于常年使用Objective-C 开发，思维方式还转不过来。 严格的空变量比较明显的区别就是处理空变量的方式。 在ObjC中，指针变量可以是nil（也就是0），对nil执行方法不会发生任何事情，因此可以算是部分安全。 Swift对待空变量更严格，!修饰的变量必须有具体值，?修饰的变量才具有空值的可能性。 nil不再表示为空对象，而是一个空值，向空值调用方法会导致闪退。对待?修饰的变量必须要小心，最好先判断是否有值再使用，好在有语法糖可以解决这类问题。 123456789101112131415161718192021//默认为nilvar money : String?//变量有值money = \"million\"//判断肯定有值后再使用if money != nil &#123; print(\"I have \\(money!) dollars.\")&#125;//保证变量有值并赋值给安全变量后执行if let account = money &#123; print(\"I have \\(account) dollars.\") &#125;//变量如果没有值就执行else事件并returnguard let account = money else &#123; print(\"I have no money.\")&#125;print(\"I have \\(account) dollars.\") 合理使用! ? 会使我们的代码更安全与简洁。 Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型。 抛出警告ObjC 有 @throw 的用法，但是根据苹果官方的描述，执行的成本很大。究其原因在于 ObjC 基于 C 语言而不是 C++，所以只能使用 setjmp()和longjmp() 方法实现，因此可能会造成内存泄漏。 Important: Exceptions are resource-intensive in Objective-C. You should not use exceptions for general flow-control, or simply to signify errors (such as a file not being accessible) Swift 从根本解决了这个问题，并结合枚举优化了整个流程。 12345678910111213141516171819202122232425262728enum CompressError : Error &#123; case NoImage case OverSize(size : Int)&#125;func compressImage(_ imageData: Data?) throws -&gt; Data? &#123; guard var compressData = imageData else &#123; throw CompressError.NoImage &#125; if compressData.count &gt; maxSize &#123; throw CompressError.OverSize(size: compressData.count) &#125;&#125;func uploadImage(_ imageData: Data?) &#123; var compressData : Data? = nil do &#123; compressData = try self.compressImage(imageData) &#125; catch CompressError.NoImage &#123; print(\"Image Not Exist\") &#125; catch CompressError.OverSize(let size) &#123; print(\"Image over size of \\(size)\") &#125; catch _ &#123;&#125; //简洁的方式，忽略处理警告 let compressData = try? self.compressImage(imageData)&#125; 利用Swift强大的枚举类型，可以定制化警告从而传递出我们需要的信息，使得整个流程更为顺畅。 语法还支持 try?忽略警告获取一个可能为空值的变量，如果自信绝对不会抛出异常的话，还能使用try!获取一个肯定值。 Mac OS 开发实际编写Cocoa代码过程中，发现与UIKit相差还是比较多的。 控件逻辑UIKit 的层级一般是 UINavigationController -&gt; UIViewController Cocoa 的层级则不太一样，NSWindowController -&gt; NSViewController 原因也很简单，手机上一般只有一个窗口，依靠导航栏进行页面跳转。但是桌面端逻辑就不太一样，新页面一般都是以新窗口的形式弹出。 其次桌面端拥有特定的状态栏控件NSMenu，在其中操作菜单项也是一个新的挑战。 腾讯云相关由于腾讯云只提供了iOS的库，所以我还需要先把库文件重新调整为Cocoa代码。这一部分也是吃了不少苦头，需要把设备相关的代码与应用、进出后台的通知等都去除，还要处理类似功能的转换（比如UIImage -&gt; NSImage）。 同时还有第二个坑，腾讯云的库都是ObjC代码，所以需要混编。 创建一个工作空间后拖入两个工程，在主工程的 Targets / Build Phases / Embed Frameworks 中加入SDK库。 接着在Swift工程中创建Project-Bridging-Header.h 头文件，在其中引用SDK库。 最后在 Targets / Build Settings / Objective-C Bridging Header 设置头文件，就可以解决代码混编的问题。 其原理在于自动创建了基于头文件的pch，把头文件中引用到的ObjC代码，都桥接到工程中。 图片压缩算法之所以不使用现成的软件还有一个原因，就是我想自己控制压缩图片的参数和效果。 通过调研和实验图片压缩效果，最终我选择压制成jpg格式，500k大小限制，压缩率限制为最小0.75，等比宽度限制为1280px。 文首那张美女图，初始是1.9M 5087x3661，由于尺寸过大，第一次压缩图片质量后，容量反而增加到了2.4M。 将宽高等比缩小到1280x922，图片又变大了，这次增加到了4.7M。（改变宽高需要新建一张画布，创建时必须要有alpha通道等其他设置，所以会变大） 我们接着压缩，最终在压缩率为0.9的情况下把图片压到了260K，成功达到了目标。 总结距离上一次博客已经有两个月的间隔，其中一部分原因在于生活上的一些变故，另一个原因就在于不熟悉 Cocoa + Swift 开发。 好在最终还是啃出来了，Github项目已开源，欢迎大家指点与吐槽。 这次项目最大的收获在于脱离自己的舒适区。人的本性包含惰性，总是趋向于在熟悉的领域干熟悉的活。但是就和企业一样，不创新就死，技术不断在发展，如果没有跟上潮流，最终就会被淘汰。以此共勉！ 参考资料Swift 4.0 教程 App图片压缩裁剪原理和上传方案","categories":[{"name":"iOS","slug":"iOS","permalink":"https://vanchchen.github.io/categories/iOS/"}],"tags":[{"name":"效率工具","slug":"效率工具","permalink":"https://vanchchen.github.io/tags/效率工具/"}]},{"title":"刨根问底KVO原理","slug":"刨根问底KVO原理","date":"2018-10-15T09:31:00.000Z","updated":"2018-10-16T01:15:41.979Z","comments":true,"path":"p/52b3.html","link":"","permalink":"https://vanchchen.github.io/p/52b3.html","excerpt":"","text":"介绍KVO( NSKeyValueObserving )是一种监测对象属性值变化的观察者模式机制。其特点是无需事先修改被观察者代码，利用 runtime 实现运行中修改某一实例达到目的，保证了未侵入性。 A对象指定观察B对象的属性后，当属性发生变更，A对象会收到通知，获取变更前以及变更的状态，从而做进一步处理。 在实际生产环境中，多用于应用层观察模型层数据变动，接收到通知后更新，从而达成比较好的设计模式。 另一种常用的用法是 Debug，通过观察问题属性的变化，追踪问题出现的堆栈，更有效率的解决问题。 应用观察回调1234- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context; 观察者需要实现这个方法来接受回调，其中keyPath 是 KVC 路径， object 是观察者，context 区分不同观察的标识。 改变字典最关键的是改变字典，其中包含了 NSKeyValueChangeKey，通过预定义的字符串来获取特定的数值。 1234567typedef NSString * NSKeyValueChangeKey NS_STRING_ENUM;FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeKindKey;FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNewKey;FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeOldKey;FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeIndexesKey;FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNotificationIsPriorKey NSKeyValueChangeKindKey 中定义的是改变的类型，如果调用的是Setter方法，那就是NSKeyValueChangeSetting。 剩余的三种分别是插入、删除、替换，当观察的属性属于集合类（这点会在之后讲），变动时就会通知这些类型。 123456typedef NS_ENUM(NSUInteger, NSKeyValueChange) &#123; NSKeyValueChangeSetting = 1, NSKeyValueChangeInsertion = 2, NSKeyValueChangeRemoval = 3, NSKeyValueChangeReplacement = 4,&#125;; NSKeyValueChangeNewKey 获取变更的最新值，NSKeyValueChangeOldKey 获取原始数值。 NSKeyValueChangeIndexesKey 如果观察的是集合，那这个键值返回索引集合。 NSKeyValueChangeNotificationIsPriorKey 如果设置了接受提前通知，那么修改之前会先发送通知，修改后再发一次。为了区分这两次，第一次会带上这个键值对，其内容为 @1。 字符串枚举在注册类型时，苹果使用了NS_STRING_ENUM宏。 虽然这个宏在ObjC下毫无作用，但是对于Swift有优化，上面的定义会变成这样。123456789enum NSKeyValueChangeKey: String &#123; case kind case new case old case indexes case notificationIsPrior&#125;let dict: [NSKeyValueChangeKey : Any] = [......]let kind = dict[.kind] as! Number 字符串枚举对于使用来说是非常直观和安全的。 添加与删除对于普通对象，使用这两个方法就能注册与注销观察。12345678- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context; 可以设置多种观察模式来匹配需求。1234567891011typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123; //可以收到新改变的数值 NSKeyValueObservingOptionNew = 0x01, //可以收到改变前的数值 NSKeyValueObservingOptionOld = 0x02, //addObserver后立刻触发通知，只有new，没有old NSKeyValueObservingOptionInitial = 0x04, //会在改变前与改变后发送两次通知 //改变前的通知带有notificationIsPrior=@1，old NSKeyValueObservingOptionPrior = 0x08&#125;; 由于不符合 KVC 的访问器标准，苹果规定 NSArray NSOrderedSet NSSet 不可以执行 addObserver 方法，不然会抛出异常。针对 NSArray 有特殊的方法，如下12345678910- (void)addObserver:(NSObject *)observer toObjectsAtIndexes:(NSIndexSet *)indexes forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;- (void)removeObserver:(NSObject *)observer fromObjectsAtIndexes:(NSIndexSet *)indexes forKeyPath:(NSString *)keyPath context:(nullable void *)context; 主要的区别在于多了一个ObjectsAtIndexes，其实做的事情是一样的，根据索引找到对象，再逐一建立观察关系。 原理RuntimeNSKeyValueObserving 与 NSKeyValueCoding 一起定义在 Foundation 库，而这个库是不开源的，我们先从苹果开发者文档中获取信息。 Automatic key-value observing is implemented using a technique called isa-swizzling. 看描述猜测苹果应该是通过重新设置被观察者的 Class (isa 中包含 Class 信息)，该类继承了原类并且重载属性的 Setter 方法，添加发通知的操作达到目的。 12345678910111213141516171819202122232425@interface ConcreteSubject : NSObject@property (nonatomic, strong) id obj;@endConcreteSubject *sub = [ConcreteSubject new];NSLog(@\"%s\", class_getName(object_getClass(sub)));//改变前 outprint--&gt; ConcreteSubject[sub addObserver:self forKeyPath:@\"obj\" options:NSKeyValueObservingOptionNew context:nil];//执行观察方法NSLog(@\"%s\", class_getName(object_getClass(sub)));//改变后 outprint--&gt; NSKVONotifying_ConcreteSubjectNSLog(@\"%s\", class_getName(object_getClass(class_getSuperclass(cls))));//获取超类名 outprint--&gt; ConcreteSubjectNSLog(@\"%s\", class_getName(sub.class));//获取类名 outprint--&gt; ConcreteSubjectclass_getMethodImplementation(cls, @selector(setObj:));//imp = (IMP)(Foundation`_NSSetObjectValueAndNotify)class_getMethodImplementation(cls, @selector(class));//imp = (IMP)(Foundation`NSKVOClass) 试了一下果然 Class 被替换了，变成加了 NSKVONotifying_ 前缀的新类。 新类继承自原类，但是这个类的 class 方法返回的还是原类，这保证了外部逻辑完整。 反编译源码通过 Runtime ，我们只能知道 KVO 使用了一个继承了原类的类，并且替换了原方法的实现，setObj: = _NSSetObjectValueAndNotify class = _NSKVOClass。如果我们想进一步了解详情，只能通过反编译 Foundation 来查找汇编代码。 这里我使用了 Hopper 工具，分析的二进制文件路径是/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/Foundation.framework/Foundation 替换的实现1234567891011//伪代码，仅供理解void _NSKVOClass(id self, SEL _cmd) &#123; Class cls = object_getClass(self); Class originCls = __NSKVONotifyingOriginalClassForIsa(cls); if (cls != originCls) &#123; return [originCls class]; &#125; else &#123; Method method = class_getInstanceMethod(cls, _cmd); return method_invoke(self, method); &#125;&#125; 先看原 class 方法，获取了当前类和原类，如果不一致就返回原类，如果一致就执行原 class 实现。 12345678910111213141516171819//伪代码，仅供理解void __NSSetObjectValueAndNotify(id self, SEL _cmd, id value) &#123; //获取额外的变量 void *indexedIvars = object_getIndexedIvars(object_getClass(self)); //加锁 pthread_mutex_lock(indexedIvars + 0x20); //从SEL获取KeyPath NSString *keyPath = [CFDictionaryGetValue(*(indexedIvars) + 0x18), _cmd) copyWithZone:0x0]; //解锁 pthread_mutex_unlock(indexedIvars + 0x20); //改变前发通知 [self willChangeValueForKey:keyPath]; //实现Setter方法 IMP imp = class_getMethodImplementation(*indexedIvars, _cmd); (imp)(self, _cmd, value); //改变后发通知 [self didChangeValueForKey:keyPath];&#125; 再看改变后的 Setter 方法，其中 indexedIvars 是原类之外的成员变量，第一个指针是改变后的类，0x20 的偏移量是线程锁，0x18 地址储存了改变过的方法字典。 在执行原方法实现前调用了 willChangeValueForKey 发起通知，同样在之后调用 didChangeValueForKey。 添加观察方法那么是在哪个方法中替换的实现呢？先看 [NSObject addObserver:forKeyPath:options:context:] 方法。12345678910111213//伪代码，仅供理解void -[NSObject addObserver:forKeyPath:options:context:](void * self, void * _cmd, void * arg2, void * arg3, unsigned long long arg4, void * arg5) &#123; pthread_mutex_lock(__NSKeyValueObserverRegistrationLock); *__NSKeyValueObserverRegistrationLockOwner = pthread_self(); rax = object_getClass(self); rax = _NSKeyValuePropertyForIsaAndKeyPath(rax, arg3); [self _addObserver:arg2 forProperty:rax options:arg4 context:arg5]; *__NSKeyValueObserverRegistrationLockOwner = 0x0; pthread_mutex_unlock(__NSKeyValueObserverRegistrationLock); return;&#125; 方法很简单，根据 KeyPath 获取具体属性后进一步调用方法。由于这个方法比较长，我特地整理成 ObjC 代码，方便大家理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//伪代码，仅供理解- (void *)_addObserver:(id)observer forProperty:(NSKeyValueProperty *)property options:(NSKeyValueObservingOptions)option context:(void *)context &#123; //需要注册通知 if (option &amp; NSKeyValueObservingOptionInitial) &#123; //获取属性名路径 NSString *keyPath = [property keyPath]; //解锁 pthread_mutex_unlock(__NSKeyValueObserverRegistrationLock); //如果注册了获得新值，就获取数值 id value = nil; if (option &amp; NSKeyValueObservingOptionNew) &#123; value = [self valueForKeyPath:keyPath]; if (value == nil) &#123; value = [NSNull null]; &#125; &#125; //发送注册通知 _NSKeyValueNotifyObserver(observer, keyPath, self, context, value, 0 /*originalObservable*/, 1 /*NSKeyValueChangeSetting*/); //加锁 pthread_mutex_lock(__NSKeyValueObserverRegistrationLock); &#125; //获取属性的观察信息 Info *info = __NSKeyValueRetainedObservationInfoForObject(self, property-&gt;_containerClass); //判断是否需要获取新的数值 id _additionOriginalObservable = nil; if (option &amp; NSKeyValueObservingOptionNew) &#123; //0\u001dx15没有找到定义，猜测为保存是否可观察的数组 id tsd = _CFGetTSD(0x15); if (tsd != nil) &#123; _additionOriginalObservable = *(tsd + 0x10); &#125; &#125; //在原有信息上生成新的信息 Info *newInfo = __NSKeyValueObservationInfoCreateByAdding (info, observer, property, option, context, _additionOriginalObservable, 0, 1); //替换属性的观察信息 __NSKeyValueReplaceObservationInfoForObject(self, property-&gt;_containerClass, info, newInfo); //属性添加后递归添加关联属性 [property object:self didAddObservance:newInfo recurse:true]; //获取新的isa Class cls = [property isaForAutonotifying]; if ((cls != NULL) &amp;&amp; (object_getClass(self) != cls)) &#123; //如果是第一次就替换isa object_setClass(self, cls); &#125; //释放观察信息 [newInfo release]; if (info != nil) &#123; [info release]; &#125; return;&#125; 其中有可能替换方法实现的步骤是获取 isa 的时候，猜测当第一次创建新类的时候，会注册新的方法，接着追踪 isaForAutonotifying 方法。 获取观察类1234567891011121314151617181920void * -[NSKeyValueUnnestedProperty _isaForAutonotifying] (void * self, void * _cmd) &#123; rbx = self; r14 = *_OBJC_IVAR_$_NSKeyValueProperty._containerClass; if ([*(rbx + r14)-&gt;_originalClass automaticallyNotifiesObserversForKey:rbx-&gt;_keyPath] != 0x0) &#123; r14 = __NSKeyValueContainerClassGetNotifyingInfo(*(rbx + r14)); if (r14 != 0x0) &#123; __NSKVONotifyingEnableForInfoAndKey(r14, rbx-&gt;_keyPath); rax = *(r14 + 0x8); &#125; else &#123; rax = 0x0; &#125; &#125; else &#123; rax = 0x0; &#125; return rax;&#125; 立刻发现了熟悉的方法！ automaticallyNotifiesObserversForKey: 是一个类方法，如果你不希望某个属性被观察，那么就设为 NO，isa 返回是空也就宣告这次添加观察失败。 如果一切顺利的话，将会执行__NSKVONotifyingEnableForInfoAndKey(info, keyPath) 改变 class 的方法，最终返回其 isa。 实质替换方法由于该方法实在太长，且使用了goto不方便阅读，所以依旧整理成伪代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//伪代码，仅供理解int __NSKVONotifyingEnableForInfoAndKey(void *info, id keyPath) &#123; //线程锁加锁 pthread_mutex_lock(info + 0x20); //添加keyPath到数组 CFSetAddValue(*(info + 0x10), keyPath); //解锁 pthread_mutex_unlock(info + 0x20); //判断原类实现能不能替换 Class originClass = *info; MethodClass *methodClass = __NSKeyValueSetterForClassAndKey(originClass, keyPath, originClass); if (![methodClass isKindOfClass:[NSKeyValueMethodSetter class]]) &#123; swizzleMutableMethod(info, keyPath); return; &#125; //判断Setter方法返回值 Method method = [methodClass method]; if (*(int8_t *)method_getTypeEncoding(method) != _C_VOID) &#123; _NSLog(@\"KVO autonotifying only supports -set&lt;Key&gt;: methods that return void.\"); swizzleMutableMethod(info, keyPath); return; &#125; //获取Setter方法参数 char *typeEncoding = method_copyArgumentType(method, 0x2); char type = sign_extend_64(*(int8_t *)typeEncoding); SEL sel;//根据参数类型选择替换的方法 switch (type) &#123; case _C_BOOL: sel = __NSSetBoolValueAndNotify; case _C_UCHR: sel = __NSSetUnsignedCharValueAndNotify; case _C_UINT: sel = __NSSetUnsignedIntValueAndNotify; case _C_ULNG: sel = __NSSetUnsignedLongValueAndNotify; case _C_ULNG_LNG: sel = __NSSetUnsignedLongLongValueAndNotify; case _C_CHR: sel = __NSSetCharValueAndNotify; case _C_DBL: sel = __NSSetDoubleValueAndNotify; case _C_FLT: sel = __NSSetFloatValueAndNotify; case _C_INT: sel = __NSSetIntValueAndNotify; case _C_LNG: sel = __NSSetLongValueAndNotify; case _C_LNG_LNG: sel = __NSSetLongLongValueAndNotify; case _C_SHT: sel = __NSSetShortValueAndNotify; case _C_USHT: sel = __NSSetUnsignedShortValueAndNotify; case _C_LNG_LNG: sel = __NSSetLongLongValueAndNotify; case _C_ID: sel = __NSSetObjectValueAndNotify; case \"&#123;CGPoint=dd&#125;\": sel = __NSSetPointValueAndNotify; case \"&#123;_NSRange=QQ&#125;\": sel = __NSSetRangeValueAndNotify; case \"&#123;CGRect=&#123;CGPoint=dd&#125;&#123;CGSize=dd&#125;&#125;\": sel = __NSSetRectValueAndNotify; case \"&#123;CGSize=dd&#125;\": sel = __NSSetSizeValueAndNotify; case *_NSKeyValueOldSizeObjCTypeName: sel = __CF_forwarding_prep_0; default; &#125; //不支持的参数类型打印错误信息 if (sel == NULL) &#123; _NSLog(@\"KVO autonotifying only supports -set&lt;Key&gt;: methods that take id, NSNumber-supported scalar types, and some NSValue-supported structure types.\") swizzleMutableMethod(info, keyPath); return; &#125; //替换方法实现 SEL methodSel = method_getName(method); _NSKVONotifyingSetMethodImplementation(info, methodSel, sel, keyPath); if (sel == __CF_forwarding_prep_0) &#123; _NSKVONotifyingSetMethodImplementation(info, @selector(forwardInvocation:), _NSKVOForwardInvocation, false); Class cls = *(info + 0x8); SEL newSel = sel_registerName(\"_original_\" + sel_getName(methodSel)); Imp imp = method_getImplementation(method); TypeEncoding type = method_getTypeEncoding(method); class_addMethod(cls, newSel, imp, type); &#125; swizzleMutableMethod(info, keyPath);&#125; 可以表述为根据 Setter 方法输入参数类型，匹配合适的 NSSetValueAndNotify 实现来替换，从而实现效果。 那么 swizzleMutableMethod 是干嘛的呢？ 1234567891011121314151617181920212223242526272829303132333435363738//替换可变数组集合的方法int swizzleMutableMethod(void *info, id keyPath) &#123; //NSKeyValueArray CFMutableSetRef getterSet = __NSKeyValueMutableArrayGetterForIsaAndKey(*info, keyPath); if ([getterSet respondsToSelector:mutatingMethods]) &#123; mutatingMethods methodList = [getterSet mutatingMethods]; replace methodList-&gt;insertObjectAtIndex _NSKVOInsertObjectAtIndexAndNotify replace methodList-&gt;insertObjectsAtIndexes _NSKVOInsertObjectsAtIndexesAndNotify replace methodList-&gt;removeObjectAtIndex _NSKVORemoveObjectAtIndexAndNotify replace methodList-&gt;removeObjectsAtIndexes _NSKVORemoveObjectsAtIndexesAndNotify replace methodList-&gt;replaceObjectAtIndex _NSKVOReplaceObjectAtIndexAndNotify replace methodList-&gt;replaceObjectsAtIndexes _NSKVOReplaceObjectsAtIndexesAndNotify &#125; //NSKeyValueOrderedSet getterSet = __NSKeyValueMutableOrderedSetGetterForIsaAndKey(*info, keyPath); if ([getterSet respondsToSelector:mutatingMethods]) &#123; mutatingMethods methodList = [getterSet mutatingMethods]; replace methodList-&gt;insertObjectAtIndex _NSKVOInsertObjectAtIndexAndNotify replace methodList-&gt;insertObjectsAtIndexes _NSKVOInsertObjectsAtIndexesAndNotify replace methodList-&gt;removeObjectAtIndex _NSKVORemoveObjectAtIndexAndNotify replace methodList-&gt;removeObjectsAtIndexes _NSKVORemoveObjectsAtIndexesAndNotify replace methodList-&gt;replaceObjectAtIndex _NSKVOReplaceObjectAtIndexAndNotify replace methodList-&gt;replaceObjectsAtIndexes _NSKVOReplaceObjectsAtIndexesAndNotify &#125; //NSKeyValueSet getterSet = __NSKeyValueMutableSetGetterForClassAndKey(*info, keyPath); if ([getterSet respondsToSelector:mutatingMethods]) &#123; mutatingMethods methodList = [getterSet mutatingMethods]; replace methodList-&gt;addObject _NSKVOAddObjectAndNotify replace methodList-&gt;intersectSet _NSKVOIntersectSetAndNotify replace methodList-&gt;minusSet _NSKVOMinusSetAndNotify replace methodList-&gt;removeObject _NSKVORemoveObjectAndNotify replace methodList-&gt;unionSet _NSKVOUnionSetAndNotify &#125; //改变新类的方法缓存 __NSKeyValueInvalidateCachedMutatorsForIsaAndKey(*(info + 0x8), keyPath); return rax;&#125; 前面提到的都是一对一，那如果我想观察一对多的集合类呢？就是通过 KVC 中的 mutableArrayValueForKey: 返回一个代理集合，改变这些代理类的实现做到的。具体的例子之后会介绍。 创建新类还有一个疑问就是替换的类是怎么创建的？具体方法在 __NSKVONotifyingEnableForInfoAndKey 中实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//伪代码，仅供理解int __NSKVONotifyingCreateInfoWithOriginalClass(Class cls) &#123; //拼接新名字 const char *name = class_getName(cls); int length = strlen(r12) + 0x10;//16是NSKVONotifying_的长度 char *newName = malloc(length); __strlcpy_chk(newName, \"NSKVONotifying_\", length, -1); __strlcat_chk(newName, name, length, -1); //生成一个继承原类的新类 Class newCls = objc_allocateClassPair(cls, newName, 0x68); free(newName); if (newCls != NULL) &#123; objc_registerClassPair(newCls); //获取额外的实例变量表 void *indexedIvars = object_getIndexedIvars(newCls); *indexedIvars = cls; //记录原isa *(indexedIvars + 0x8) = newCls; //记录新isa //新建一个集合，保存观察的keyPath *(indexedIvars + 0x10) = CFSetCreateMutable(0x0, 0x0, _kCFCopyStringSetCallBacks); //新建一个字典，保存改变过的SEL *(indexedIvars + 0x18) = CFDictionaryCreateMutable(0x0, 0x0, 0x0, _kCFTypeDictionaryValueCallBacks); //新建一个线程锁 pthread_mutexattr_init(var_38); pthread_mutexattr_settype(var_38, 0x2); pthread_mutex_init(indexedIvars + 0x20, var_38); pthread_mutexattr_destroy(var_38); //获取NSObject类默认的实现 if (*__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectIMPLookupOnce == NULL) &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectWillChange = class_getMethodImplementation([NSObject class], @selector(willChangeValueForKey:)); *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectDidChange = class_getMethodImplementation([NSObject class], @selector(didChangeValueForKey:)); &#125;); &#125; //设置是否替换过ChangeValue方法的flag BOOL isChangedImp = YES; if (class_getMethodImplementation(cls, @selector(willChangeValueForKey:)) == *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectWillChange) &#123; BOOL isChangedDidImp = class_getMethodImplementation(cls, @selector(didChangeValueForKey:)) != *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectDidChange; isChangedImp = isChangedDidImp ? YES : NO; &#125; *(int8_t *)(indexedIvars + 0x60) = isChangedImp; //使用KVO的实现替换原类方法 _NSKVONotifyingSetMethodImplementation(indexedIvars, @selector(_isKVOA), _NSKVOIsAutonotifying, false/*是否需要保存SEL到字典*/); _NSKVONotifyingSetMethodImplementation(indexedIvars, @selector(dealloc), _NSKVODeallocate, false); _NSKVONotifyingSetMethodImplementation(indexedIvars, @selector(class), _NSKVOClass, false); &#125; return newCls;&#125; 建立关系还有一种情况就是观察的属性依赖于多个关系，比如 color 可能依赖于 r g b a，其中任何一个改变，都需要通知 color 的变化。 建立关系的方法是 + (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key 或 + (NSSet *)keyPathsForValuesAffecting&lt;key&gt; 返回依赖键值的字符串集合 123456789101112//伪代码+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123; char *str = \"keyPathsForValuesAffecting\" + key; SEL sel = sel_registerName(str); Method method = class_getClassMethod(self, sel); if (method != NULL) &#123; result = method_invoke(self, method); &#125; else &#123; result = [self _keysForValuesAffectingValueForKey:key]; &#125; return result;&#125; 还记得之前在 _addObserver 方法中有这段代码吗？ 12//属性添加后递归添加关联属性[property object:self didAddObservance:newInfo recurse:true]; 其中 NSKeyValueProperty 也是一个类簇，具体分为 NSKeyValueProperty NSKeyValueComputedProperty NSKeyValueUnnestedProperty NSKeyValueNestedProperty，从名字也看出 NSKeyValueNestedProperty 是指嵌套子属性的属性类，那我们观察下他的实现。 1234567891011121314//伪代码- (void)object:(id)obj didAddObservance:(id)info recurse:(BOOL)isRecurse &#123; if (self-&gt;_isAllowedToResultInForwarding != nil) &#123; //获得关系键 relateObj = [obj valueForKey:self-&gt;_relationshipKey]; //注册所有关系通知 [relateObj addObserver:info forKeyPath:self-&gt;_keyPathFromRelatedObject options:info-&gt;options context:nil]; &#125; //再往下递归 [self-&gt;_relationshipProperty object:obj didAddObservance:info recurse:isRecurse];&#125; 至此，实现的大致整体轮廓比较了解了，下面会讲一下怎么把原理运用到实际。 应用原理手动触发当 +(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key 返回是 YES，那么注册的这个 Key 就会替换对应的 Setter ，从而在改变的时候调用 -(void)willChangeValueForKey:(NSString *)key 与 -(void)didChangeValueForKey:(NSString *)key 发送通知给观察者。 那么只要把自动通知设为 NO，并代码实现这两个通知方法，就可以达到手动触发的要求。 123456789101112131415+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123; if ([key isEqualToString:@\"object\"]) &#123; return false; &#125; return [super automaticallyNotifiesObserversForKey:key];&#125;- (void)setObject:(NSObject *)object &#123; if (object != _object) &#123; [self willChangeValueForKey:@\"object\"]; _object = object; [self didChangeValueForKey:@\"object\"]; &#125;&#125; 如果操作的是之前提到的集合对象，那么实现的方法就需要变为 12345678910111213- (void)willChange:(NSKeyValueChange)changeKind valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key;- (void)didChange:(NSKeyValueChange)changeKind valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key;- (void)willChangeValueForKey:(NSString *)key withSetMutation:(NSKeyValueSetMutationKind)mutationKind usingObjects:(NSSet *)objects;- (void)didChangeValueForKey:(NSString *)key withSetMutation:(NSKeyValueSetMutationKind)mutationKind usingObjects:(NSSet *)objects; 依赖键观察之前也有提过构建依赖关系的方法，具体操作如下 12345678910111213141516171819202122232425262728+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123; if ([key isEqualToString:@\"color\"]) &#123; return [NSSet setWithObjects:@\"r\",@\"g\",@\"b\",@\"a\",nil]; &#125; return [super keyPathsForValuesAffectingValueForKey:key];&#125;//建议使用静态指针地址作为上下文区分不同的观察static void * const kColorContext = (void*)&amp;kColorContext;- (void)viewDidLoad &#123; [super viewDidLoad]; [self addObserver:self forKeyPath:@\"color\" options:NSKeyValueObservingOptionNew context:kColorContext]; self.r = 133;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; if (context == kColorContext) &#123; NSLog(@\"%@\", keyPath); //outprint --&gt; color &#125;&#125; 可变数组与集合不可变的数组与集合由于内部结构固定，所以只能通过观察容器类内存地址来判断是否变化，也就是 NSKeyValueChangeSetting。 集合和数组的观察都很类似，我们先关注如果要观察可变数组内部插入移除的变化呢？ 先了解一下集合代理方法，- (NSMutableArray *)mutableArrayValueForKey:，这是一个 KVC 方法，能够返回一个可供观察的 NSKeyValueArray 对象。 根据苹果注释，其搜索顺序如下 1.搜索是否实现最少一个插入与一个删除方法1234-insertObject:in&lt;Key&gt;AtIndex:-removeObjectFrom&lt;Key&gt;AtIndex:-insert&lt;Key&gt;:atIndexes:-remove&lt;Key&gt;AtIndexes: 2.否则搜索是否有 set&lt;Key&gt;: 方法，有的话每次都把修改数组重新赋值回原属性。 3.否则检查 + (BOOL)accessInstanceVariablesDirectly，如果是YES，就查找成员变量_&lt;key&gt; or &lt;key&gt;，此后所有的操作针对代理都转接给成员变量执行。 4.最后进入保护方法valueForUndefinedKey: 第一种方法1234567891011121314151617- (void)insertObject:(NSObject *)object inDataArrayAtIndex:(NSUInteger)index &#123; [_dataArray insertObject:object atIndex:index];&#125;- (void)removeObjectFromDataArrayAtIndex:(NSUInteger)index &#123; [_dataArray removeObjectAtIndex:index];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; _dataArray = @[].mutableCopy; [self addObserver:self forKeyPath:@\"dataArray\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld | NSKeyValueObservingOptionPrior context:nil]; [self insertObject:@1 inDataArrayAtIndex:0];&#125; 通过实现了insert与remove方法，使得代理数组能够正常运作数组变量，KVO 观察了代理数组的这两个方法，发出了我们需要的通知。 这种方式使用了第一步搜索，比较容易理解，缺点是改动的代码比较多，改动数组必须通过自定义方法。 第二种方法1234567891011121314151617@property (nonatomic, strong, readonly) NSMutableArray *dataArray;@synthesize dataArray = _dataArray;- (NSMutableArray *)dataArray &#123; return [self mutableArrayValueForKey:@\"dataArray\"];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; _dataArray = @[].mutableCopy; [self addObserver:self forKeyPath:@\"dataArray\" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld | NSKeyValueObservingOptionPrior context:nil]; [self.dataArray addObject:@1];&#125; 这种方式相对来说更简洁，修改数组的方法与平时一致，比较适合使用。 下面说一下原理，首先我们没有实现对应的insert与remove方法，其次readonly属性也没有set&lt;key&gt;:方法，但我们实现了 @synthesize dataArray = _dataArray; 所以根据第三步对代理数组的操作都会实际操作到实例变量中。 然后重载了 dataArray 的 Getter 方法，保证了修改数组时必须调用主体是self.dataArray，也就是代理数组，从而发送通知。 问答KVO的底层实现？KVO 就是通过 Runtime 替换被观察类的 Setter 实现，从而在发生改变时发起通知。 如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？通过设置 automaticallyNotifiesObserversForKey 为 False 实现取消自动触发。 符合条件再触发可以这么实现。 123456789101112- (void)setObject:(NSObject *)object &#123; if (object == _object) return; BOOL needNotify = [object isKindOfClass:[NSString class]]; if (needNotify) &#123; [self willChangeValueForKey:@\"object\"]; &#125; _object = object; if (needNotify) &#123; [self didChangeValueForKey:@\"object\"]; &#125;&#125; 总结由于对汇编语言、反编译工具、objc4开源代码的不熟悉，这篇文章写了一周时间，结构也有点混乱。 所幸还是理顺了整体结构，在整理的过程中学会了很多很多。 由于才疏学浅，其中对汇编和源码的解释难免出错，还望大佬多多指教！ 资料分享ObjC中国的期刊 KVC和KVO 杨大牛的 Objective-C中的KVC和KVO iOS开发技巧系列—详解KVC(我告诉你KVC的一切)","categories":[{"name":"iOS","slug":"iOS","permalink":"https://vanchchen.github.io/categories/iOS/"}],"tags":[{"name":"原理分析","slug":"原理分析","permalink":"https://vanchchen.github.io/tags/原理分析/"}]},{"title":"脚本处理iOS的Crash日志","slug":"脚本解析Crash","date":"2018-10-08T08:06:38.000Z","updated":"2018-12-07T06:16:41.187Z","comments":true,"path":"p/2616.html","link":"","permalink":"https://vanchchen.github.io/p/2616.html","excerpt":"","text":"背景当我们打包app时，可以选择生成对应的符号表，其保存 16 进制函数地址映射信息，通过给定的函数起始地址和偏移量，可以对应函数具体信息以供分析。 所以我们拿到测试给的闪退日志(.crash)时，需要找到打包时对应生成的符号表(.dSYM)作为钥匙解析。具体分为下面几个步骤 dwarfdump --uuid 命令获取 .dSYM 的 uuid 打开 .crash 文件，在特定位置找到 uuid 根据 arm 版本比对两者是否一致 到 Xcode 目录下寻找 symbolicatecrash 工具 不同版本文件路径不同，具体版本请谷歌。Xcode9路径是/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/ 设置终端环境变量 export DEVELOPER_DIR=&quot;/Applications/Xcode.app/Contents/Developer&quot; 使用 symbolicatecrash 工具解析日志 symbolicatecrash .crash .dsym &gt; a.out 虽然过程不复杂，但是每次都需要手动执行一次检查与命令，过于繁琐，所以决定用脚本化提高效率。 步骤实现输入Crash日志123#要求输入crash文件路径inputFile 'Please Input Crash File' 'crash'crashPath=$filePath 由于需要输入两种不同后缀的文件路径，且都需要检查，因此统一定义一个方法。123456789101112131415161718#定义全局变量filePath=#输入文件路径inputFile() &#123; readSuccess=false #首先清空变量值 filePath= while [ $readSuccess = false ]; do echo $1 #读取到变量中 read -a filePath if [[ ! -e $filePath || $&#123;filePath##*.&#125; != $2 ]]; then echo \"Input file is not .\"$2 else readSuccess=true fi done&#125; .dSYM 是文件夹路径，所以这里简单的判断了路径是否存在，如果不存在就继续让用户输入。 Shell命令中判断分为[]与[[]]，后者比前者更通用，可以使用 || 正则运算等。 判断中，-f表示检查是否存在该文件，-d表示检查是否存在文件夹，-e表示检查是否存在该路径 输入dSYM符号表1234567891011121314dsymSuccess=falsewhile [ $dsymSuccess = false ]; do #要求输入dSYM文件路径 inputFile 'Please Input dSYM File' 'dSYM' dsymPath=$filePath #检查是否匹配 checkUUID \"$crashPath\" \"$dsymPath\" match=$? if [ $match -eq 0 ]; then echo 'UUID not match!' else dsymSuccess=true fidone 循环获取匹配 UUID 的 dSYM ，这里使用了另一种方法获取方法返回值，具体之后章节会总结。 查找symbolicatecrash工具在 Xcode 文件夹指定路径下查找工具，加快效率，如果没找到就停止运行。 123456# 查找symbolicatecrash解析工具，内置在Xcode的库文件中toolPath=`find /Applications/Xcode.app/Contents/SharedFrameworks -name symbolicatecrash | head -n 1`if [ ! -f $toolPath ]; then echo \"Symbolicatecrash not exist!\" exit 0fi 执行解析命令1234567#先设置环境变量export DEVELOPER_DIR=\"/Applications/Xcode.app/Contents/Developer\"#指定解析结果路径crashName=`basename $crashPath`afterPath=\"$(dirname \"$crashPath\")\"/\"$&#123;crashName%%.*&#125;\"\"_after.crash\"#开始解析$toolPath \"$crashPath\" \"$dsymPath\" &gt; \"$afterPath\" 2&gt; /dev/null 这里我将错误信息导流到 /dev/null，保证解析文件没有杂乱信息。 遇到的问题怎么获取函数返回值？之前没有处理过需要返回数值的方法，所以一开始有点懵，查询资料后最终采用了两种方式实现了效果，现在做一些总结。 全局变量记录12345678#定义全局变量filePath=inputFile() &#123; #读取到变量中 read -a filePath&#125;inputFilecrashPath=$filePath 通过 inputFile 方法来了解一下，首先定义一个全局变量为 filePath，在方法中重新赋值，方法结束后读取全局变量中的数据。 这种方法的好处是可以自定义返回参数类型和个数，缺点是容易和其他变量搞混。 Return返回值类似与C语言中的用法，脚本也支持 retrun 0 返回结果并停止运行。 123456789checkUUID() &#123; grep \"$arm64id\" \"$1\" if [ $? -ne 0 ]; then return 1; fi return 0;&#125;checkUUID \"$crashPath\" \"$dsymPath\"match=$? 获取结果的方式为 $?，其能够返回环境中最后一个指令结果，也就是之前执行的checkUUID的结果。 优点是简洁明了，符合编码习惯，缺点是返回值只能是 0-255 的数字，不能返回其他类型的数据。 获取打印值还有一种方法其实平时一直在使用，只不过并不了解其运行方式。123456crashName=`basename $crashPath`print() &#123; echo \"Hello World\"&#125;text=$(print) 运行系统预设的方法或者自定义方法，将执行命令用 $() 的方式使用，就可以获取该命令中所有打印的信息，赋值到变量就可以拿到需要的返回值。 优点是功能全效率高，使用字符串的方式可以传递定制化信息，缺点是不可预期返回结果，需要通过字符串查找等命令辅助。 循环输入合法路径在我的设想中，需要用户输入匹配的 dSYM 文件路径，如果不匹配，则重新输入，直到合法。为了支持嵌套，需要定义局部变量控制循环，具体代码如下1234567891011121314dsymSuccess=falsewhile [ $dsymSuccess = false ]; do #要求输入dSYM文件路径 inputFile 'Please Input dSYM File' 'dSYM' dsymPath=$filePath #检查是否匹配 checkUUID \"$crashPath\" \"$dsymPath\" match=$? if [ $match -eq 0 ]; then echo 'UUID not match!' else dsymSuccess=true fidone 处理字符串获取到 UUID 所有输出信息后，需要截取出对应平台的信息，处理还是不太熟悉，特地整理如下1234567891011121314151617#原始信息UUID: 92E495AA-C2D4-3E9F-A759-A50AAEF446CD (armv7) /Volumes/.dSYM/Contents/Resources/DWARF/appUUID: 536527A8-0243-34DB-AE08-F1F64ACA4351 (arm64) /Volumes/.dSYM/Contents/Resources/DWARF/app#去除中间间隔-uuid=$&#123;uuid//-/&#125;#从后往前找第一个匹配 \\(arm64的，并且都删除arm64id=$&#123;uuid% \\(arm64*&#125;#处理后UUID: 92E495AAC2D43E9FA759A50AAEF446CD (armv7) /Volumes/.dSYM/Contents/Resources/DWARF/appUUID: 536527A8024334DBAE08F1F64ACA4351#从前往后找最后一个UUID: ，并删除arm64id=$&#123;arm64id##*UUID: &#125;#处理后 536527A8024334DBAE08F1F64ACA4351 总结看似简单的脚本，也花了一天时间编写，总体还是不太熟练，仍需努力联系。 这次特地尝试了与上次不同的参数输入方法，使用提示输入的方式，果然遇到了新的问题。好在都查资料解决了，结果还算满意。 脚本我提交到了Github，欢迎大家指教共同进步！给个关注最好啦～","categories":[{"name":"Shell","slug":"Shell","permalink":"https://vanchchen.github.io/categories/Shell/"}],"tags":[{"name":"效率工具","slug":"效率工具","permalink":"https://vanchchen.github.io/tags/效率工具/"}]},{"title":"AssociatedObject关联对象原理实现","slug":"AssociatedObject原理实现","date":"2018-09-29T09:55:21.000Z","updated":"2018-10-16T01:15:41.975Z","comments":true,"path":"p/f39e.html","link":"","permalink":"https://vanchchen.github.io/p/f39e.html","excerpt":"","text":"介绍关联对象（AssociatedObject）是Objective-C 2.0运行时的一个特性，允许开发者对已经存在的类在扩展中添加自定义的属性。在实际生产过程中，比较常用的方式是给分类（Category）添加成员变量。 例子1234567891011121314151617181920#import &lt;objc/runtime.h&gt;@interface NSObject (AssociatedObject)@property (nonatomic, strong) id property;@end@implementation NSObject (AssociatedObject)@dynamic property;- (id)property &#123; return objc_getAssociatedObject(self, _cmd);&#125;- (void)setProperty:(NSString *)property &#123; objc_setAssociatedObject(self, @selector(property), property, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 通过实现代码可以稍微分析下，objc_getAssociatedObject 拿着不变的指针地址（示例传入selector作为参数，实际是void*），从实例中获取需要的对象。objc_setAssociatedObject 根据传入的参数协议，保存指定的对象。 参数协议1234567typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */ OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. The association is not made atomically. */ OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. The association is not made atomically. */ OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object. The association is made atomically. */ OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied. The association is made atomically. */&#125;; 其实这五个协议就是我们平时定义属性时使用的，需要注意的是，虽然苹果在注释中说 OBJC_ASSOCIATION_ASSIGN 相当于一个 weak reference，但其实等于 assign/unsafe_unretained。 对于与weak的区别不在本文讨论范围内，浅显的区别在于变量释放后，weak 会把引用置空，unsafe_unretained会保留内存地址，一旦获取可能会野指针闪退。 总结我们知道，如果类要添加变量，只有在objc_allocateClassPair与objc_registerClassPair之间addIvar。等类注册后，变量结构就不允许再被改变，这是为了防止两个相同类的实例拥有不同变量导致运行困惑。 那么在runtime时给实例添加变量，又不改变类内部变量结构，关联对象就是一个比较好的做法。 关联对象的实现外部方法12345678//Sets an associated value for a given object using a given key and association policy.void objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy);//Returns the value associated with a given object for a given key.id objc_getAssociatedObject(id object, const void * key);//Removes all associations for a given object.void objc_removeAssociatedObjects(id object); 相比刚刚例子中的用法，多了一个objc_removeAssociatedObjects，那么可不可以用这个方法来删除不用的关联对象呢？ 苹果的文档中解释说这个方法主要用来还原对象到类初始的状态，会移除所有的关联，包括其他模块添加的，因此应该用 objc_setAssociatedObject(..,nil,..) 的方式去卸载。 Setter实现objc_setAssociatedObject实际调用的是_object_set_associative_reference 1234567891011121314151617181920212223242526272829303132333435363738394041424344void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) &#123; // break any existing association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); &#125; &#125; else &#123; // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125; &#125; &#125; &#125; // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 内存管理12345678910111213141516171819202122static id acquireValue(id value, uintptr_t policy) &#123; switch (policy &amp; 0xFF) &#123; case OBJC_ASSOCIATION_SETTER_RETAIN: return objc_retain(value); case OBJC_ASSOCIATION_SETTER_COPY: return ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy); &#125; return value;&#125;static void releaseValue(id value, uintptr_t policy) &#123; if (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123; return objc_release(value); &#125;&#125;ObjcAssociation old_association(0, nil);id new_value = value ? acquireValue(value, policy) : nil;&#123; old_association = ...&#125;if (old_association.hasValue()) ReleaseValue()(old_association); 我们摘出与对象内存相关的代码仔细分析下，首先把新传入的对象，根据协议进行retain/copy，在赋值的过程中获取旧值，在方法结束前release。 赋值1234567891011121314151617181920212223242526AssociationsManager manager;AssociationsHashMap &amp;associations(manager.associations());disguised_ptr_t disguised_object = DISGUISE(object);if (new_value) &#123; //需要赋值 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; //找到了这个对象的关联表 ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; //找到了这个key的关联对象 old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; //没找到，新增一个关联 (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; //没找到，创建一个新的关联表 ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); &#125;&#125; 先了解一下AssociationsManager与AssociationsHashMap12345678910111213class AssociationsManager &#123; static AssociationsHashMap *_map;public: AssociationsHashMap &amp;associations() &#123; if (_map == NULL) _map = new AssociationsHashMap(); return *_map; &#125;&#125;;class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt;;class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt;； AssociationsManager通过一个以指针地址为主键，值为关联表的哈希表，来管理应用内所有的关联对象。 首先以对象的指针地址去寻找关联表，再通过指定的键值查找关联关系，从而获取关联对象。 删除123456789AssociationsHashMap::iterator i = associations.find(disguised_object);if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125;&#125; 和修改方法类似，找到关联关系后，执行哈希表的erase方法删除。 Getter实现objc_getAssociatedObject实际调用的是_object_get_associative_reference 1234567891011121314151617181920212223242526id _object_get_associative_reference(id object, void *key) &#123; id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123; objc_retain(value); &#125; &#125; &#125; &#125; if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123; objc_autorelease(value); &#125; return value;&#125; 查找哈希表的方法和Setter一样，区别在于如果策略中需要retain和autorelease的话，都需要处理。那么是怎么约定这些策略呢？ 12345678910111213141516enum &#123; OBJC_ASSOCIATION_SETTER_ASSIGN = 0, OBJC_ASSOCIATION_SETTER_RETAIN = 1, OBJC_ASSOCIATION_SETTER_COPY = 3, // NOTE: both bits are set, so we can simply test 1 bit in releaseValue below. OBJC_ASSOCIATION_GETTER_READ = (0 &lt;&lt; 8), OBJC_ASSOCIATION_GETTER_RETAIN = (1 &lt;&lt; 8), OBJC_ASSOCIATION_GETTER_AUTORELEASE = (2 &lt;&lt; 8)&#125;; typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, OBJC_ASSOCIATION_COPY_NONATOMIC = 3, OBJC_ASSOCIATION_RETAIN = 01401, OBJC_ASSOCIATION_COPY = 01403&#125;; OBJC_ASSOCIATION_RETAIN = 01401，其中01401开头是0，所以是八进制数字，翻译为二进制就是0000 0011 0000 0001，取位判断就是OBJC_ASSOCIATION_SETTER_RETAIN OBJC_ASSOCIATION_GETTER_RETAIN OBJC_ASSOCIATION_GETTER_AUTORELEASE。 在保存的时候，需要retain，在获取的时候，需要先retain增加引用计数，再执行autorelease等待释放，从而实现原子性。 Remove实现objc_removeAssociatedObjects会判断对象是否存在关联，然后再执行_object_set_associative_reference12345678910111213141516171819202122void _object_remove_assocations(id object) &#123; vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); if (associations.size() == 0) return; disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i-&gt;second; for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123; elements.push_back(j-&gt;second); &#125; // remove the secondary table. delete refs; associations.erase(i); &#125; &#125; // the calls to releaseValue() happen outside of the lock. for_each(elements.begin(), elements.end(), ReleaseValue());&#125; 实现方式也可以看出为什么在介绍里不推荐使用，因为会遍历所有的关联对象，并且全部释放，可能会造成别的模块功能缺陷。 判断关联对象比较有意思的是判断对象是否有关联对象的实现。 123456inline bool objc_object::hasAssociatedObjects()&#123; if (isTaggedPointer()) return true; if (isa.nonpointer) return isa.has_assoc; return true;&#125; 1234567891011121314inline void objc_object::setHasAssociatedObjects()&#123; if (isTaggedPointer()) return; retry: isa_t oldisa = LoadExclusive(&amp;isa.bits); isa_t newisa = oldisa; if (!newisa.nonpointer || newisa.has_assoc) &#123; ClearExclusive(&amp;isa.bits); return; &#125; newisa.has_assoc = true; if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;&#125; 默认返回的结果都是true，只有在64位系统下，才保存一个标记位。这么处理我推测是为了加快释放周期速度，在析构对象时，会根据这个方法判断是否需要释放关联对象。试想如果每次都查询哈希表，执行效率必定会降低，不如都先通过，之后再做处理。 关于nonpointer不在本文介绍范围内，简单描述为在64位系统下，指针地址保存不仅仅为内存地址，还存有其他标记信息，包括本文涉及的has_assoc。 taggedPointer是一种优化策略，把简单的数字或字符串信息直接保存在指针地址中，从而不申请额外内存加快运行效率。 总结关联对象的实现不复杂，保存的方式为一个全局的哈希表，存取都通过查询表找到关联来执行。哈希表的特点就是牺牲空间换取时间，所以执行速度也可以保证。 问答关联对象有什么应用？关联对象可以在运行时给指定对象绑定一个有生命周期的变量。 1.由于不改变原类的实现，所以可以给原生类或者是打包的库进行扩展，一般配合Category实现完整的功能。 2.ObjC类定义的变量，由于runtime的特性，都会暴露到外部，使用关联对象可以隐藏关键变量，保证安全。 3.可以用于KVO，使用关联对象作为观察者，可以避免观察自身导致循环。 系统如何管理关联对象？系统通过管理一个全局哈希表，通过对象指针地址和传递的固定参数地址来获取关联对象。根据setter传入的参数协议，来管理对象的生命周期。 其被释放的时候需要手动将其指针置空么？当对象被释放时，如果设置的协议是OBJC_ASSOCIATION_ASSIGN，那么他的关联对象不会减少引用计数，其他的协议都会减少从而释放关联对象。 unsafe_unretain一般认为外部有对象控制，所以对象不用处理，因此不管什么协议，对象释放时都无需手动讲关联对象置空。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://vanchchen.github.io/categories/iOS/"}],"tags":[{"name":"原理分析","slug":"原理分析","permalink":"https://vanchchen.github.io/tags/原理分析/"}]},{"title":"初试Shell脚本","slug":"初试Shell脚本","date":"2018-09-20T08:45:12.000Z","updated":"2018-12-07T06:16:35.757Z","comments":true,"path":"p/3f22.html","link":"","permalink":"https://vanchchen.github.io/p/3f22.html","excerpt":"","text":"背景临上线前测试比较努力，遇到闪退或者其他问题，会把日志包打给我，由于app内存限制，目前每次打包都是1m大小，所以有时查找问题的上下文比较吃力。同时由于日志比较多，根据关键词过滤的需求越来越重要。 于是决定学写脚本完成这个任务，根据我的要求，工作流程应该是传入压缩包，根据后缀名解压，根据日期排序后合并成一个文件，按需过滤关键词。 先上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#!/usr/bin/env bash# Created By Vanch at 2018/9/20printHelp() &#123; echo \"Uncompess log files from inputed zip\" echo \"Then Merge these logs to one file\" echo \"Supported file types: zip tar tar.gz tar.bz2\" echo echo \"Use -s for filtering socket result to socket.log\" echo echo \"Have fun!\"&#125;#如果没输入参数，就打印帮助信息if [ $# -eq 0 ]; then printHelp exit 0fi#把长选项转到短选项for arg in \"$@\"; do shift case \"$arg\" in \"--help\") set -- \"$@\" \"-h\" ;; \"--version\") set -- \"$@\" \"-v\" ;; \"--list\") set -- \"$@\" \"-l\" ;; *) set -- \"$@\" \"$arg\" esacdone#获取短选项OPTIND=1printS=false;while getopts \"dmksahvl\" opt; do case $opt in h) #输入为help，就打印帮助信息 printHelp exit 0;; l) #支持单独获取支持文件后缀列表 echo \"Supported file types: zip tar tar.gz tar.bz2\" exit 0;; v) #支持查找版本号 echo \"1.0.0\" exit 0;; s) #过滤Socket printS=true;; esacdone#获得压缩包地址file=$&#123;!#&#125;#如果不存在就退出if [ ! -f \"$file\" ]; then echo \"File not exist!\" exit 0;fi #获取压缩后缀fileName=`basename $file`suffix=$&#123;fileName#*.&#125;#判断文件类型support=('tar','tar.gz','tar.bz2','zip')if [ -z `echo \"$&#123;support[@]&#125;\" | grep -w \"$suffix\"` ] ; then echo \"File type not support!\" exit 0; fi#拼接文件夹地址fileDir=$(dirname $file)/$&#123;fileName%%.*&#125;if [ -d $fileDir ]; then rm -rf $fileDirfimkdir $fileDircd $fileDir#解压文件case $suffix in 'tar') eval \"tar xvf $file &gt; /dev/null 2&gt;&amp;1\";; 'tar.gz') eval \"tar zxvf $file &gt; /dev/null 2&gt;&amp;1\";; 'tar.bz2') eval \"tar jxvf $file &gt; /dev/null 2&gt;&amp;1\";; 'zip') eval \"unzip -o $file &gt; /dev/null 2&gt;&amp;1\";;esacecho 'Uncompass Success!'#获取日志列表，按排序合并到一个日志mergeFile=./merge.loglogCount=0#搜索com开头的日志，按日期排序，用？临时代替空格for logName in `ls | grep 'com' | sort -n | tr \" \" \"?\"`; do logName=$&#123;logName//'?'/' '&#125; cat ./\"$logName\" &gt;&gt; $mergeFile ((logCount++))done#不存在日志就打断if [ $logCount -eq 0 ]; then echo \"Log not exist!\" exit fiecho 'Merge Success!'#打印socketif [ $printS = true ]; then cat $mergeFile | grep -i 'socket' &gt;&gt; ./socket.log echo 'Filter socket'fi 遇到的问题查询了很多资料后写完了这个脚本，基本满足了我的需求，下面总结一下怎么解决遇到的问题。 使用环境一开始学脚本时，书上都说#! /bin/bash，但是看项目中大神写的脚本，都是#!/usr/bin/env bash，有什么区别呢？ 脚本用env启动的原因，是因为脚本解释器在linux中可能被安装于不同的目录，env可以在系统的PATH目录中查找。同时，env还规定一些系统环境变量。 不同的系统，解释器的路径可能也不同，所以使用绝对路径是比较危险的方式。通过从环境中查找，可以保证兼容性。 获取选项开发中我们经常用到命令，这些命令一般都配合选项达到不同的效果，比如最常用的ls -al，通过-a来指定结果包含隐藏文件，通过-l达到列表显示的效果。 通过查询相关资料，我发现获取选项普遍的做法是使用getopts命令，但是这个方法只能获取-h这种短选项，对于--help长选项就不行。 第一种办法是换成getopt命令，但是并不是每个系统都支持这个命令。具体使用和getopts类似，比如getopt -o ab:c -l a-long:b-long 第二种方法是把支持的长命令转成短命令，我使用的就是这种方式，相对来说比较容易理解，且case写的比较统一。通过shift取出参数，再set --的方式重写，最后OPTIND=1把指针指回第一个选项。 文件路径和文件后缀按需求需要判断后缀名来解压，那么就需要判断tar.gz之类的问题。同时，如果传入的文件目录是隐藏目录，也会造成一定的障碍。我们假设传入文件路径为/a/.b/c.tar.gz。 ${param#pattern} 从param前面删除pattern的最小匹配${param##pattern} 从param前面删除pattern的最大匹配${param%pattern} 从param后面删除pattern的最小匹配${param%%pattern} 从param后面删除pattern的最大匹配 如果按照${fileName##*.}来截取，那么只能拿到gz。如果按照${fileName#*.}来截取，拿到的又是b/c.tar.gz。那怎么办呢？ 好在有dirname可以直接获取文件路径，basename拿到文件名，单独对文件名进行${fileName#*.}就可以拿到tar.gz了。 去除不必要的打印执行解压命令时，会打印解压步骤，一般来说也需要显示，那如果我们不想要打印出来呢？有一个办法就是在命令之后加上&gt; /dev/null 2&gt;&amp;1 /dev/null ：代表空设备文件 > ：代表重定向到哪里，例如：echo “123” &gt; /home/123.txt 1 ：表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null” 2 ：表示stderr标准错误 &amp; ：表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 所以含义就是把命令输出结果和错误输出重定向，使得输出不在当前屏幕显示，由于null比较特殊，向这个文件输入等于进入黑洞，因此达到效果。 数组与空格使用ls | grep的方式来过滤结果获取文件名数组的最大问题是，如果文件名包含空格，那么前后会被分割成两个单元，导致处理比较困难。 比较讨巧的方法是临时用特殊符号代替空格，在使用时再替换回来。这种方法不会改变文件名，也不用写复杂的数组合并，比较符合简单的设计。 12tr \" \" \"?\"$&#123;logName//'?'/' '&#125; 总结通过这次简单的脚本实验，对shell有了新的认识，及时记录遇到的问题，相信下次会更有印象。使用脚本，可以让工作更有效率，相信以后也会越用越多。","categories":[{"name":"Shell","slug":"Shell","permalink":"https://vanchchen.github.io/categories/Shell/"}],"tags":[{"name":"效率工具","slug":"效率工具","permalink":"https://vanchchen.github.io/tags/效率工具/"}]},{"title":"Category探索","slug":"Category探索","date":"2018-09-17T07:29:29.000Z","updated":"2018-10-16T01:15:41.976Z","comments":true,"path":"p/5cb0.html","link":"","permalink":"https://vanchchen.github.io/p/5cb0.html","excerpt":"","text":"什么是Category?Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已经存在的类添加方法，一般称为分类，文件名格式是”NSObject+A.h”。 123456789struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; struct property_list_t *_classProperties;&#125; 从结构能看出分类可以扩展实例方法列表、类方法列表、协议列表，也支持扩展属性，但不支持扩展成员变量（之后会说）。 一般使用的场景有扩展现有类方法、代码分区、添加私有方法（不对外暴露category.h）、模拟多继承（使用关联对象的方式添加属性实现） 什么是Extension？Extension一般被称为类扩展、匿名分类，用于定义私有属性和方法，不可被继承。只能依附自定义类写于.m中，定义一般为: 12345@interface ViewController ()@property (nonatomic, strong) NSObject *obj;@end 类扩展支持写在多个.h文件，但都必须在.m文件中引用，且不能有自己的实现。 类扩展很多时候会与分类搞混，我在文后问答环节详细整理了他们的区别。 Category如何加载的？1234567891011121314151617181920212223242526struct objc_class : objc_object &#123; Class superclass; class_data_bits_t bits; class_rw_t *data() &#123; return bits.data(); &#125; ...&#125;struct class_rw_t &#123; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; ...&#125;struct class_ro_t &#123; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; //只有ro才有实例变量表 property_list_t *baseProperties; ...&#125;; 先简单了解一下Class对象的结构，每个objc_class都包含有class_data_bits_t数据位，其中储存了class_rw_t的指针地址和一些其他标记。class_rw_t中包含有属性方法协议列表，以及class_ro_t指针地址。而在class_ro_t结构中，储存的是编译器决定的属性方法协议。 那么是怎么运行的呢？在编译期类的结构中的class_data_bits_t指向的是一个 class_ro_t指针。 在运行时调用realizeClass方法，初始化一个class_rw_t结构体，设置ro值为原数据中的class_ro_t后设为数据位中的指向，最后调用methodizeClass方法加载。 12345678910111213141516171819202122232425262728293031static void methodizeClass(Class cls)&#123; auto rw = cls-&gt;data(); auto ro = rw-&gt;ro; //从ro中加载方法表 method_list_t *list = ro-&gt;baseMethods(); if (list) &#123; prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); rw-&gt;methods.attachLists(&amp;list, 1); &#125; //加载属性 property_list_t *proplist = ro-&gt;baseProperties; if (proplist) &#123; rw-&gt;properties.attachLists(&amp;proplist, 1); &#125; //加载协议 protocol_list_t *protolist = ro-&gt;baseProtocols; if (protolist) &#123; rw-&gt;protocols.attachLists(&amp;protolist, 1); &#125; //基类添加初始化方法 if (cls-&gt;isRootMetaclass()) &#123; addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, \"\", NO); &#125; //加载分类 category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/); attachCategories(cls, cats, false /*don't flush caches*/); if (cats) free(cats);&#125; 可以看到，在methodizeClass中加载了原先类在编译期决定的方法属性和协议，然后获取了未连接的分类表，将列表中的扩展方法添加到运行期类中。 Category方法覆盖如果不同的分类实现了相同名字的方法，那么调用时会使用最后加入的实现，这是为什么呢？ 加载Categorydyld链接并初始化二进制文件后，交由ImageLoader读取，接着通知runtime处理，runtime调用map_images解析，然后执行_read_images分析文件中包含的类和分类。 1234567891011121314151617181920212223242526272829303132333435//加载分类category_t **catlist = _getObjc2CategoryList(hi, &amp;count);bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) &#123; //分类指定的类还没加载，可能是链接库顺序的问题 catlist[i] = nil; continue; &#125; //添加分类到类的分类表中，伺机重载入 bool classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) &#123; remethodizeClass(cls); classExists = YES; &#125; &#125; //添加分类到元类中 if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123; addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) &#123; remethodizeClass(cls-&gt;ISA()); &#125; &#125;&#125; 添加方法属性和协议如果有新增的分类，就分别添加到原类和meta类，并通过remethodizeClass更新，具体就是调用attachCategories方法把分类中所有的方法都添加到指定类中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; bool isMeta = cls-&gt;isMetaClass(); //新建数组指针 method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); int mcount = 0; int propcount = 0; int protocount = 0; int i = cats-&gt;count;//倒序获取最新的分类 bool fromBundle = NO; while (i--) &#123; auto&amp; entry = cats-&gt;list[i]; //分别获取列表 method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; auto rw = cls-&gt;data(); //加载列表到rw中 prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; 123456789101112131415161718192021222324252627282930void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; &#125; 可以看到最后调用了rw-&gt;methods.attachLists(mlists, mcount); 把新增分类中的方法列表添加到实际运行时查询的方法列表头部。 在进行方法调用时会从头部查询，一旦查到后就返回结果，因此后编译的文件中的方法会被优先调用。 同时之前添加的方法实现也保存了，可以通过获取同名方法的方式查找原类的实现。 Category实现属性分类不能添加成员变量属性（Property）包含了成员变量（Ivar）和Setter&amp;Getter。 可以在分类中定义属性，但由于分类是在运行时添加分类属性到类的属性列表中，所以并没有创建对应的成员变量和方法实现。 关联对象如果我们想让分类实现添加新的属性，一般都通过关联对象的方式。12345678910111213141516171819// 声明文件@interface TestObject (Category)@property (nonatomic, strong) NSObject *object;@end// 实现文件static void *const kAssociatedObjectKey = (void *)&amp;kAssociatedObjectKey;@implementation TestObject (Category)- (NSObject *)object &#123; return objc_getAssociatedObject(self, kAssociatedObjectKey);&#125;- (void)setObject:(NSObject *)object &#123; objc_setAssociatedObject(self, kAssociatedObjectKey, object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 这种方式可以实现存取对象，但是不能获取_object变量。 问答分类和扩展有什么区别？1.分类多用于扩展方法实现，类扩展多用于申明私有变量和方法。 2.类扩展作用在编译期，直接和原类在一起，而分类作用在运行时，加载类的时候动态添加到原类中。 3.类扩展可以定义属性，分类中定义的属性只会申明setter/getter，并没有相关实现和变量。 分类有哪些局限性？1.分类只能给现有的类加方法或协议，不能添加实例变量（ivar）。 2.分类添加的方法如果与现有的重名，会覆盖原有方法的实现。如果多个分类方法都重名，则根据编译顺序执行最后一个。 分类的结构体里面有哪些成员？分类结构体包含了分类名，绑定的类，实例与类方法列表，实例与类方法属性以及协议表。 参考深入理解Objective-C：Category 神经病院 Objective-C Runtime 入院第一天—— isa 和 Class 探秘Runtime - 深入剖析Category","categories":[{"name":"iOS","slug":"iOS","permalink":"https://vanchchen.github.io/categories/iOS/"}],"tags":[{"name":"原理分析","slug":"原理分析","permalink":"https://vanchchen.github.io/tags/原理分析/"}]},{"title":"iOS面试题","slug":"iOS面试题","date":"2018-09-14T09:40:01.000Z","updated":"2018-10-16T01:35:44.505Z","comments":true,"path":"p/6ea5.html","link":"","permalink":"https://vanchchen.github.io/p/6ea5.html","excerpt":"","text":"前言本文借鉴整理了iOS高级开发常见的面试题，并且分博客一一分析，希望能和大家一起进步学习。 欢迎大家关注我的 Github👏以及相关博客 简书 博客园 大家的鼓励是我前进的动力😄 iOS基础题 分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？ Category探索 讲一下atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？ 被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？ 关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将其指针置空么？ AssociatedObject关联对象原理实现 KVO的底层实现？如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？ 刨根问底KVO原理 Autoreleasepool所使用的数据结构是什么？AutoreleasePoolPage结构体了解么？ 讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的？为什么对象方法没有保存的对象结构体里，而是保存在类对象的结构体里？ class_ro_t 和 class_rw_t 的区别？ iOS 中内省的几个方法？class方法和objc_getClass方法有什么区别? 在运行时创建类的方法objc_allocateClassPair的方法名尾部为什么是pair（成对的意思）？ 一个int变量被__block修饰与否的区别？\\12. 为什么在block外部使用__weak修饰的同时需要在内部使用__strong修饰？ RunLoop的作用是什么？它的内部工作机制了解么？（最好结合线程和内存管理来说） 哪些场景可以触发离屏渲染？（知道多少说多少） iOS 实战题 AppDelegate如何瘦身？ 反射是什么？可以举出几个应用场景么？（知道多少说多少） 有哪些场景是NSOperation比GCD更容易实现的？（或是NSOperation优于GCD的几点，知道多少说多少） App 启动优化策略？最好结合启动流程来说（main()函数的执行前后都分别说一下，知道多少说多少） App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？（知道多少说多少） 你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？（知道多少说多少） 你知道有哪些情况会导致app卡顿，分别可以用什么方法来避免？（知道多少说多少） 网络题 App 网络层有哪些优化策略？ TCP为什么要三次握手，四次挥手？ 对称加密和非对称加密的区别？分别有哪些算法的实现？ HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么？ HTTPS是如何实现验证身份和验证完整性的？ 如何用Charles抓HTTPS的包？其中原理和流程是什么？ 什么是中间人攻击？如何避免？ 计算机系统题 了解编译的过程么？分为哪几个步骤？ 静态链接了解么？静态库和动态库的区别？ 内存的几大区域，各自的职能分别是什么？ static和const有什么区别？ 了解内联函数么？ 什么时候会出现死锁？如何避免？ 说一说你对线程安全的理解？ 列举你知道的线程同步策略？ 有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说 设计模式题 除了单例，观察者设计模式以外，还知道哪些设计模式？分别介绍一下 最喜欢哪个设计模式？为什么？ iOS SDK 里面有哪些设计模式的实践？ **设计模式是为了解决什么问题的？ **设计模式的成员构成以及工作机制是什么？ **设计模式的优缺点是什么？ 架构 &amp; 设计题 MVC和MVVM的区别？MVVM和MVP的区别？ 面向对象的几个设计原则了解么？最好可以结合场景来说。 可以说几个重构的技巧么？你觉得重构适合什么时候来做？ 你觉得框架和设计模式的区别是什么？ 看过哪些第三方框架的源码，它们是怎么设计的？设计好的地方在哪里，不好的地方在哪里，如何改进？（这道题的后三个问题的难度已经很高了，如果不是太N的公司不建议深究） 数据结构&amp;算法题 链表和数组的区别是什么？插入和查询的时间复杂度分别是多少？ 哈希表是如何实现的？如何解决地址冲突？ 排序题：冒泡排序，选择排序，插入排序，快速排序（二路，三路）能写出那些？ 链表题：如何检测链表中是否有环？如何删除链表中等于某个值的所有节点？ 数组题：如何在有序数组中找出和等于给定值的两个元素？如何合并两个有序的数组之后保持有序？ 二叉树题：如何反转二叉树？如何验证两个二叉树是完全相等的？ 引用出一套 iOS 高级面试题","categories":[{"name":"iOS","slug":"iOS","permalink":"https://vanchchen.github.io/categories/iOS/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://vanchchen.github.io/tags/面试/"}]}]}