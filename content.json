{"meta":{"title":"Vanch's Blog","subtitle":null,"description":null,"author":"Vanch","url":"https://vanchchen.github.io"},"pages":[{"title":"","date":"2018-09-14T09:54:31.903Z","updated":"2017-11-07T01:57:43.000Z","comments":true,"path":"404.html","permalink":"https://vanchchen.github.io/404.html","excerpt":"","text":"404"},{"title":"tags","date":"2018-09-14T09:00:14.000Z","updated":"2018-09-14T09:14:24.713Z","comments":false,"path":"tags/index.html","permalink":"https://vanchchen.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-14T09:13:36.000Z","updated":"2018-09-14T09:15:05.482Z","comments":false,"path":"categories/index.html","permalink":"https://vanchchen.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"AssociatedObject关联对象原理实现","slug":"AssociatedObject原理实现","date":"2018-09-29T09:55:21.000Z","updated":"2018-09-29T09:58:35.843Z","comments":true,"path":"2018/09/29/AssociatedObject原理实现/","link":"","permalink":"https://vanchchen.github.io/2018/09/29/AssociatedObject原理实现/","excerpt":"","text":"介绍关联对象（AssociatedObject）是Objective-C 2.0运行时的一个特性，允许开发者对已经存在的类在扩展中添加自定义的属性。在实际生产过程中，比较常用的方式是给分类（Category）添加成员变量。 \b例子1234567891011121314151617181920#import &lt;objc/runtime.h&gt;@interface NSObject (AssociatedObject)@property (nonatomic, strong) id property;@end@implementation NSObject (AssociatedObject)@dynamic property;- (\bid)property &#123; return objc_getAssociatedObject(self, _cmd);&#125;- (void)setProperty:(NSString *)property &#123; objc_setAssociatedObject(self, @selector(property), property, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 通过实现代码可以\b稍微分析下，\bobjc_getAssociatedObject 拿着不变的\b指针地址（示例传入selector作为参数，实际是void*），从\b实例中获取需要的对象。objc_setAssociatedObject 根据传入的参数协议，保存指定的对象。 参数协议1234567typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */ OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. The association is not made atomically. */ OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. The association is not made atomically. */ OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object. The association is made atomically. */ OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied. The association is made atomically. */&#125;; 其实这五个协议就是我们平时定义属性时使用的，需要注意的是，虽然苹果在注释中说 OBJC_ASSOCIATION_ASSIGN 相当于一个 weak reference，但其实\b等于 \bassign/unsafe_unretained。 对于与weak的区别不在本文讨论范围内，\b浅显的区别在于变量释放后，weak 会把引用置空，unsafe_unretained会保留内存地址，\b一旦获取可能会野指针闪退。 总结\b我们知道，如果类要\b添加变量，只有在\bobjc_allocateClassPair与objc_registerClassPair之间addIvar。等类注册后，变量结构就不允许再被改变，这是为了防止两个\b相同类的实例拥有不同变量导致\b运行困惑。 那么在runtime时给实例添加变量，又不改变类内部变量结构，关联对象就是一个比较好的做法。 关联对象的实现外部方法12345678//Sets an associated value for a given object using a given key and association policy.void objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy);//Returns the value associated with a given object for a given key.id objc_getAssociatedObject(id object, const void * key);//Removes all associations for a given object.void objc_removeAssociatedObjects(id object); \b相比刚刚例子中的用法，\b多了一个objc_removeAssociatedObjects，那么可不可以用这个方法来删除不用的关联对象呢？ 苹果的文档中解释说\b这个方法主要用来还原对象到类初始的状态，会移除所有的关联，包括其他模块添加的，因此应该\b用 objc_setAssociatedObject(..,nil,..) 的方式去卸载。 \bSetter实现objc_setAssociatedObject实际调用的是_object_set_associative_reference 1234567891011121314151617181920212223242526272829303132333435363738394041424344void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) &#123; // break any existing association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); &#125; &#125; else &#123; // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125; &#125; &#125; &#125; // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association);&#125; \b内存管理12345678910111213141516171819202122static id acquireValue(id value, uintptr_t policy) &#123; switch (policy &amp; 0xFF) &#123; case OBJC_ASSOCIATION_SETTER_RETAIN: return objc_retain(value); case OBJC_ASSOCIATION_SETTER_COPY: return ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy); &#125; return value;&#125;static void releaseValue(id value, uintptr_t policy) &#123; if (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123; return objc_release(value); &#125;&#125;ObjcAssociation old_association(0, nil);id new_value = value ? acquireValue(value, policy) : nil;&#123; old_association = ...&#125;if (old_association.hasValue()) ReleaseValue()(old_association); 我们摘出与对象\b内存相关的\b代码仔细分析下，首先把新传入的对象，根据协议进行retain/copy，在赋值的过程中获取\b旧值，在方法结束前release。 \b赋值1234567891011121314151617181920212223242526AssociationsManager manager;AssociationsHashMap &amp;associations(manager.associations());disguised_ptr_t disguised_object = DISGUISE(object);if (new_value) &#123; //需要\b赋值 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; //找到了这个对象的关联表 ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; //找到了这个key的关联对象 old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; //没找到，新增一个关联 (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; //没找到，创建一个新的关联表 ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); &#125;&#125; 先了解一下\bAssociationsManager与AssociationsHashMap12345678910111213class AssociationsManager &#123; static AssociationsHashMap *_map;public: AssociationsHashMap &amp;associations() &#123; if (_map == NULL) _map = new AssociationsHashMap(); return *_map; &#125;&#125;;class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt;;class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt;； AssociationsManager通过一个以指针地址为主键，值为关联表的哈希表，来管理应用内所有的关联对象。 首先以对象的指针地址去寻找关联表，再通过指定的\b键值查找关联关系，从而获取关联对象。 删除123456789AssociationsHashMap::iterator i = associations.find(disguised_object);if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125;&#125; 和修改方法类似，找到关联关系后，\b执行哈希表的erase方法删除。 \bGetter实现objc_getAssociatedObject实际调用的是_object_get_associative_reference 1234567891011121314151617181920212223242526id _object_get_associative_reference(id object, void *key) &#123; id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123; objc_retain(value); &#125; &#125; &#125; &#125; if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123; objc_autorelease(value); &#125; return value;&#125; 查找哈希表的方法和Setter一样，区别在于如果策略中需要retain和autorelease的话，\b都需要处理。那么是怎么约定这些策略呢？ 12345678910111213141516enum &#123; OBJC_ASSOCIATION_SETTER_ASSIGN = 0, OBJC_ASSOCIATION_SETTER_RETAIN = 1, OBJC_ASSOCIATION_SETTER_COPY = 3, // NOTE: both bits are set, so we can simply test 1 bit in releaseValue below. OBJC_ASSOCIATION_GETTER_READ = (0 &lt;&lt; 8), OBJC_ASSOCIATION_GETTER_RETAIN = (1 &lt;&lt; 8), OBJC_ASSOCIATION_GETTER_AUTORELEASE = (2 &lt;&lt; 8)&#125;; typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, OBJC_ASSOCIATION_COPY_NONATOMIC = 3, OBJC_ASSOCIATION_RETAIN = 01401, OBJC_ASSOCIATION_COPY = 01403&#125;; \bOBJC_ASSOCIATION_RETAIN = 01401，其中01401开头是0，所以是八进制数字，翻译为二进制就是0000 0011 0000 0001，\b\b取位判断\b就是OBJC_ASSOCIATION_SETTER_RETAIN OBJC_ASSOCIATION_GETTER_RETAIN OBJC_ASSOCIATION_GETTER_AUTORELEASE。 在保存的时候，需要retain，在获取的时候，需要先retain增加引用计数，再执行\bautorelease等待释放，从而实现原子性。 Remove实现objc_removeAssociatedObjects会判断对象是否存在关联，然后再执行_object_set_associative_reference12345678910111213141516171819202122void _object_remove_assocations(id object) &#123; vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); if (associations.size() == 0) return; disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i-&gt;second; for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123; elements.push_back(j-&gt;second); &#125; // remove the secondary table. delete refs; associations.erase(i); &#125; &#125; // the calls to releaseValue() happen outside of the lock. for_each(elements.begin(), elements.end(), ReleaseValue());&#125; 实现方式也可以看出为什么在介绍里不推荐使用，因为会遍历所有的关联对象，并且全部释放，可能会造成别的模块功能缺陷。 判断关联对象比较有意思的是判断对象是否有关联对象的实现。 123456inline bool objc_object::hasAssociatedObjects()&#123; if (isTaggedPointer()) return true; if (isa.nonpointer) return isa.has_assoc; return true;&#125; 1234567891011121314inline void objc_object::setHasAssociatedObjects()&#123; if (isTaggedPointer()) return; retry: isa_t oldisa = LoadExclusive(&amp;isa.bits); isa_t newisa = oldisa; if (!newisa.nonpointer || newisa.has_assoc) &#123; ClearExclusive(&amp;isa.bits); return; &#125; newisa.has_assoc = true; if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;&#125; \b\b默认返回的结果都是true，只有在64位系统下，才保存一个标记位。这么处理我\b推测是为了加快释放周期速度，在\b析构\b对象时，会根据这个方法\b判断是否需要释放关联对象。试想如果每次都查询哈希表，执行效率必定会降低，不如都\b先通过，\b之后再做处理。 \b关于nonpointer不在本文介绍范围内，简单描述为在64位系统下，指针地址保存不仅仅为内存地址，还存有其他\b标记信息，包括本文涉及的\bhas_assoc。 taggedPointer是一种优化\b策略，\b把简单的数字\b或字符串信息直接保存在指针地址中，从而不申请额外内存\b加快运行效率。 \b总结\b关联对象的实现不复杂，\b保存的方式为一个全局的哈希表，存取都通过查询表找到关联来执行。哈希表的特点就是牺牲空间换取时间，所以执行速度也可以保证。","categories":[{"name":"面试","slug":"面试","permalink":"https://vanchchen.github.io/categories/面试/"}],"tags":[]},{"title":"初试Shell脚本","slug":"初试Shell脚本","date":"2018-09-20T08:45:12.000Z","updated":"2018-09-20T10:24:35.981Z","comments":true,"path":"2018/09/20/初试Shell脚本/","link":"","permalink":"https://vanchchen.github.io/2018/09/20/初试Shell脚本/","excerpt":"","text":"背景临上线前\b测试比较努力，遇到闪退或者其他问题，会把日志包打给我，由于app内存限制，目前每次打包都是1m\b大小，所以有时查找问题的上下文比较吃力。同时由于日志比较多，根据关键词过滤的需求越来越重要。 于是决定学写脚本完成这个任务，\b根据我的要求，工作流程应该是传入压缩包，根据后缀名解压，根据日期排序后合并成一个文件，按需过滤关键词。 先上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#!/usr/bin/env bash# Created By Vanch at 2018/9/20printHelp() &#123; echo \"Uncompess log files from inputed zip\" echo \"Then Merge these logs to one file\" echo \"Supported file types: zip tar tar.gz tar.bz2\" echo echo \"Use -s for filtering socket result to socket.log\" echo echo \"Have fun!\"&#125;#如果没输入参数，就打印帮助信息if [ $# -eq 0 ]; then printHelp exit 0fi#把长选项转到短选项for arg in \"$@\"; do shift case \"$arg\" in \"--help\") set -- \"$@\" \"-h\" ;; \"--version\") set -- \"$@\" \"-v\" ;; \"--list\") set -- \"$@\" \"-l\" ;; *) set -- \"$@\" \"$arg\" esacdone#获取短选项OPTIND=1printS=false;while getopts \"dmksahvl\" opt; do case $opt in h) #输入为help，就打印帮助信息 printHelp exit 0;; l) #支持单独获取支持文件后缀列表 echo \"Supported file types: zip tar tar.gz tar.bz2\" exit 0;; v) #支持查找版本号 echo \"1.0.0\" exit 0;; s) #过滤Socket printS=true;; esacdone#获得压缩包地址file=$&#123;!#&#125;#如果不存在就退出if [ ! -f \"$file\" ]; then echo \"File not exist!\" exit 0;fi #获取压缩后缀fileName=`basename $file`suffix=$&#123;fileName#*.&#125;#判断文件类型support=('tar','tar.gz','tar.bz2','zip')if [ -z `echo \"$&#123;support[@]&#125;\" | grep -w \"$suffix\"` ] ; then echo \"File type not support!\" exit 0; fi#拼接文件夹地址fileDir=$(dirname $file)/$&#123;fileName%%.*&#125;if [ -d $fileDir ]; then rm -rf $fileDirfimkdir $fileDircd $fileDir#解压文件case $suffix in 'tar') eval \"tar xvf $file &gt; /dev/null 2&gt;&amp;1\";; 'tar.gz') eval \"tar zxvf $file &gt; /dev/null 2&gt;&amp;1\";; 'tar.bz2') eval \"tar jxvf $file &gt; /dev/null 2&gt;&amp;1\";; 'zip') eval \"unzip -o $file &gt; /dev/null 2&gt;&amp;1\";;esacecho 'Uncompass Success!'#获取日志列表，按排序合并到一个日志mergeFile=./merge.loglogCount=0#搜索com开头的日志，按日期排序，用？临时代替空格for logName in `ls | grep 'com' | sort -n | tr \" \" \"?\"`; do logName=$&#123;logName//'?'/' '&#125; cat ./\"$logName\" &gt;&gt; $mergeFile ((logCount++))done#不存在日志就打断if [ $logCount -eq 0 ]; then echo \"Log not exist!\" exit fiecho 'Merge Success!'#打印socketif [ $printS = true ]; then cat $mergeFile | grep -i 'socket' &gt;&gt; ./socket.log echo 'Filter socket'fi 遇到的问题查询了很多资料后写完了这个脚本，基本满足了我的需求，下面总结一下怎么解决遇到的问题。 使用环境\b一开始学脚本时，书上都说#! /bin/bash，但是看项目中大神写的脚本，都是#!/usr/bin/env bash，有什么区别呢？ 脚本用env启动的原因，是因为脚本解释器在linux中可能被安装于不同的目录，env可以在系统的PATH目录中查找。同时，env还规定一些系统环境变量。 不同的系统，解释器的路径可能也不同，所以使用绝对路径是比较危险的方式。通过从环境中查找，可以保证兼容性。 获取选项开发中我们经常用到命令，这些命令一般都配合选项达到不同的效果，比如最常用的ls -al，通过\b-a来指定结果包含隐藏文件，通过-l达到列表显示的效果。 通过查询相关资料，我发现获取选项普遍的做法是使用getopts命令，但是这个方法只能获取-h这种短选项，对于--help长选项就不行。 第一种办法是换成getopt命令，但是并不是每个系统都支持这个命令。具体使用和getopts类似，比如getopt -\bo ab:c -l a-long:b-long 第二种方法是把支持的长命令转成短命令，我使用的就是这种方式，相对来说比较容易理解，且case写的比较统一。\b通过shift取出参数，\b再set --的方式重写，最后OPTIND=1把指针指回第一个选项。 文件路径和文件后缀按需求需要判断后缀名来解压，\b那么就需要判断tar.gz之类的问题。同时，如果传入的文件目录是隐藏目录，也会造成一定的障碍。我们假设传入文件路径为/a/.b/c.tar.gz。 ${param#pattern} 从param前面删除pattern的最小匹配${param##pattern} 从param前面删除pattern的最大匹配${param%pattern} 从param后面删除pattern的最小匹配${param%%pattern} 从param后面删除pattern的最大匹配 如果按照${fileName##*.}来截取，那么只能拿到gz。如果按照${fileName#*.}来截取，\b拿到的又是b/c.tar.gz。\b那怎么办呢？ 好在有dirname可以直接获取文件路径，basename拿到文件名，单独对文件名进行${fileName#*.}就可以拿到tar.gz了。 去除不必要的打印执行解压命令时，会打印解压步骤，一般来说也需要显示，那如果我们不想要打印出来呢？\b有一个办法就是在命令之后加上&gt; /dev/null 2&gt;&amp;1 /dev/null ：代表空设备文件 > ：代表重定向到哪里，例如：echo “123” &gt; /home/123.txt 1 ：表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null” 2 ：表示stderr标准错误 &amp; ：表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 所以含义就是把命令输出结果和错误输出重定向，使得输出不在当前屏幕显示，\b由于null比较特殊，向这个文件输入等于进入黑洞，因此达到效果。 数组与空格使用ls | grep的方式来过滤结果获取文件名数组的最大问题是，如果文件名包含空格，那么前后会被分割成两个单元，导致处理比较困难。 比较讨巧的方法是临时用特殊符号代替空格，在使用时再替换回来。这种方法不会改变文件名，也不用写复杂的数组合并，比较符合简单的设计。 12tr \" \" \"?\"$&#123;logName//'?'/' '&#125; 总结通过这次简单的脚本实验，对shell有了新的认识，\b及时记录遇到的问题，相信下次会更有印象。使用脚本，可以让工作更有效率，相信以后也会越用越多。","categories":[{"name":"杂学","slug":"杂学","permalink":"https://vanchchen.github.io/categories/杂学/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://vanchchen.github.io/tags/shell/"}]},{"title":"Category探索","slug":"Category探索","date":"2018-09-17T07:29:29.000Z","updated":"2018-09-17T07:43:14.029Z","comments":true,"path":"2018/09/17/Category探索/","link":"","permalink":"https://vanchchen.github.io/2018/09/17/Category探索/","excerpt":"","text":"什么是\bCategory?Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已经存在的类添加方法，一般称为分类，文件名格式是”\bNSObject+A.h”。 123456789struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; struct property_list_t *_classProperties;&#125; 从结构能看出分类可以扩展实例方法列表、类方法列表、协议列表，也支持扩展属性，但不支持扩展成员变量（之后会说）。 一般使用的场景有扩展现有类方法、代码分区、添加私有方法（不对外暴露category.h）、模拟多继承（使用关联对象的方式添加\b属性实现） 什么是Extension？Extension一般被称为\b类扩展、\b匿名分类，\b用于定义私有属性和方法，不可被继承。只能依附自定义类写于.m中，定义一般为: 12345@interface ViewController ()@\bproperty (nonatomic, strong) NSObject *obj;@end 类扩展支持\b写在多个.h文件，但都必须在.m文件中引用，且不能有自己的实现。 \bCategory与Extension有什么区别？1.分类多用于扩展方法实现，类扩展多用于申明私有变量和方法。 2.类扩展作用在编译期，直接和原类在一起，而分类作用在运行时，加载类的时候动态添加到原类中。 3.类扩展可以定义属性，分类中定义的属性只会申明setter/getter，并没有相关实现和变量。 \bCategory如何加载的？1234567891011121314151617181920212223242526struct objc_class : objc_object &#123; Class superclass; class_data_bits_t bits; class_rw_t *data() &#123; return bits.data(); &#125; ...&#125;struct class_rw_t &#123; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; ...&#125;struct class_ro_t &#123; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; property_list_t *baseProperties; ...&#125;; 先简单了解一下Class\b对象的结构，每个\bobjc_class都包含有class_data_bits_t数据位，其中储存了class_rw_t的指针地址和一些其他标记。class_rw_t中包含有属性方法协议列表，以及class_ro_t指针地址。而在class_ro_t结构中，储存的是编译器决定的属性方法协议。 那么是怎么运行的呢？在编译期类的结构中的\bclass_data_bits_t指向的是一个 class_ro_t指针。 在运行时调用realizeClass方法，初始化一个class_rw_t结构体，设置ro值为原数据中的class_ro_t后设为数据位中的指向，最后调用\bmethodizeClass方法加载。 1234567891011121314151617181920212223242526272829303132333435static void methodizeClass(Class cls)&#123; auto rw = cls-&gt;data(); auto ro = rw-&gt;ro; // Install methods and properties that the class implements itself. method_list_t *list = ro-&gt;baseMethods(); if (list) &#123; prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); rw-&gt;methods.attachLists(&amp;list, 1); &#125; property_list_t *proplist = ro-&gt;baseProperties; if (proplist) &#123; rw-&gt;properties.attachLists(&amp;proplist, 1); &#125; protocol_list_t *protolist = ro-&gt;baseProtocols; if (protolist) &#123; rw-&gt;protocols.attachLists(&amp;protolist, 1); &#125; // Root classes get bonus method implementations if they don't have // them already. These apply before category replacements. if (cls-&gt;isRootMetaclass()) &#123; // root metaclass addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, \"\", NO); &#125; // Attach categories. category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/); attachCategories(cls, cats, false /*don't flush caches*/); if (cats) free(cats);&#125; 可以看到，在methodizeClass中加载了原先类在编译期决定的方法属性和协议，然后获取了未连接的分类表，将列表中的扩展方法添加到运行期类中。 Category方法覆盖\b\b如果不同的分类实现了相同名字的方法，那么调用时会使用最后加入的实现，这是为什么呢？ 加载Categorydyld链接并初始化二进制文件后，交由ImageLoader读取，接着通知runtime\b处理，runtime\b\b调用map_images解析，然后执行_read_images分析文件中包含的类和分类。 123456789101112131415161718192021222324252627282930313233343536373839404142// Discover categories. for (EACH_HEADER) &#123; category_t **catlist = _getObjc2CategoryList(hi, &amp;count); bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties(); for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) &#123; // Category's target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = nil; continue; &#125; // Process this category. // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. bool classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) &#123; remethodizeClass(cls); classExists = YES; &#125; &#125; if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123; addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) &#123; remethodizeClass(cls-&gt;ISA()); &#125; &#125; &#125;&#125; 添加方法属性和协议如果有新增的分类，就\b分别添加到原类和meta类，并通过remethodizeClass更新，具体就是调用attachCategories方法把分类中所有的方法都添加到指定类中。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; bool isMeta = cls-&gt;isMetaClass(); // fixme rearrange to remove these intermediate allocations method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; int propcount = 0; int protocount = 0; int i = cats-&gt;count; bool fromBundle = NO; while (i--) &#123; auto&amp; entry = cats-&gt;list[i]; method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; auto rw = cls-&gt;data(); prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; 123456789101112131415161718192021222324252627282930void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; &#125; 可以看到最后调用了rw-&gt;methods.attachLists(mlists, mcount); 把新增分类中的方法列表添加到实际运行时查询的方法列表\b头部。 在\b进行方法调用时会从头部查询，一旦查到后就返回结果，因此后编译的文件\b中的方法会被优先调用。 同时之前添加的方法实现\b也保存了，可以通过\b获取同名方法的方式查找原类的实现。 Category实现属性分类不能添加成员变量\b属性（Property）包含了成员变量（Ivar）和Setter&amp;Getter。 可以在分类中定义属性，但由于分类是在运行时添加分类属性到类的属性列表中，所以并没有创建对应的成员变量和方法实现。 关联对象如果我们想让分类实现添加新的属性，一般都通过关联对象的方式。12345678910111213141516171819// 声明文件@interface TestObject (Category)@property (nonatomic, strong) NSObject *object;@end// 实现文件static void *const kAssociatedObjectKey = (void *)&amp;kAssociatedObjectKey;@implementation TestObject (Category)- (NSObject *)object &#123; return objc_getAssociatedObject(self, kAssociatedObjectKey);&#125;- (void)setObject:(NSObject *)object &#123; objc_setAssociatedObject(self, kAssociatedObjectKey, object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 这种方式可以实现存取\b对象，但是不能获取_object变量。 参考深入理解Objective-C：Category \b神经病院 Objective-C Runtime 入院第一天—— isa 和 Class 探秘Runtime - 深入剖析Category","categories":[{"name":"面试","slug":"面试","permalink":"https://vanchchen.github.io/categories/面试/"}],"tags":[]},{"title":"iOS面试题","slug":"iOS面试题","date":"2018-09-14T09:40:01.000Z","updated":"2018-09-14T09:42:46.884Z","comments":true,"path":"2018/09/14/iOS面试题/","link":"","permalink":"https://vanchchen.github.io/2018/09/14/iOS面试题/","excerpt":"","text":"iOS基础题 分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？ 讲一下atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？ 被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？ 关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将其指针置空么？ KVO的底层实现？如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？ Autoreleasepool所使用的数据结构是什么？AutoreleasePoolPage结构体了解么？ 讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的？为什么对象方法没有保存的对象结构体里，而是保存在类对象的结构体里？ class_ro_t 和 class_rw_t 的区别？ iOS 中内省的几个方法？class方法和objc_getClass方法有什么区别? 在运行时创建类的方法objc_allocateClassPair的方法名尾部为什么是pair（成对的意思）？ 一个int变量被__block修饰与否的区别？\\12. 为什么在block外部使用__weak修饰的同时需要在内部使用__strong修饰？ RunLoop的作用是什么？它的内部工作机制了解么？（最好结合线程和内存管理来说） 哪些场景可以触发离屏渲染？（知道多少说多少） iOS 实战题 AppDelegate如何瘦身？ 反射是什么？可以举出几个应用场景么？（知道多少说多少） 有哪些场景是NSOperation比GCD更容易实现的？（或是NSOperation优于GCD的几点，知道多少说多少） App 启动优化策略？最好结合启动流程来说（main()函数的执行前后都分别说一下，知道多少说多少） App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？（知道多少说多少） 你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？（知道多少说多少） 你知道有哪些情况会导致app卡顿，分别可以用什么方法来避免？（知道多少说多少） 网络题 App 网络层有哪些优化策略？ TCP为什么要三次握手，四次挥手？ 对称加密和非对称加密的区别？分别有哪些算法的实现？ HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么？ HTTPS是如何实现验证身份和验证完整性的？ 如何用Charles抓HTTPS的包？其中原理和流程是什么？ 什么是中间人攻击？如何避免？ 计算机系统题 了解编译的过程么？分为哪几个步骤？ 静态链接了解么？静态库和动态库的区别？ 内存的几大区域，各自的职能分别是什么？ static和const有什么区别？ 了解内联函数么？ 什么时候会出现死锁？如何避免？ 说一说你对线程安全的理解？ 列举你知道的线程同步策略？ 有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说 设计模式题 除了单例，观察者设计模式以外，还知道哪些设计模式？分别介绍一下 最喜欢哪个设计模式？为什么？ iOS SDK 里面有哪些设计模式的实践？ **设计模式是为了解决什么问题的？ **设计模式的成员构成以及工作机制是什么？ **设计模式的优缺点是什么？ 架构 &amp; 设计题 MVC和MVVM的区别？MVVM和MVP的区别？ 面向对象的几个设计原则了解么？最好可以结合场景来说。 可以说几个重构的技巧么？你觉得重构适合什么时候来做？ 你觉得框架和设计模式的区别是什么？ 看过哪些第三方框架的源码，它们是怎么设计的？设计好的地方在哪里，不好的地方在哪里，如何改进？（这道题的后三个问题的难度已经很高了，如果不是太N的公司不建议深究） 数据结构&amp;算法题 链表和数组的区别是什么？插入和查询的时间复杂度分别是多少？ 哈希表是如何实现的？如何解决地址冲突？ 排序题：冒泡排序，选择排序，插入排序，快速排序（二路，三路）能写出那些？ 链表题：如何检测链表中是否有环？如何删除链表中等于某个值的所有节点？ 数组题：如何在有序数组中找出和等于给定值的两个元素？如何合并两个有序的数组之后保持有序？ 二叉树题：如何反转二叉树？如何验证两个二叉树是完全相等的？ 引用出一套 iOS 高级面试题","categories":[{"name":"面试","slug":"面试","permalink":"https://vanchchen.github.io/categories/面试/"}],"tags":[]}]}