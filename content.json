{"meta":{"title":"Vanch's Blog","subtitle":null,"description":null,"author":"Vanch","url":"https://vanchchen.github.io"},"pages":[{"title":"","date":"2018-09-14T09:54:31.903Z","updated":"2017-11-07T01:57:43.000Z","comments":true,"path":"404.html","permalink":"https://vanchchen.github.io/404.html","excerpt":"","text":"404"},{"title":"categories","date":"2018-09-14T09:13:36.000Z","updated":"2018-09-14T09:15:05.482Z","comments":false,"path":"categories/index.html","permalink":"https://vanchchen.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-14T09:00:14.000Z","updated":"2018-09-14T09:14:24.713Z","comments":false,"path":"tags/index.html","permalink":"https://vanchchen.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Category探索","slug":"Category探索","date":"2018-09-17T07:29:29.000Z","updated":"2018-09-17T07:30:27.569Z","comments":true,"path":"2018/09/17/Category探索/","link":"","permalink":"https://vanchchen.github.io/2018/09/17/Category探索/","excerpt":"","text":"什么是\bCategory?Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已经存在的类添加方法，一般称为分类，文件名格式是”\bNSObject+A.h”。 12345678//定义在runtime.h中struct objc_category &#123; char * category_name; char * class_name; struct objc_method_list * instance_methods; struct objc_method_list * class_methods ; struct objc_protocol_list * protocols;&#125; 从结构能看出分类可以扩展实例方法列表、类方法列表、协议列表，但是不支持扩展属性。 一般使用的场景有扩展现有类方法、代码分区、添加私有方法（不对外暴露category.h）、模拟多继承（使用关联对象的方式添加\b属性实现） 什么是Extension？Extension一般被称为\b类扩展、\b匿名分类，\b用于定义私有属性和方法，不可被继承。只能依附自定义类写于.m中，定义一般为: 123@interface ViewController () @end \bCategory与Extension有什么区别？1.分类多用于扩展方法实现，类扩展多用于定义私有变量和方法。 2.类扩展作用在编译期，直接和原类在一起，而分类作用在运行时，加载类的时候动态添加到原类中。 3.类扩展可以定义属性，分类中定义的属性只会申明setter/getter，并没有相关实现和变量。 \bCategory如何加载的？1234567891011121314151617181920212223242526struct objc_class : objc_object &#123; Class superclass; class_data_bits_t bits; class_rw_t *data() &#123; return bits.data(); &#125; ...&#125;struct class_rw_t &#123; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; ...&#125;struct class_ro_t &#123; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; property_list_t *baseProperties; ...&#125;; 先简单了解一下Class\b对象的结构，每个\bobjc_class都包含有class_data_bits_t数据位，其中储存了class_rw_t的指针地址和一些其他标记。class_rw_t中包含有属性方法协议列表，以及class_ro_t指针地址。而在class_ro_t结构中，储存的是编译器决定的属性方法协议。 那么是怎么运行的呢？在编译期类的结构中的\bclass_data_bits_t指向的是一个 class_ro_t指针。 在运行时调用realizeClass方法，初始化一个class_rw_t结构体，设置ro值为原数据中的class_ro_t后设为数据位中的指向，最后调用\bmethodizeClass方法加载。 1234567891011121314151617181920212223242526272829303132333435static void methodizeClass(Class cls)&#123; auto rw = cls-&gt;data(); auto ro = rw-&gt;ro; // Install methods and properties that the class implements itself. method_list_t *list = ro-&gt;baseMethods(); if (list) &#123; prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); rw-&gt;methods.attachLists(&amp;list, 1); &#125; property_list_t *proplist = ro-&gt;baseProperties; if (proplist) &#123; rw-&gt;properties.attachLists(&amp;proplist, 1); &#125; protocol_list_t *protolist = ro-&gt;baseProtocols; if (protolist) &#123; rw-&gt;protocols.attachLists(&amp;protolist, 1); &#125; // Root classes get bonus method implementations if they don't have // them already. These apply before category replacements. if (cls-&gt;isRootMetaclass()) &#123; // root metaclass addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, \"\", NO); &#125; // Attach categories. category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/); attachCategories(cls, cats, false /*don't flush caches*/); if (cats) free(cats);&#125; 可以看到，在methodizeClass中加载了原先类在编译期决定的方法属性和协议，然后获取了未连接的分类表，将列表中的扩展方法添加到运行期类中。 Category方法覆盖\b\b如果不同的分类实现了相同名字的方法，那么调用时会使用最后加入的实现，这是为什么呢？ 加载Categorydyld链接并初始化二进制文件后，交由ImageLoader读取，接着通知runtime\b处理，runtime\b\b调用map_images解析，然后执行_read_images分析文件中包含的类和分类。 123456789101112131415161718192021222324252627282930313233343536373839404142// Discover categories. for (EACH_HEADER) &#123; category_t **catlist = _getObjc2CategoryList(hi, &amp;count); bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties(); for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) &#123; // Category's target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = nil; continue; &#125; // Process this category. // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. bool classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) &#123; remethodizeClass(cls); classExists = YES; &#125; &#125; if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123; addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) &#123; remethodizeClass(cls-&gt;ISA()); &#125; &#125; &#125;&#125; 添加方法属性和协议如果有新增的分类，就\b分别添加到原类和meta类，并通过remethodizeClass更新，具体就是调用attachCategories方法把分类中所有的方法都添加到指定类中。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; bool isMeta = cls-&gt;isMetaClass(); // fixme rearrange to remove these intermediate allocations method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; int propcount = 0; int protocount = 0; int i = cats-&gt;count; bool fromBundle = NO; while (i--) &#123; auto&amp; entry = cats-&gt;list[i]; method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; auto rw = cls-&gt;data(); prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; 123456789101112131415161718192021222324252627282930void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; &#125; 可以看到最后调用了rw-&gt;methods.attachLists(mlists, mcount); 把新增分类中的方法列表添加到实际运行时查询的方法列表\b头部。 在\b进行方法调用时会从头部查询，一旦查到后就返回结果，因此后编译的文件\b中的方法会被优先调用。 同时之前添加的方法实现\b也保存了，可以通过\b获取同名方法的方式查找原类的实现。 Category实现属性分类不能添加成员变量\b属性（Property）包含了成员变量（Ivar）和Setter&amp;Getter。 可以在分类中定义属性，但由于分类是在运行时添加分类属性到类的属性列表中，所以并没有创建对应的成员变量和方法实现。 关联对象如果我们想让分类实现添加新的属性，一般都通过关联对象的方式。12345678910111213141516171819// 声明文件@interface TestObject (Category)@property (nonatomic, strong) NSObject *object;@end// 实现文件static void *const kAssociatedObjectKey = (void *)&amp;kAssociatedObjectKey;@implementation TestObject (Category)- (NSObject *)object &#123; return objc_getAssociatedObject(self, kAssociatedObjectKey);&#125;- (void)setObject:(NSObject *)object &#123; objc_setAssociatedObject(self, kAssociatedObjectKey, object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 这种方式可以实现存取\b对象，但是不能获取_object变量。 参考深入理解Objective-C：Category \b神经病院 Objective-C Runtime 入院第一天—— isa 和 Class 探秘Runtime - 深入剖析Category","categories":[{"name":"面试","slug":"面试","permalink":"https://vanchchen.github.io/categories/面试/"}],"tags":[]},{"title":"iOS面试题","slug":"iOS面试题","date":"2018-09-14T09:40:01.000Z","updated":"2018-09-14T09:42:46.884Z","comments":true,"path":"2018/09/14/iOS面试题/","link":"","permalink":"https://vanchchen.github.io/2018/09/14/iOS面试题/","excerpt":"","text":"iOS基础题 分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？ 讲一下atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？ 被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？ 关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将其指针置空么？ KVO的底层实现？如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？ Autoreleasepool所使用的数据结构是什么？AutoreleasePoolPage结构体了解么？ 讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的？为什么对象方法没有保存的对象结构体里，而是保存在类对象的结构体里？ class_ro_t 和 class_rw_t 的区别？ iOS 中内省的几个方法？class方法和objc_getClass方法有什么区别? 在运行时创建类的方法objc_allocateClassPair的方法名尾部为什么是pair（成对的意思）？ 一个int变量被__block修饰与否的区别？\\12. 为什么在block外部使用__weak修饰的同时需要在内部使用__strong修饰？ RunLoop的作用是什么？它的内部工作机制了解么？（最好结合线程和内存管理来说） 哪些场景可以触发离屏渲染？（知道多少说多少） iOS 实战题 AppDelegate如何瘦身？ 反射是什么？可以举出几个应用场景么？（知道多少说多少） 有哪些场景是NSOperation比GCD更容易实现的？（或是NSOperation优于GCD的几点，知道多少说多少） App 启动优化策略？最好结合启动流程来说（main()函数的执行前后都分别说一下，知道多少说多少） App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？（知道多少说多少） 你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？（知道多少说多少） 你知道有哪些情况会导致app卡顿，分别可以用什么方法来避免？（知道多少说多少） 网络题 App 网络层有哪些优化策略？ TCP为什么要三次握手，四次挥手？ 对称加密和非对称加密的区别？分别有哪些算法的实现？ HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么？ HTTPS是如何实现验证身份和验证完整性的？ 如何用Charles抓HTTPS的包？其中原理和流程是什么？ 什么是中间人攻击？如何避免？ 计算机系统题 了解编译的过程么？分为哪几个步骤？ 静态链接了解么？静态库和动态库的区别？ 内存的几大区域，各自的职能分别是什么？ static和const有什么区别？ 了解内联函数么？ 什么时候会出现死锁？如何避免？ 说一说你对线程安全的理解？ 列举你知道的线程同步策略？ 有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说 设计模式题 除了单例，观察者设计模式以外，还知道哪些设计模式？分别介绍一下 最喜欢哪个设计模式？为什么？ iOS SDK 里面有哪些设计模式的实践？ **设计模式是为了解决什么问题的？ **设计模式的成员构成以及工作机制是什么？ **设计模式的优缺点是什么？ 架构 &amp; 设计题 MVC和MVVM的区别？MVVM和MVP的区别？ 面向对象的几个设计原则了解么？最好可以结合场景来说。 可以说几个重构的技巧么？你觉得重构适合什么时候来做？ 你觉得框架和设计模式的区别是什么？ 看过哪些第三方框架的源码，它们是怎么设计的？设计好的地方在哪里，不好的地方在哪里，如何改进？（这道题的后三个问题的难度已经很高了，如果不是太N的公司不建议深究） 数据结构&amp;算法题 链表和数组的区别是什么？插入和查询的时间复杂度分别是多少？ 哈希表是如何实现的？如何解决地址冲突？ 排序题：冒泡排序，选择排序，插入排序，快速排序（二路，三路）能写出那些？ 链表题：如何检测链表中是否有环？如何删除链表中等于某个值的所有节点？ 数组题：如何在有序数组中找出和等于给定值的两个元素？如何合并两个有序的数组之后保持有序？ 二叉树题：如何反转二叉树？如何验证两个二叉树是完全相等的？ 引用出一套 iOS 高级面试题","categories":[{"name":"面试","slug":"面试","permalink":"https://vanchchen.github.io/categories/面试/"}],"tags":[]}]}